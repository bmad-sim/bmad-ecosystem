\chapter {Element Attributes}
\label{c:attrib}
\index{element attribute}

%-----------------------------------------------------------------
\section{Dependent and Independent Attributes} 
\label{s:depend} 
\index{element attribute!dependent and independent}

\index{parameter statement}
\index{dependent attribute}
For convenience, \bmad computes the values of some attributes based
upon the values of other attributes. Some of these dependent variables are
listed in Table~\ref{t:dependent}. Also shown in
Table~\ref{t:dependent} are the independent variables they are
calculated from.  In the table \vn{n_part} and \vn{l_lattice} (lattice
length) are lattice attributes, not element attributes. The first two
are set by the \vn{parameter} statement (See
\sref{s:param}). \vn{l_lattice} is calculated when the lattice is read
in.

\index{bbi_constant}\index{charge}\index{sig_x}\index{sig_y}
\index{e_tot}\index{n_part}\index{e_field}\index{voltage}
\index{hkick}\index{vkick}\index{gap}\index{l}
\index{e_tot}\index{e_loss}\index{delta_e}\index{gradient}
\index{l}\index{rho}\index{angle}\index{l_chord}
\index{g}\index{l}\index{k1}\index{rho}\index{num_steps}\index{ds_step}
\index{b_max}\index{e_tot}\index{beambeam}\index{elseparator}
\index{lcavity}\index{rbend}\index{sbend}\index{wiggler}
\begin{table}[ht]
\centering {
\begin{tabular}{|l|l|l|} \hline
 {\em Element}                & {\em Independent Variables}    & {\em Dependent Variables}          \HH
 All elements                 & \vn{ds_step}                   & \vn{num_steps}                     \HH
 \vn{BeamBeam}                & \vn{charge}, \vn{sig_x}, \vn{sig_y}, \vn{e_tot}, \vn{n_part}
                                                               & \vn{bbi_constant}                  \HH
 \vn{Elseparator}             & \vn{hkick}, \vn{vkick}, \vn{gap}, \vn{l}, \vn{e_tot}      
                                                               & \vn{e_field}, \vn{voltage}         \HH
 \vn{Lcavity}                 & \vn{gradient}, \vn{l}          & \vn{e_loss}, \vn{voltage}          \HH
 \vn{Rbend}, \vn{Sbend}       & \vn{g}, \vn{l}                     
                                                               & \vn{rho}, \vn{angle}, \vn{l_chord} \HH

 \vn{Wiggler} (map type)      & \vn{term(i)}                   & \vn{b_max}, \vn{k1}, \vn{rho}      \HH
 \vn{Wiggler} (periodic type) & \vn{b_max}, \vn{e_tot}         & \vn{k1}, \vn{rho}                  \HH
\end{tabular}
}
\caption[Table of dependent variables.]{Partial listing of dependent variables and 
  the independent variables they are calculated from.}
\label{t:dependent}
\end{table}

\index{lattice!expansion}\index{harmon}\index{delta_e}\index{gradient}
\index{rho}\index{g}\index{angle}\index{rf_frequency}
No attempt should be made to set or vary within a program dependent
attributes. It should be remarked that this is not an iron clad rule.
If a program properly bypasses \bmad's attribute bookkeeping routine
then anything is possible. In a lattice file, before lattice expansion
(\sref{s:expand}), \bmad allows the setting of a select group of
dependent attributes if the appropriate independent attributes are
not set. The list of settable dependent variables is given in
Table~\ref{t:dep.except}.  After reading in the lattice \bmad will set
the appropriate independent variable based upon the value of the
dependent variable. \vn{harmon} is the exception in that it will never
be set by the bookkeeping routine.
\index{lcavity}\index{rbend}
\index{sbend}\index{rfcavity}
\begin{table}[ht]
\centering {
\begin{tabular}{|l|l|l|} \hline
{\em Element}                  & {\em Dependent Variable Set}  &  {\em Independent Variables Not Set} \HH
  \vn{Lcavity}                 & \vn{voltage}       & \vn{gradient}      \HH
  \vn{Rbend}, \vn{Sbend}       & \vn{rho}           & \vn{g}             \HH
  \vn{Rbend}, \vn{Sbend}       & \vn{angle}         & \vn{g}, or \vn{l}  \HH
  \vn{RFcavity}                & \vn{rf_frequency}  & \vn{harmon}        \HH
  \vn{Wiggler} (periodic type) & \vn{n_pole}        & \vn{l_pole}        \HH
\end{tabular}
}
\caption {Dependent variables that can be set in a primary lattice file.}
\label{t:dep.except}
\end{table}

\index{g}\index{g_err}\index{b_field}\index{bs_field}\index{b_field_err}
\index{b1_gradient}\index{b2_gradient}\index{b3_gradient}\index{ks}
\index{k1}\index{k2}\index{k3}
\index{bl_kick}\index{bl_hkick}\index{bl_vkick}
\index{kick}\index{hkick}\index{vkick}
The normal attribute used to vary the strength of, say, a
\vn{quadrupole} is \vn{k1}.  It is sometimes convenient to be able to
vary the magnetic field strength directly instead. To do this \bmad
has a rule that if the appropriate field attribute appears in the
primary lattice file then it becomes an independent variable and the
normalized strength attribute (the strength attribute normalized by
the reference energy) becomes a dependent variable as tabulated in
Table~\ref{t:dep.field}.
\index{sbend}\index{rbend}\index{solenoid}\index{quadrupole}
\index{sol_quad}\index{sextupole}\index{octupole}
\begin{table}[ht]
\centering {
\begin{tabular}{|l|l|l|} \hline
  {\em Element} & {\em Normalized Strength} & {\em Field Attribute} \HH
  \vn{Sbend}, \vn{Rbend}     & \vn{g}      &  \vn{b_field}        \HH
  \vn{Sbend}, \vn{Rbend}     & \vn{g_err}  &  \vn{b_field_err}    \HH
  \vn{Solenoid, Sol_quad}    & \vn{ks}     &  \vn{bs_field}       \HH
  \vn{Quadrupole, Sol_quad, Sbend, Rbend}            
                             & \vn{k1}     &  \vn{b1_gradient}    \HH
  \vn{Sextupole, Sbend, Rbend}             
                             & \vn{k2}     &  \vn{b2_gradient}    \HH
  \vn{Octupole}              & \vn{k3}     &  \vn{b3_gradient}    \HH
  \vn{HKicker}, \vn{VKicker} & \vn{kick}   &  \vn{bl_kick}        \HH
  Most                       & \vn{hkick}  &  \vn{bl_hkick}       \HH
  Most                       & \vn{vkick}  &  \vn{bl_vkick}       \HH
\end{tabular}
}
\caption {Field and Strength Attributes.}
\label{t:dep.field}
\end{table}
Using both field strength and normalized strength as the independent
variable for a given element is not permitted. For example, for a quadrupole the 
normalized strengths \vn{k1}, \vn{hkick}, and \vn{vkick} can be used as the
independent variable or the field strengths \vn{b1_gradient}, \vn{bl_hkick} and
\vn{bl_vkick}. but the mixing of the two is not valid
\begin{example}
  Q1: quadrupole, k1 = 0.6, bl_hkick = 37.5  ! NO. Not VALID.
\end{example}
\index{field_master}
To define an element with the field strength as the independent
attribute without setting the strength just set the strength to zero
or, alternatively, the \vn{field_master} logical can be set. For
example
\begin{example}
  Q1: quadrupole, b1_gradient = 0   ! Field strengths now the independent variables
  Q1: quadrupole, field_master = T  ! Same as above
\end{example}
The same effect can be obtained by setting the field or \vn{field_master} attributes
after the element has been defined.
\begin{example}
  q1: quadrupole        ! Define q1.
  q1[b1_gradient] = 0   ! Field strengths now the independent variables.
  q1[field_master] = T  ! Same as above.
\end{example}

%-----------------------------------------------------------------
\section{Type, Alias and Descrip Attributes}
\label{s:alias}
\index{type|hyperbf}
\index{alias|hyperbf}
\index{descrip|hyperbf}

There are three string labels associated with any element:
\begin{example}
  type    = <String>
  alias   = <String>
  descrip = <String>
\end{example}
\bmad routines do not use these labels except when printing element
information. \vn{type} and \vn{alias} can be up to 40 characters in
length and \vn{descrip} can be up to 200 characters. The attribute
strings can be enclosed in double quotation marks ("). The attribute
strings may contain blanks. If the attribute string does not contain a
blank then the quotation marks may be omitted. In this case the first
comma (,) or the end of the line marks the end of the string. Example:
\begin{example}
  Q00W: Quad, type = "My Type", alias = Who_knows, &
                                  descrip = "Only the shadow knows"
\end{example}

%-----------------------------------------------------------------
\section[Energy and Wavelength Attributes]{Energy and Wavelength Attributes: E_tot, P0C, and \\ ref_wavelength }
\label{s:energy}
\index{parameter statement}\index{e_tot}
\index{e_tot_start}\index{p0c_start}
\index{patch}\index{lcavity}\index{p0c}\index{e_gun}
\index{n_ref_pass}\index{ref_wave_length}
The attributes that define the reference energy and momentum at an element are:
\begin{example}
  e_tot  = <Real>  ! Total energy in eV.
  p0c    = <Real>  ! Momentum in eV.
\end{example}
The energy and momentum are defined at the exit end of the element.
For ultra--relativistic particles, and for photons, these two values
are the same (\sref{s:phase.space}). Except for multipass elements
(\sref{s:multipass}), \vn{e_tot} and \vn{p0c} are dependent attributes
and, except for multipass elements, any setting of \vn{e_tot} and
\vn{p0c} in the lattice input file is an error. The value of
\vn{e_tot} and \vn{p0c} for an element is calculated by \bmad to be
the same as the previous element except for \vn{e_gun}, \vn{lcavity} and
\vn{patch} elements. To set the \vn{e_tot} or \vn{p0c} at the start of
the lattice use the \vn{beginning} or \vn{parameter} statements.
See~\sref{s:param}. Since the energy changes from the start to the end
of an \vn{lcavity} or. \vn{em_field}, an \vn{lcavity} or \vn{em_field} has
the dependent attributes
\index{em_field}\index{lcavity}
\begin{example}
  e_tot_start   and
  p0c_start
\end{example}
which are just the reference energy and momentum at the start of the element.

\index{beginning_ele}
The \vn{beginning_ele} element (\sref{s:begin.ele}) also has associated
\vn{e_tot_start} and \vn{p0c_start} attributes as well as \vn{e_tot}
and \vn{p0c}. Generally, for an \vn{beginning_ele}, \vn{p0c_start} and
\vn{p0c} are the same and \vn{e_tot_start} and \vn{e_tot} are the same
and the values for these attributes are set in the lattice file with
the appropriate \vn{parameter} (\sref{s:param}) or \vn{beginning}
(\sref{s:beginning}) statement. The exception occurs when there is an
\vn{e_gun} element in the lattice (\sref{s:e.gun}). In this case, the
\vn{p0c_start} and \vn{e_tot_start} attributes of the \vn{beginning_ele}
are set to the values as set in the lattice file and \vn{e_tot} is set
to
\begin{example}
  e_tot = e_tot_start + voltage
\end{example}
and \vn{p0c} is calculated from \vn{e_tot} and the mass of the
particle being tracked. For example, if the lattice file contained:
\begin{example}
  beginning[p0c] = 0
  gun: e_gun, voltage = 0.5e6
  injector: line = (gun, ...)
\end{example}
Then the following energy values will be set for the beginning \vn{beginning_ele} element:
\begin{example}
  p0c_start   = 0
  e_tot_start = mc2
  e_tot       = mc2 + 0.5e6
  p0c         = Sqrt(e_tot - mc2^2)
\end{example}
where \vn{mc2} is the particle rest mass.  The reason for using this
convoluted convention is to allow the setting, in the lattice file, of
a zero reference momentum at the start of the lattice, while
avoiding the calculational problems that would occur if the \vn{e_gun}
element truly had a starting reference momentum of zero.
Specifically, the problem with zero reference momentum is that the
phase space momentum would be infinity as can be seen from \Eqs{ppp}.

For \vn{multipass} elements, the reference energy is set by specifying
one of \vn{e_tot}, \vn{p0c}, or \vn{n_ref_pass} as described in
\sref{s:multipass}.

For photons, the reference wavelength, \vn{ref_wavelength} is also a
dependent attribute calculated from the reference energy.

\vfill

%-----------------------------------------------------------------
\section{Orientation: Offset, Pitch, Tilt, and Roll Attributes}
\label{s:offset}
\index{x_offset|hyperbf}
\index{y_offset|hyperbf}\index{z_offset|hyperbf}
\index{x_pitch|hyperbf}\index{y_pitch|hyperbf}
\index{roll|hyperbf}\index{tilt|hyperbf}

By default, an element, like a quadrupole, is aligned in space
coincident with the reference orbit running through it
(\sref{s:ref.construct}). A quadrupole can be displaced in space using
the quadrupole's ``\vn{orientational}'' attributes. For a quadrupole,
the orientational attributes only affect the physical element and not
the reference orbit. However, the orientational attributes of some
other elements, like the \vn{fiducial} element, do affect the
reference orbit. To sort all this out, lattice elements can be divided
into seven classes:
  \begin{enumerate}
  \item\vn{Straight line elements} (\sref{ss:straight.orient}) \Newline
Straight line elements are elements where the reference orbit is a
straight line. Examples include \vn{quadrupoles}, and \vn{sextupoles}
as well as zero length elements like \vn{markers}.
  \item\vn{Dipole bends} (\sref{ss:bend.orient}) \Newline
Dipole bends are:
\begin{example}
  sbend \& rbend
\end{example}
  \item\vn{Photon reflecting elements} (\sref{ss:photon.orient}) \Newline
The reflecting elements are
\begin{example}
  crystal
  mirror
  multilayer_mirror
\end{example}
These elements have a kink in the reference orbit at the nominal
element surface.
  \item\vn{Reference orbit manipulator elements} (\sref{ss:manip.orient}) \Newline
Elements that are used to manipulate the reference orbit are
\begin{example}
  fork \& photon_fork
  floor_shift
  patch
\end{example}
  \item\vn{Fiducial Element} (\sref{ss:fiducial.orient}) \Newline
  \item\vn{Girder Elements} (\sref{ss:girder.orient}) \Newline
  \item\vn{Control Elements} \Newline
Control elements are elements that control attributes of other
elements. The control elements are:
\begin{example}
  group
  overlay
\end{example}
These elements do not have orientational attributes.
  \end{enumerate}

%-----------------------------------------------------------------
\subsection{Straight Line Element Orientation}
\label{ss:straight.orient}

The straight line elements have the following orientational attributes:
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  z_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  tilt     = <Real>    
\end{example}
For straight line elements the orientational attributes only shift the
physical element and do not affect the reference orbit.

\begin{figure}[tb]
  \centering
  \includegraphics{pitch.pdf}
  \caption{Geometry of Pitch and Offset attributes}
  \label{f:pitch}
\end{figure}

\vn{x_offset} translates an element in the local $x$--direction
as shown in \fig{f:pitch}. Similarly, \vn{y_offset} and 
\vn{z_offset} translate an element along the local $y$ and 
$z$--directions respectively.

The \vn{x_pitch} attribute rotates an element about the element's
center such that the exit face of the element is displaced in the
$+x$--direction as shown in figure~\ref{f:pitch}.  An
\vn{x_pitch} represents a rotation around the positive $y$-axis.

Similarly, the \vn{y_pitch} attribute rotates an element about the
element's center using the negative $x$--axis as the rotation axis so
that the exit face of the element is displaced in the $+y$--direction.

The \vn{x_pitch} and \vn{y_pitch} rotations are about the center of
the element which is in contrast to the \vn{dtheta} and \vn{dphi}
misalignments of \mad which rotate around the entrance point. The
sense of the rotation between \bmad and MAD is:
\index{MAD!element rotation origin}
\begin{example}
  x_pitch (Bmad) =  dtheta (MAD)
  y_pitch (Bmad) = -dphi (MAD)
\end{example}

\begin{figure}[tb]
  \centering
  \includegraphics{tilt.pdf}
  \caption{Geometry of a Tilt}
  \label{f:tilt}
\end{figure}

The tilt attribute rotates the element in the $(x, y)$ plane as shown
in figure~\ref{f:tilt}. The rotation axis is the positive
$z$-axis. For example
\begin{example}
  q1: quad, l = 0.6, x_offset = 0.03, y_pitch = 0.001, tilt
\end{example}
\index{sol_quad!tilt default}\index{quadrupole!tilt default}
\index{sextupole!tilt default}\index{octupole!tilt default}
Like MAD, \bmad allows the use of the \vn{tilt} attribute without a
value to designate a skew element. The default tilt is $\pi/(2(n+1))$
where $n$ is the order of the element:
\begin{example}
  sol_quad       n = 1
  quadrupole     n = 1
  sextupole      n = 2
  octupole       n = 3
\end{example}

Note that \vn{hkick} and \vn{vkick} attributes are not affected by
\vn{tilt} except for \vn{kicker} and \vn{elseparator} elements.

%-----------------------------------------------------------------
\subsection{Bend Element Orientation}
\label{ss:bend.orient}

\begin{figure}[ht]
  \centering
  \includegraphics{roll.pdf}
  \caption[Geometry of a Bend]{
Geometry of a Bend. Like straight line elements, offsets and pitches
are calculated with respect to the coordinates at the center of the
bend. The exception is the \vn{roll} attribute which is a rotation
around the axis passing through the entrance and exit points.  Shown
here is the geometry for a bend with \vn{ref_tilt} = 0. That is, the bend
is in the $x-z$ plane.}
  \label{f:roll}
\end{figure}

The orientation attributes for \vn{sbend} and \vn{rbend} elements is
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  z_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  ref_tilt = <Real>    ! Shifts and reference orbit rotation axis.
  roll     = <Real>    
\end{example}
The geometry for orienting a bend is shown in \fig{f:roll}. Like
straight line elements, the offset and pitch attributes are evaluated
with respect to the center of the element. 

Unlike the straight line elements, bends do not have a \vn{tilt}
attribute. Rather they have a \vn{ref_tilt} and a \vn{roll} attribute.
The \vn{roll} attribute rotates the bend along an axis that runs
through the entrance point and exit point as shown in
figure~\ref{f:roll}. A \vn{roll} attribute, like the offset and pitch
attributes does not affect the reference orbit.
The major effect of a \vn{roll} is to give a vertical
kick to the beam. For a bend with positive bend angle, a positive
\vn{roll} will move the outside portion ($+x$ side) of the bend upward
and the inside portion (-$x$ side) downward. Much like car racetracks
which are typically slanted towards the inside of a turn.

The \vn{ref_tilt} attribute of a bend rotates the bend about the $z$
axis at the upstream end of the bend as shown in \fig{f:roll}. Unlike
\vn{rolls} and \vn{tilts}, \vn{ref_tilt} also shifts the rotation axis
of the reference orbit along with the physical element. A \vn{bend}
with a \vn{ref_tilt} of $\pi/2$ will bend a beam vertically downward
(\sref{s:global}). Note that the \vn{ref_tilt} attribute of \bmad is
the same as the MAD \vn{tilt} attribute.

%-----------------------------------------------------------------
\subsection{Photon Reflecting Element Orientation}
\label{ss:photon.orient}

\begin{figure}[ht]
  \centering
  \includegraphics{reflect-orient.pdf}
  \caption[Geometry of a photon reflecting element orientation]{
Geometry of a photon reflecting element orientation.
The reference coordinates used for defining the orientational attribute
is the entrance reference coordinates. 
}
  \label{f:reflect.orient}
\end{figure}

Photon reflecting elements have the following orientational attributes:
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  z_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  ref_tilt = <Real>    ! Shifts both element and reference orbit.
  tilt     = <Real>    
\end{example}
Roughly, these elements can be viewed as zero length bends except,
since there is no center position, the orientational attributes are
defined with respect to the entrance coordinates as shown in
\fig{f:reflect.orient}. Like bend elements, the \vn{ref_tilt} attribute
rotates both the physical element and the reference coordinates.
The \vn{tilt} attribute rotates just the physical element. Thus
the total rotation of the physical element about the entrance $z$
axis is the sum \vn{tilt} + \vn{ref_tilt}.

%-----------------------------------------------------------------
\subsection{Reference Orbit Manipulator Element Orientation}
\label{ss:manip.orient}

The \vn{fork}, \vn{photon_fork}, \vn{floor_shift}, and \vn{patch} elements
use the following attributes to orient their exit edge with respect to their
entrance edge:
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  z_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  tilt     = <Real>    
\end{example}
Here "exit" edge for \vn{fork} and \vn{photon_fork} elements is defined
to be the start of the line being branched to. [Within the line containing
the fork, the \vn{fork} element is considered to have zero length so the exit face
in the line containing the fork is coincident with the entrance face.]
The placement of the exit edge for these elements defines the reference orbit.
Thus, unlike the corresponding attributes for other elements, 
the orientational attributes here directly control the reference orbit.

%-----------------------------------------------------------------
\subsection{Fiducial Element Orientation}
\label{ss:fiducial.orient}

The \vn{fiducial} element (\sref{s:girder}) uses the 
following attributes to define its position:
\begin{example}
  origin_ele        = <Name>     ! Reference element.
  origin_ele_ref_pt = <location> ! Reference pt on reference ele.
  dx_origin         = <Real>     ! x-position offset
  dy_origin         = <Real>     ! y-position offset
  dz_origin         = <Real>     ! z-position offset
  dtheta_origin     = <Real>     ! orientation angle offset.
  dphi_origin       = <Real>     ! orientation angle offset.
  dpsi_origin       = <Real>     ! orientation angle offset.
\end{example}
See Section~\sref{s:fiducial} for more details.

%-----------------------------------------------------------------
\subsection{Girder Orientation}
\label{ss:girder.orient}

A \vn{girder} (\sref{s:girder}) element uses the same attributes as a \vn{fiducial}
element (\sref{s:fiducial}) to orient the reference girder position. In addition,
the following attributes are used to move the girder physically from the reference position: 
\begin{example}
  x_offset = <Real>
  y_offset = <Real>
  z_offset = <Real>
  x_pitch  = <Real>
  y_pitch  = <Real>
  tilt     = <Real>    
\end{example}
Shifting the girder from its reference position shifts all the elements that are
supported by the girder. See Section~\sref{s:girder} for more details.

\index{x_offset_tot|hyperbf}\index{y_offset_tot|hyperbf}\index{z_offset_tot|hyperbf}
\index{x_pitch_tot|hyperbf}\index{y_pitch_tot|hyperbf}
\index{tilt_tot|hyperbf}\index{roll_tot|hyperbf}\index{tilt_err_tot|hyperbf}
If an element is supported by a \vn{girder} element (\sref{s:girder}),
the orientational attributes of the element are with respect to the
orientation of the \vn{girder}. The computed offsets, pitches and tilt with
respect to the local reference coordinates are stored in the dependent attributes
\begin{example}
  x_offset_tot
  y_offset_tot
  z_offset_tot
  x_pitch_tot
  y_pitch_tot
  tilt_tot
  roll_tot
\end{example}
\index{sbend}\index{rbend}
A \vn{*_tot} attribute will only be present if the corresponding non
\vn{*_tot} attribute is present. For example, only \vn{sbend} and
\vn{rbend} elements have a \vn{roll_tot} attribute since only these
elements have a \vn{roll} attribute.

If an element is not supported by a \vn{girder}, the values of the
\vn{*_tot} attributes will be the same value as the values of the
corresponding non \vn{*_tot} attributes.

%-----------------------------------------------------------------
\section{Hkick, Vkick, and Kick Attributes}
\label{s:kick}
\index{hkick|hyperbf}\index{bl_hkick|hyperbf}
\index{vkick|hyperbf}\index{bl_vkick|hyperbf}
\index{kick|hyperbf}\index{bl_kick|hyperbf}


\index{hkicker}
\index{vkicker}
\index{elseparator}
\index{kicker}
The kick attributes that an element may have are:
\begin{example}
  kick,  bl_kick  = <Real>  ! Used only with a Hkicker or Vkicker
  hkick, bl_hkick = <Real>
  vkick, bl_vkick = <Real>
\end{example}
\vn{kick}, \vn{hkick}, and \vn{vkick} attributes are the integrated
kick of an element in radians. \vn{kick} is only used for \vn{hkicker}
and \vn{vkicker} elements. All other elements that can kick use
\vn{hkick} and \vn{vkick}. The \vn{tilt} attribute will only rotate a
kick for \vn{hkicker}, \vn{vkicker}, \vn{elseparator} and \vn{kicker}
elements. This rule was implemented so that, for example, the
\vn{hkick} attribute for a skew quadrupole would represent a
horizontal steering. The \vn{bl_kick}, \vn{bl_hkick}, and
\vn{bl_vkick} attributes are the integrated field kick in
\vn{meters-Tesla}. Normally these are dependent attributes except if
they appear in the lattice file (\sref{s:depend}).

For an \vn{elseparator} element, the \vn{hkick} and \vn{vkick} are
appropriate for a positively charged particle. The kick for a
negatively charged particle is opposite this.

%-----------------------------------------------------------------
\section{Aperture and Limit Attributes}
\label{s:limit}
\index{aperture|hyperbf}
\index{limit|hyperbf}
\index{aperture_at|hyperbf}

\begin{figure}[ht]
  \centering
  \includegraphics{apertures.pdf}
  \caption[Apertures for ecollimator and rcollimator elements.]
  {Apertures for ecollimator and rcollimator elements. 
  Positive $s$ points up out of the page.}
  \label{f:limit}
\end{figure}

\index{ecollimator}
\index{rcollimator}
\index{x_limit|hyperbf}
\index{y_limit|hyperbf}
\index{x1_limit|hyperbf}
\index{y1_limit|hyperbf}
\index{x2_limit|hyperbf}
\index{y2_limit|hyperbf}
\index{x_offset|hyperbf}
\index{offset_moves_aperture|hyperbf}
\index{aperture_type}
The aperture attributes are:
\begin{example}
  x1_limit      = <Real>      ! Horizontal, negative side, aperture limit
  x2_limit      = <Real>      ! Horizontal, positive side, aperture limit
  y1_limit      = <Real>      ! Vertical, negative side, aperture limit
  y2_limit      = <Real>      ! Vertical, positive side, aperture limit
  x_limit       = <Real>      ! Alternative to specifying x1_limit and x2_limit
  y_limit       = <Real>      ! Alternative to specifying y1_limit and y2_limit
  aperture      = <Real>      ! Alternative to specifying x_limit and y_limit
  aperture_at   = <Switch>    ! What end aperture is at. (\sref{ss:ap.place})
  aperture_type = <Switch>    ! What type of aperture it is
  offset_moves_aperture = <Logical> ! Element offsets affect aperture position (\sref{ss:offset.ap})
\end{example}
\vn{x1_limit}, \vn{x2_limit}, \vn{y1_limit}, and \vn{y2_limit} specify
the half--width of the aperture of an element as shown in
figure~\ref{f:limit}. A zero \vn{x1_limit}, \vn{x2_limit},
\vn{y1_limit}, or \vn{y2_limit} is interpreted as no aperture in the
appropriate plane.

By default, apertures are assumed to be rectangular except that an
\vn{ecollimator} has a elliptical aperture. This can be changed by
setting the \vn{aperture_type} attribute. The possible values of this
attribute are:
\begin{example}
  auto         ! Default for diffraction_plate elements
  custom
  elliptical   ! Default for \vn{ecollimator} elements
  rectangular  ! Default for most elements.
\end{example}
The \vn{custom} setting is used in the case where programs have been
compiled with custom, non-Bmad, code to handle the aperture
calculation.  The \vn{auto} setting is used for automatic calculation
of a rectangular aperture. For a \vn{diffraction_plate} element, the
\vn{auto} setting causes the four aperture limits to be set to just
cover the clear area of a \vn{diffraction_plate}
(\sref{s:wall.diff.plate}). For all other elements, the \vn{auto}
setting is only to be used when there is an associated surface grid
(\sref{s:surf.grid}) for the element and, in this case, \bmad to set
the four limits to just cover the surface grid

To avoid numerical overflow and other errors in tracking, a particle
will be considered to have hit an aperture in an element, even if
there are no apertures set for that element, if its orbit exceeds 1000
meters. Additionally, there are other situations where a particle will
be considered lost. For example, if a particle's trajectory does
not intersect the output face in a bend.

For convenience, \vn{x_limit} can be used to set \vn{x1_limit} and
\vn{x2_limit} to a common value. Similarly, \vn{y_limit} can be used
to set \vn{y1_limit} and \vn{y2_limit}.  The \vn{aperture} attribute
can be use to set all four \vn{x1_limit}, \vn{x2_limit}, \vn{y1_limit}
and \vn{y2_limit} to a common value. Internally, the \bmad code does {\em not}
store \vn{x_limit}, \vn{y_limit}, or \vn{aperture}. This means that
using \vn{x_limit}, \vn{y_limit} or aperture in arithmetic expressions is
an error:
\begin{example}
  q2: quad, aperture = q1[aperture]   ! THIS IS AN ERROR!
  q2: quad, aperture = q1[x1_limit]   ! Correct
\end{example}

Examples:
\begin{example}
  q1, quadrupole, y1_limit = 0.03
  q1[y2_limit] = 0.03
  q1[y_limit] = 0.03  ! equivalent to the proceeding 2 lines.  
  q1[aperture_at] = both_ends
\end{example}

%-----------------------------------------------------------------
\subsection{Apertures and Element Offsets}
\label{ss:offset.ap}

\index{tilt}
\index{x_offset}
\index{y_offset}
\index{x_pitch}
\index{y_pitch}
\index{rcollimator}\index{ecollimator}
\index{multilayer_mirror}\index{mirror}\index{crystal}
Normally, whether a particle hits an aperture or not is evaluated
independent of any element offsets (\sref{s:offset}). This is
equivalent to the situation where a beam pipe containing an aperture
is independent of the placement of the physical element the beam pipe
passes through. That is, the beam pipe does not ``touch'' the physical
element. This can be changed by setting the \vn{offset_moves_aperture}
attribute to \vn{True}. In this case any offsets or pitches will be
considered to have shifted the aperture boundary. The exceptions here
is that the default for the following elements is for
\vn{offset_moves_aperture} to be \vn{True}:
\begin{example}
  rcollimator, 
  ecollimator,
  multilayer_mirror, 
  mirror, and 
  crystal 
\end{example}

Even with \vn{offset_moves_aperture} set to \vn{True}, \vn{tilt}s will
not affect the aperture calculation. This is done, for example, so
that the tilt of a skew quadrupole does not affect the aperture. The
exception here is that tilting an \vn{rcollimator} or \vn{ecollimator}
element will tilt the aperture. Additionally, when the aperture is at
the \vn{surface} (see below), any \vn{tilt} will be used in the
calculation.

Example:
\begin{example}
  q1: quad, l = 0.6, x1_limit = 0.045, offset_moves_aperture = T
\end{example}

%-----------------------------------------------------------------
\subsection{Aperture Placement}
\label{ss:ap.place}

\index{both_ends|hyperbf}\index{continuous|hyperbf}
\index{entrance_end|hyperbf}\index{exit_end|hyperbf}
\index{surface|hyperbf}\index{aperture_at}\index{no_aperture}
By default, for most elements, the aperture is evaluated at the exit face of the
element. This can be changed by setting the \vn{aperture_at} attribute.
Possible settings for \vn{aperture_at} are:
\begin{example}
  entrance_end
  exit_end       ! Default for most elements
  both_ends
  continuous
  surface  
  no_aperture
\end{example}
The \vn{exit_end} setting is the default for most elements except for
the following elements who have a default of \vn{surface}:
\index{mirror}\index{multilayer_mirror}\index{crystal}
\index{diffraction_plate}\index{sample}
\begin{example}
  crystal
  diffraction_plate
  mirror
  multilayer_mirror
  sample
\end{example}

In fact, for the following elements:
\begin{example}
  mirror, 
  multilayer_mirror
  crystal
\end{example}
The \vn{surface} setting for \vn{aperture_at} must be used.
Additionally, due to the complicated geometry of these elements, to
keep things conceptionally simple, the rule is imposed that, for an
aperture at the surface, the \vn{offset_moves_aperture} setting must
be left in its default state of True. Additionally, For
\vn{entrance_end} or \vn{exit_end} apertures,
\vn{offset_moves_aperture} must be set to False.

Note: The entrance and exit ends of an element are independent of
which direction particles are tracked through an element. Thus if a
particle is tracked backwards it enters an element at the ``exit end''
and exits at the ``entrance end''. The \vn{continuous} setting
indicates that the aperture is continuous along the length of the
element. This only matters when particle tracking involves stepping
through an element a little bit at a time. For example, as in
Runge-Kutta tracking (\sref{s:tkm}). For tracking where a formula is
used to transform the particle coordinates at the entrance of an
element to the coordinates at the exit end, the aperture is only
checked at the end points so, in this situation, a \vn{continuous}
aperture is equivalent to the \vn{both_ends} setting.

Examples:
\begin{example}
  q2: quad, aperture_type = elliptical, aperture_at = continuous
  q1: quad, l = 0.6, x1_limit = 0.045, offset_moves_aperture = T
\end{example}

%-----------------------------------------------------------------
\subsection{Apertures and X-Ray Generation}
\label{s:aper.x.ray}

With X-ray simulation apertures can be used by \bmad to limit the
directions in which photons are generated. This can greatly decrease
simulation times. For example, a photon passing through a
\vn{diffraction_plate} element will diffract in an arbitrary
direction. If a {\em downstream} element has an aperture set, \bmad
can restrict the velocity directions so that the photons will fill the
downstream aperture and the amount of time wasted tracking photons
that ultimately would be collimated is minimal.

%-----------------------------------------------------------------
\section{X-Rays Crystal \& Compound Materials}
\label{s:cryst.list}

For basic crystallographic and X-ray matter interaction cross-sections,
\bmad uses the XRAYLIB\cite{b:xraylib} library. Crystal structure
parameters in XRAYLIB are mainly from R.~W.~G.~Wyckoff\cite{b:wyckoff}
with some structure parameters coming from NIST. The list of available
structures is:
\begin{center}
\begin{tabular}{llll}
AlphaAlumina & GaP       & KCl        & Platinum  \\
AlphaQuartz  & GaSb      & KTP        & RbAP      \\
Aluminum     & Ge        & LaB6       & Sapphire  \\
Be           & Gold      & LaB6_NIST  & Si        \\
Beryl        & Graphite  & LiF        & Si_NIST   \\
Copper       & InAs      & LiNbO3     & Si2       \\
CsCl         & InP       & Muscovite  & SiC       \\
CsF          & InSb      & NaCl       & Titanium  \\
Diamond      & Iron      & PET        & TlAP      \\
GaAs         & KAP       &            &           \\
\end{tabular}
\end{center}
These names are case sensitive

Besides the above crystal list, \bmad can calculate structure factors
for all the elements and the following list of materials. Material
properties are from NIST. These names are case sensitive. That is, the
NIST materials all use upper case. As noted in the table, several of
the materials may be specified using the appropriate chemical
formula. For example, liquid water may be referenced using the name
\vn{H2O}.
\begin{center}
\footnotesize
\begin{longtable}{lll}
\multicolumn{3}{r}{{\normalsize Continued on next page}} \\
\endfoot
\endlastfoot
A_150_TISSUE_EQUIVALENT_PLASTIC     & LITHIUM_TETRABORATE                       \\
ACETONE                             & LUNG_ICRP                                 \\
ACETYLENE                           & M3_WAX                                    \\
ADENINE                             & MAGNESIUM_CARBONATE                       \\
ADIPOSE_TISSUE_ICRP                 & MAGNESIUM_FLUORIDE                        \\
AIR_DRY_NEAR_SEA_LEVEL              & MAGNESIUM_OXIDE                           \\
ALANINE                             & MAGNESIUM_TETRABORATE                     \\
ALUMINUM_OXIDE, Al2O3               & MERCURIC_IODIDE                           \\
AMBER                               & METHANE                                   \\
AMMONIA, NH3                        & METHANOL                                  \\
ANILINE                             & MIX_D_WAX                                 \\
ANTHRACENE                          & MS20_TISSUE_SUBSTITUTE                    \\
B_100_BONE_EQUIVALENT_PLASTIC       & MUSCLE_SKELETAL                           \\
BAKELITE                            & MUSCLE_STRIATED                           \\
BARIUM_FLUORIDE                     & MUSCLE_EQUIVALENT_LIQUID_WITH_SUCROSE     \\
BARIUM_SULFATE                      & MUSCLE_EQUIVALENT_LIQUID_WITHOUT_SUCROSE  \\
BENZENE, C6H6                       & NAPHTHALENE                               \\
BERYLLIUM_OXIDE                     & NITROBENZENE                              \\
BISMUTH_GERMANIUM_OXIDE             & NITROUS_OXIDE                             \\
BLOOD_ICRP                          & NYLON_DU_PONT_ELVAMIDE_8062               \\
BONE_COMPACT_ICRU                   & NYLON_TYPE_6_AND_TYPE_6_6                 \\
BONE_CORTICAL_ICRP                  & NYLON_TYPE_6_10                           \\
BORON_CARBIDE, B4C                  & NYLON_TYPE_11_RILSAN                      \\
BORON_OXIDE, B2O3                   & OCTANE_LIQUID                             \\
BRAIN_ICRP                          & PARAFFIN_WAX                              \\
BUTANE                              & N_PENTANE                                 \\
N_BUTYL_ALCOHOL                     & PHOTOGRAPHIC_EMULSION                     \\
C_552_AIR_EQUIVALENT_PLASTIC        & PLASTIC_SCINTILLATOR_VINYLTOLUENE_BASED   \\
CADMIUM_TELLURIDE                   & PLUTONIUM_DIOXIDE                         \\
CADMIUM_TUNGSTATE                   & POLYACRYLONITRILE                         \\
CALCIUM_CARBONATE                   & POLYCARBONATE_MAKROLON_LEXAN              \\
CALCIUM_FLUORIDE                    & POLYCHLOROSTYRENE                         \\
CALCIUM_OXIDE                       & POLYETHYLENE                              \\
CALCIUM_SULFATE                     & POLYETHYLENE_TEREPHTHALATE_MYLAR          \\
CALCIUM_TUNGSTATE                   & POLYMETHYL_METHACRALATE_LUCITE_PERSPEX    \\
CARBON_DIOXIDE                      & POLYOXYMETHYLENE                          \\
CARBON_TETRACHLORIDE                & POLYPROPYLENE                             \\
CELLULOSE_ACETATE_CELLOPHANE        & POLYSTYRENE                               \\
CELLULOSE_ACETATE_BUTYRATE          & POLYTETRAFLUOROETHYLENE_TEFLON            \\
CELLULOSE_NITRATE                   & POLYTRIFLUOROCHLOROETHYLENE               \\
CERIC_SULFATE_DOSIMETER_SOLUTION    & POLYVINYL_ACETATE                         \\
CESIUM_FLUORIDE                     & POLYVINYL_ALCOHOL                         \\
CESIUM_IODIDE                       & POLYVINYL_BUTYRAL                         \\
CHLOROBENZENE                       & POLYVINYL_CHLORIDE                        \\
CHLOROFORM                          & POLYVINYLIDENE_CHLORIDE_SARAN             \\
CONCRETE_PORTLAND                   & POLYVINYLIDENE_FLUORIDE                   \\
CYCLOHEXANE                         & POLYVINYL_PYRROLIDONE                     \\
12_DDIHLOROBENZENE                  & POTASSIUM_IODIDE                          \\
DICHLORODIETHYL_ETHER               & POTASSIUM_OXIDE                           \\
12_DICHLOROETHANE                   & PROPANE                                   \\
DIETHYL_ETHER                       & PROPANE_LIQUID                            \\
NN_DIMETHYL_FORMAMIDE               & N_PROPYL_ALCOHOL                          \\
DIMETHYL_SULFOXIDE                  & PYRIDINE                                  \\
ETHANE                              & RUBBER_BUTYL                              \\
ETHYL_ALCOHOL                       & RUBBER_NATURAL                            \\
ETHYL_CELLULOSE                     & RUBBER_NEOPRENE                           \\
ETHYLENE                            & SILICON_DIOXIDE                           \\
EYE_LENS_ICRP                       & SILVER_BROMIDE                            \\
FERRIC_OXIDE                        & SILVER_CHLORIDE                           \\
FERROBORIDE                         & SILVER_HALIDES_IN_PHOTOGRAPHIC_EMULSION   \\
FERROUS_OXIDE                       & SILVER_IODIDE                             \\
FERROUS_SULFATE_DOSIMETER_SOLUTION  & SKIN_ICRP                                 \\
FREON_12                            & SODIUM_CARBONATE                          \\
FREON_12B2                          & SODIUM_IODIDE                             \\
FREON_13                            & SODIUM_MONOXIDE                           \\
FREON_13B1                          & SODIUM_NITRATE                            \\
FREON_13I1                          & STILBENE                                  \\
GADOLINIUM_OXYSULFIDE               & SUCROSE                                   \\
GALLIUM_ARSENIDE                    & TERPHENYL                                 \\
GEL_IN_PHOTOGRAPHIC_EMULSION        & TESTES_ICRP                               \\
GLASS_PYREX                         & TETRACHLOROETHYLENE                       \\
GLASS_LEAD                          & THALLIUM_CHLORIDE                         \\
GLASS_PLATE                         & TISSUE_SOFT_ICRP                          \\
GLUCOSE                             & TISSUE_SOFT_ICRU_FOUR_COMPONENT           \\
GLUTAMINE                           & TISSUE_EQUIVALENT_GAS_METHANE_BASED       \\
GLYCEROL                            & TISSUE_EQUIVALENT_GAS_PROPANE_BASED       \\
GUANINE                             & TITANIUM_DIOXIDE                          \\
GYPSUM_PLASTER_OF_PARIS             & TOLUENE                                   \\
N_HEPTANE                           & TRICHLOROETHYLENE                         \\
N_HEXANE                            & TRIETHYL_PHOSPHATE                        \\
KAPTON_POLYIMIDE_FILM               & TUNGSTEN_HEXAFLUORIDE                     \\
LANTHANUM_OXYBROMIDE                & URANIUM_DICARBIDE                         \\
LANTHANUM_OXYSULFIDE                & URANIUM_MONOCARBIDE                       \\
LEAD_OXIDE                          & URANIUM_OXIDE                             \\
LITHIUM_AMIDE                       & UREA                                      \\
LITHIUM_CARBONATE                   & VALINE                                    \\
LITHIUM_FLUORIDE                    & VITON_FLUOROELASTOMER                     \\
LITHIUM_HYDRIDE                     & WATER_LIQUID, H2O                         \\
LITHIUM_IODIDE                      & WATER_VAPOR                               \\
LITHIUM_OXIDE                       & XYLENE                                    \\
\end{longtable}
\end{center}

%-----------------------------------------------------------------

\begin{figure}[tb]
  \centering
  \includegraphics[width=5in]{surface-curvature.pdf}
  \caption[Surface curvature geometry.]
{Surface curvature geometry. The element reference frame used to
describe surface curvature has the $x$ axis pointing towards the
interior of the element, and the $z$ axis along the plane defined by
the entrance and exit reference orbit.}
  \label{f:surface}
\end{figure}

%-----------------------------------------------------------------
\section{Surface Properties for X-Ray elements}
\label{s:s.curve}

The following X-ray elements have a surface which X-rays impinge upon:
\begin{example}
  crystal               \sref{s:crystal}
  detector              \sref{s:detector}
  diffraction_plate     \sref{s:diff.plate}
  mirror, and           \sref{s:mirror}
  multilayer_mirror     \sref{s:multilayer}
  sample                \sref{s:sample}
\end{example}
[There is also the \vn{capillary} element but this element specifies
its surface differently.]

The coordinate system used for characterizing the curvature of a
surface is the element reference frame as shown in
\fig{f:surface}). This coordinate system has the $x$ axis pointing
towards the interior of the element, and the $z$ axis along the plane
defined by the entrance and exit reference orbit. In this coordinate system, 
the surface curvature is parameterized by
a fourth order polynomial in $z$ and $y$
\Begineq
  {-z} = \sum_{2 \le i+j \le 6} c_{ij} \, x^i \, y^j
  \label{xs2ij4}
\Endeq
The coefficients are set in the lattice file by setting the following
element attributes
\index{surface curveture}
\begin{example}
  curvature_xM_yN      = <Real>   
\end{example}
where \vn{M} and \vn{N} are integers in the range 0 through 6 with the restriction
\begin{example}
  2 \(\le\) M + N \(\le\) 6
\end{example}
Example:
\begin{example}
  c2: crystal, curvature_x2_y0 = 37, ...
\end{example}
in this example, \vn{curvature_x2_y0} corresponds to the $c_{20}$ term
in \Eq{xs2ij4}. To get the effect of a nonzero $x^0\, y^0$, $x^1 \,
y^0$, or $x^0 \, y^1$ terms (since corresponding \vn{curvature_xN_yM}
are not permitted), element offsets and pitches can be used
(\sref{s:offset}).

Some useful formulas: Series expansion for a circle of radius $R$:
\Begineq
  {-z} = \frac{x^2}{2 \, R} + \frac{x^4}{8 \, R^3} + \frac{x^6}{16 \, R^5} +
         \frac{y^2}{2 \, R} + \frac{y^4}{8 \, R^3} + \frac{y^6}{16 \, R^5} +
         \frac{x^2 \, y^2}{4 \, R^3} + \frac{3 \, x^4 \, y^2}{16 \, R^5} +
         \frac{3 \, x^2 \, y^4}{16 \, R^5} 
\Endeq
If $p$ is the distance from the source to the crystal, and $q$ is the
distance from the crystal to the detector, the radius of the Rowland
circle $R_s$ in the sagittal plane is given by\cite{b:del.rio}
\Begineq
  \frac{1}{p} + \frac{1}{q} = \frac{\sin\theta_{g,in} + \sin\theta_{g,out}}{R_s}
\Endeq
where $\theta_{g,in}$ and $\theta_{g,out}$ are the entrance and exit
graze angles. In the transverse plane (also called meridional plane),
the radius $R_t$ needed for foucusing is
\Begineq
  \frac{\sin^2\theta_{g,in}}{p} + \frac{\sin^2\theta_{g,out}}{q} = \frac{\sin\theta_{g,in} + \sin\theta_{g,out}}{R_t}
\Endeq

Example:
\begin{example}
  t_bragg = 1.3950647
  rt = 1  ! Crystal transverse radius
  rs = rt*(sin(t_bragg))^2
  c: crystal, crystal_type =  'Si(553)', b_param = -1,
        curvature_x0_y2 =  1 / (2 * rs), curvature_x0_y4 = 1 / (8 * rs^3),
        curvature_x2_y0 = 1 / (2 * rt), curvature_x4_y0 = 1 / (8 * rt^3),
\end{example}

%-----------------------------------------------------------------
\subsection{Surface Grid}
\label{s:surf.grid}
\index{surface grid}

A surface can be broken up into a grid of rectangles. This is useful,
for example, in breaking up a \vn{detector} element into pixel photo
receptors or in simulating a rough serface for \vn{crystal}s and other
elements. The general syntax is:
\begin{example}
  surface = \{
    grid = \{                
      type = <type_name>,                ! Crystals: Off, Segmented, or H_Misalign
      ix_bounds = (<ix_min>, <ix_max>),  ! Min/max index bounds in x-direction
      iy_bounds = (<iy_min>, <iy_max>),  ! Min/max index bounds in y-direction
      r0 = (<x0>, <y0>),                 ! (x,y) coordinates at grid origin
      dr = (<dx>, <dy>),                 ! width and height of pixels.
      pt(<i>,<j>) = (<x_pitch>, <y_pitch>, <x_pitch_rms>, <x_pitch_rms>),
          \} \}
\end{example}
Example:
\begin{example}
  ccd: crystal, surface = \{
          grid = \{
            type = h_misalign,
            r0 = (0.0, 0.01), dr = (0.005, 0.005),
            ix_bounds = (1, 57), iy_bounds = (-30, 10),
            pt(1,-30) = (0.001, -0.002, 0, 0), 
            pt(1,-29) = ..., 
          \} \}
\end{example}

The grid is a two dimensional with bounds given by the \vn{ix_bounds}
and \vn{iy_bounds} components. These two components must be present. In
the above example the grid is 57 pixels in $x$ and 41 pixels in $y$.

The physical placement of the grid on the element is determined by the
\vn{r0} and \vn{dr} components. \vn{r0} is optional and gives the
$(x,y)$ coordinates of the center of the pixel with index $(0,0)$. The
\vn{dr} component, which must be present, gives the pixal width and
height. Thus the center of the $(i,j)$ pixel is:
\begin{example}
  (x,y) = (r0(1), r0(2)) + (i*dr(1), j*dr(2))
\end{example}

The \vn{type} component of the grid is used for
\vn{crystal} elements only. Possible \vn{type} values are:
\begin{example}
  H_Misalign         ! Misalignment of crystal H vector
  Off                ! Ignore grid
  Segmented          ! Surface is a matrix of flat rectangles
\end{example}
\vn{H_Misalign} misaligns the $H$ vector which is the normal to the
diffracting planes of the the crystal (\sref{s:crystal.tracking}).
When using \vn{H_Misalign}, each \vn{pt(i,j)} component gives the
misalignment of $H$ for the corresponding pixel. For an individual
photon, the misalignt of $H$ will be
\begin{example}
  x_pitch_tot = <x_pitch> + r1 * <x_pitch_rms>
  y_pitch_tot = <y_pitch> + r2 * <y_pitch_rms>
\end{example}
where \vn{x_pitch_tot} and \vn{y_pitch_tot} are the rotational
misalignment (\sref{s:offset}) used in the calculation, the quantities
in brackets \vn{<...>} are components of \vn{pt}, and \vn{r1} and
\vn{r2} are Gaussian distributed random numbers with unit rms. These
random numbers are regenerated for each photon. Note: \vn{pt} is only
used with \vn{H_Misalign}.

When the \vn{type} component is set to \vn{Segmented}, the crystal
surface is modeled as a grid of flat ``rectangles'' (the actual shape
is very close but not quite rectangular). Using a segmented crystal
only makes sense when the crystal is curved. There is one rectangle
for each pixel. Each rectangle has an extent in the $(x,y)$ transverse
dimensions equal to the extent of the corresponding pixel. The $z$
coordinate of the vertices of the rectangular are adjusted so that 
\begin{example}
  1) The rectangle is flat
  2) The rectangle contacts the unsegmented surface two diagonally opposite vertices.
  3) The other two diagonnaly opposite vertices will be as close as possible in the
     least squares sense from the unsegmented surface.
\end{example}

When the \vn{type} component is set to \vn{Off}, the grid will not be used.

%-----------------------------------------------------------------
\section{Walls: Vacuum Chamber, Capillary and Diffraction Plate}
\label{s:wall}
\index{wall}

The \vn{wall} attribute for an element is used to define:
\begin{example}
  vacuum chamber wall
  capillary element (\sref{s:capillary}) inside wall
  diffraction_plate (\sref{s:diff.plate}) geometry
\end{example}

The topics of the following subsections are:
\begin{example}
  \sref{s:wall.syntax}      General wall syntax.
  \sref{s:wall.section}      Cross-section construction. 
  \sref{s:wall.interpolation}      Capillary and vacuum chamber wall interpolation.
  \sref{s:wall.capillary}      Capillary specific.
  \sref{s:wall.vacuum}      Vacuum chamber specific.
  \sref{s:wall.diff.plate}      Diffraction_plate specific.
\end{example}

%-----------------------------------------------------------------
\subsection{Wall Syntax}
\label{s:wall.syntax}

The syntax of the \vn{wall} attribute is:
\begin{example}
  wall = \{
    superimpose = <T/F>,                     ! Chamber wall only
    thickness = <real>                       ! Default thickness. 
    opaque_material = <material_type>        ! Default opaque material. 
    clear_material = <material_type>         ! Default clear material. 
    section = \{ 
      type = <section_type>,                 ! Chamber and Diffraction_plate only
      s = <longitudinal_position>,           ! Relative to beginning of element.
      x0 = <value>, y0 = <value>,            ! Section origin
      material = <material_type>             ! Diffraction_plate only.
      thickness = <real>                     ! Diffraction_plate only.
      dr_ds = <value>,                       ! Capillary and Chamber only
      v(1) = \{<x>, <y>, <radius_x>, <radius_y>, <tilt>\}, 
      v(2) = \{ ... \},
      ...\},
    section = \{
      s = <longitudinal_position>, 
      v(1) = \{... \},
      ... \},
    ... \}
\end{example}
A \vn{wall} begins with ``\vn{wall = \{}'' and ends with a
``\vn{\}}''. In between are a number of individual cross-section
structures. Each individual cross-section begins with ``\vn{section =
\{}'' and ends with a ``\vn{\}}''. The \vn{s} parameter of a
cross-section gives the longitudinal position of the cross-section.
Example:
\begin{example}
  this_cap: capillary, 
    wall = \{   
      section = \{ ! cross-section with top/bottom symmetry
        s = 0, v(1) =  \{0.02, 0.00\}, 
        v(2) = \{0.00, 0.02, 0.02\}, v(3) = \{-0.01, 0.01\} \}, 
      section = \{  ! Cross-section that is a tilted ellipse.
        s = 0.34, 
        v(1) = \{0.003, -0.001, 0.015, 0.008, 0.2*pi\} \} \}
\end{example}
In this example an element called \vn{this_cap} is a \vn{capillary}
whose wall is defined by two cross-sections.

%------------------

\begin{figure}[tb]
  \centering
  \includegraphics[width=6in]{chamber-wall.pdf}
  \caption[Capillary or vacuum chamber wall.]
{A) The inside wall of a capillary or the vacuum chamber wall of a
non-capillary element is defined by a number of cross-sectional
slices.  B) Each cross-section is made up of a number of vertices. The
segments between the vertices can be either a line segment, the arc of
a circle, or a section of an ellipse.}
  \label{f:chamber.wall}
\end{figure}

%-----------------------------------------------------------------
\subsection{Wall Sections}
\label{s:wall.section}

The wall is defined by a number of cross-sectional slices. For
\fig{f:chamber.wall}A shows the geometry for \vn{capillary} or vacuum
chamber walls.  Each cross-section is defined by a longitudinal
position $s$ relative to the beginning of the element and a number of
vertices. The verticies are defined with respect to the local sector
origin $(x_0, y_0)$. The arc between each vertex may be either a
straight line, an arc of a circle, or a section of an ellipse. For a
capillary it is mandatory that a cross-section be convex. That is,
given any two points within the cross-section, all points on the line
segment connecting them must be within the cross-section.

The \vn{v(<j>)} within a cross-section define the vertices for each
cross-section. The vertices are defined with respect to the section
origin given by \vn{x0} and \vn{y0}. Each \vn{v(<j>)} has five
parameters. It is mandatory to specify the first two parameters
\vn{<x>} and \vn{<y>}. Specifying the rest, \vn{<radius_x>},
\vn{<radius_y>}, and \vn{<tilt>}, is optional. The default values, if
not specified, is zero. The point (\vn{<x>}, \vn{<y>}) defines the
position of the vertex. The parameters \vn{<radius_x>},
\vn{<radius_y>}, and \vn{<tilt>} define the shape of the segment of
the cross-section between the given vertex and the preceding one.
\begin{example}
  <radius_x>  = 0, <radius_y>  = 0   --> Straight line segment.
  <radius_x> != 0, <radius_y>  = 0   --> Circular arc with radius = radius_x
  <radius_x>  = 0, <radius_y> != 0   --> Illegal!
  <radius_x> != 0, <radius_y> != 0   --> Ellipse section.
\end{example}
When an ellipse is specified, \vn{<radius_x>}, and \vn{<radius_y>} are
the half width and half height of the semi-major axes and the
\vn{<tilt>} parameter gives the tilt of the ellipse. \vn{<radius_x>}
and \vn{<radius_y>} must not be negative.

In the example above, for the first cross-section, \vn{v(2)}
specifies a non-zero \vn{<radius_x>} and, by default, \vn{<radius_y>}
is zero. Thus the segment of the cross-section between \vn{v(1)} and
\vn{v(2)} is circular in nature with a radius of 0.02. Since \vn{v(3)}
does not specify \vn{<radius_x>} nor \vn{<radius_y>}, the
cross-section between \vn{v(2)} and \vn{v(3)} is a straight line
segment.

The vertex points must be arranged in a ``counter clockwise manner''. 
For vertices \vn{<v(i)>} and \vn{<v(i+1)>} connected by a line segment
this translates to
\Begineq
  0 < \theta_{i+1} - \theta_{i} \pmod{2\pi} < \pi
\Endeq
where $(r_n, \theta_n)$ are the polar coordinates of the $n^{th}$
vertex. For vertices connected by an arc, ``counter clockwise manner''
means that the line segment with one end at the center of the arc and
the other end traversing the arc from \vn{<v(i)>} to \vn{<v(i+1)>}
rotates in counter clockwise as shown in
\fig{f:chamber.wall}B. 

The red line segment with one end at the center of the arc and the
other end traversing the arc from, in this case, $V(2)$ to $V(3)$,
rotates in counter clockwise manner. In general, there are two
solutions for constructing such an arc. For positive radii, the
solution chosen is the one whose center is closest to the section
origin $(x_0, y_0)$. If the radii are negative, the center point will
be the point farthest from the origin (the dashed line between $V(2)$
and $V(3)$ in the figure).

A restriction on cross-sections is that the section origin $(x_0,
y_0)$ must be in the interior of any cross-section and that for any
cross-section a line drawn from the origin at any given angle $\theta$
will intersect the cross-section at exactly one point as shown in
\fig{f:chamber.wall}B. This is an important point in the construction
of the wall between cross-sections as explained below.

The last vertex specified, call it \vn{<v(n)>}, should not have the
same \vn{<x>}, \vn{<y>} values as the first vertex \vn{<v(1)>}. That
is, there will be a segment of the cross-section connecting
\vn{<v(n)>} to \vn{<v(1)>}. The geometry of this segment is determined
by the parameters of \vn{<v(1)>}.

If there is mirror symmetry about the $x$ or $y$ axis for a
cross-section, the ``mirrored'' vertices, on the ``negative'' side of
the mirror plane, do not have to be specified. Thus if all the vertex
points of a cross-section are in the first quadrant, that is, all
\vn{<x>} and \vn{<y>} are zero or positive, mirror symmetry about both the
$x$ and $y$ axes is assumed. If all the \vn{<y>} values are zero or
positive and some \vn{<x>} values are positive and some are negative,
mirror symmetry about the $x$ axis is assumed. Finally, if all the
\vn{<x>} values are zero or positive but some \vn{<y>} values are
positive and some are negative, symmetry about the $y$ axis is
assumed. For example, for the first in the above example, since
all the \vn{<y>} values are non-negative and there are positive and
negative \vn{<x>} values, symmetry about the $x$ axis is assumed.

The one exception to the above rule that (\vn{<x>}, \vn{<y>}) is the
vertex center is when a single vertex \vn{v(1)} is specified for a
cross-section with a non-zero \vn{<radius_x>}. In this case,
(\vn{<x>}, \vn{<y>}) are taken to be the center of the circle or
ellipse. In the example above, the second cross-section is a
tilted ellipse with center at $(0.003, -0.001)$. If a cross-section
has a single vertex and \vn{<radius_x>} is
not specified, the cross-section is a rectangle. For example
\begin{example}
    section = \{ s = 0.34, v(1) = \{0.03, 0.01\} \}
\end{example}

%-----------------------------------------------------------------
\subsection{Interpolation Between Sections}
\label{s:wall.interpolation}

\begin{figure}[tb]
  \centering
  \includegraphics[width=4in]{concave-capillary.pdf}
  \caption[Convex cross-sections do not guarantee a convex volume.]
{Example where convex cross-sections do not produce a convex volume.
Cross-sections (A) and (C) are ellipses with a 5 to 1 aspect ratio.
Half way in between, linear interpolation produces a convex cross-section
as shown in (B).} 
  \label{f:concave.capillary}
\end{figure}

For \vn{capillary} and vacuum chamber walls, the wall between
cross-sections, is defined by interpolation. Let $r_{c1}(\theta)$ be
the radius of the wall as a function of $\theta$ for a given
cross-section defined at $s = s_1$. Let $r_{c2}(\theta)$ be the radius
function at the next defined cross-section at $s = s_2$. The wall
$r_c(\theta, s)$ at any point $s$ between $s_1$ and $s_2$ is defined
by the equation
\Begineq
  r_c(\theta, s) = p_1(\stilde) \, r_{c1}(\theta) + p_2(\stilde) \, r_{c2}(\theta)
\Endeq
where 
\Begineq
  \stilde \equiv \frac{s - s_1}{s_2 - s_1}
\Endeq
and $p_1$ and $p_2$ are cubic polynomials parameterized by
\begin{align}
  p_1 &= 1 - \stilde + a_1 \, \stilde + a_2 \, \stilde^2 + a_3 \, \stilde^3 \CRNO
  p_2 &= \stilde + b_1 \, \stilde + b_2 \, \stilde^2 + b_3 \, \stilde^3 
\end{align}
If $a_i = b_i = 0$ for all $i = 1, 2, 3$, the interpolation is linear
and this is the default if either of the parameters \vn{dr_ds1} and
\vn{dr_ds2} are not given in the wall definition. These parameters are
the slopes of the wall with respect to $s$ at the end points
\begin{equation}
  \text{dr_ds1} \equiv \left. \frac{d\overline{r}}{ds} \right|_{s = s_1} \comma \qquad
  \text{dr_ds2} \equiv \left. \frac{d\overline{r}}{ds} \right|_{s = s_2} 
\end{equation}
where $\overline{r}$ is the average $r$ averaged over all
$\theta$. When {\em both} \vn{dr_ds1} and \vn{dr_ds2} are specified, the $a_i$
and $b_i$ are calculated so that the slopes of the wall match 
the values of \vn{dr_ds1} and \vn{dr_ds2} along with the constraints.
\begin{align}
  p_1(0) &= 1 \comma \qquad p_1(1) = 0 \CRNO
  p_2(0) &= 0 \comma \qquad p_2(1) = 1 \\
  M &\equiv a_1^2 + a_2^2 + a_3^2 + b_1^2 + b_2^2 + b_3^2 \text{ is a minimum}
  \nonumber
\end{align}
The last constraint ensures a ``smooth'' transition between the two cross-sections.

To refer to a cross-section parameters after an element has been
defined, the following syntax is used:
\begin{example}
  ele_name[wall.section(n).v(j).x]   ! x value of j^th vertex of n^th cross-section
\end{example}

%-----------------------------------------------------------------
\subsection{Capillary Wall}
\label{s:wall.capillary}
\index{capillary!wall}

For a \vn{capillary}, \vn{s} must be zero for the first cross-section and
the length of the capillary is given by the value of \vn{s} of the
last cross-section.

For a \vn{capillary}, in order for \bmad to quickly track photons,
\bmad assumes that the volume between the cross-sections is
convex. The volume will be convex if each cross-section $r_c(\theta,
s)$ at any given $s$ is convex. Note that it is {\em not} sufficient
for $r_c(\theta, s)$ to be convex at the specified cross-sections as
shown in \fig{f:concave.capillary}. Also note that it is perfectly
fine for the total capillary volume to not be convex.

%-----------------------------------------------------------------
\subsection{Vacuum Chamber Wall}
\label{s:wall.vacuum}

The vacuum chamber wall is independent of the element apertures
(\sref{s:limit}). Unless a program is specifically constructed, the
presence of a vacuum chamber wall will not affect particle tracking.

The vacuum chamber wall defined for an element may be shorter or
longer than the element.  The vacuum chamber wall for a particular
lattice branch is the sum of all the chamber walls of the individual
elements. That is, the chamber wall at any given point is determined
by interpolation of the nearest sections upstream and downstream to
the point.  Thus a given lattice element need not contain a \vn{wall}
component for the chamber wall to be well defined at the element. 

The exception to the above rule is when a \vn{section} has its
\vn{type} component set to either:
\begin{example}
  wall_start
  wall_end
\end{example}
If a section has a \vn{type} of \vn{wall_start}, the region between
that section and the previous section will be considered to have no
wall. If the \vn{wall_start} section is the first section of the
containing lattice branch, and if the lattice branch has an open
geometry, then the region of no wall will start at the end of the
branch. Similarly, if a section has a \vn{type} of \vn{wall_end}, the
region between that section and the next section (or the end of the
lattice branch if there is no next seciton and the branch has an open
geometry) will not have a wall.

The chamber walls of any two elements may not overlap. The exception
is when the \vn{superimpose} attribute for a wall of an element is set
to True. In this case, any other wall cross-sections from any other
elements that overlap the superimposed wall are discarded.
Superposition of a wall is useful, for example, in introducing mask
regions into the wall.

If a branch has a closed geometry (\sref{s:param}), wall sections that
extend beyound the ends of the branch are ``wrapped'' around.

If a particle is past the last wall cross-section or before the first
wall cross-section, The following rules are used: If the branch has a
\vn{closed geometry}, the wall will be interpolated between the last
and first cross-sections. If the branch has an \vn{open} geometry, the
wall is taken to have a constant cross-section in these regions. 

The chamber wall is defined with respect to the local coordinate
system (\sref{s:ref}). That is, in a bend a wall that has a constant
cross section is a section of a torus.

\index{patch!and chamber wall}
\vn{Patch} elements complicate the wall geometry since the coordinate
system at the end of the \vn{patch} may be arbitrarily located
relative to the beginning of the patch. To avoid confusion as to what
coordinate system a wall section belongs to, \vn{patch} elements are
not allowed to define a wall. The wall through a patch is determined
by the closest wall sections of neighboring elements. These wall
sections need to be placed at the edge of the \vn{patch}.

%-------------------

\begin{figure}[tb]
  \centering
  \includegraphics[width=6in]{crotch.pdf}
  \caption[vacuum chamber crotch geometry.]
{A) Crotch geometry: Two pipes labeled ``leg1'' and ``leg2'' merge
into a single pipe called the ``trunk'' pipe. Five wall sections are
used to define the crotch geometry (solid lines). Dashed lines
represent sections not involved in defining the crotch. For purposes
of illustration, the three trunk sections are displaced longitudinally
but in reality must have the same longitudinal coordinate.  B) Example
layout of the trunk1, trunk2 and trunk wall sections. $O_1$, $O_2$
and $O$ are the $x_0, y_0$ origins of the sections.}
  \label{f:crotch}
\end{figure}

%-------------------

\index{crotch chamber geometry}
Each section has a \vn{type} attribute. This attribute is not used for 
\vn{capillary} elements. For a vacuum chamber wall, the \vn{type} 
attribute is used to dscribe a ``crotch'' geometry where
two pipes merge into one pipe. The possible values for the \vn{type} 
attribute are:
\begin{example}
  normal     ! default
  leg1
  leg2
  trunk1
  trunk2
  trunk
\end{example}
The geometry of a crotch is shown in \fig{f:crotch}A. Two pipes,
called ``leg1'' and ``leg2'', merge into one pipe called the ``trunk''
pipe.  The trunk pipe can be either upstream or downstream of the leg
pipes.  To describe this situation, five sections are needed: One
section in each leg pipe which need to have their \vn{type} attribute
set to \vn{leg1} and \vn{leg2}, and three sections in the trunk with
one having a a \vn{type} attribute of \vn{trunk1}, another having a
\vn{type} attribute of \vn{trunk2} and the third haveing a \vn{type}
attribute of \vn{trunk}. There can be no sections between the leg
sections and the trunk sections.

All three trunk sections must be associated with the same element and
have the same \vn{s} value. In the list of sections of the element
containing the trunk elements, the \vn{trunk1} and \vn{trunk2}
sections must be listed first if the leg pipes are upstream of the
trunk pipe (the situation shown in the figure) and must be listed last
if the leg pipes are downstream. That is, the \vn{trunk1} and
\vn{trunk2} sections are ``between'' the leg sections and the
\vn{trunk} section. It does not matter if \vn{trunk1} is before or
after \vn{trunk2}.

The \vn{trunk1} and \vn{trunk2} sections must not overlap and the
\vn{trunk} section must be constructed so that its area is the union
of the areas of \vn{trunk1} and \vn{trunk2}. An example is illustrated
in \fig{f:crotch}B. Here the \vn{trunk1} and \vn{trunk2} sections are
squares with origins labeled $O_1$ and $O_2$ in the figure. By
necessity, these origins must be different since each must lie within
the boundaries of their respective areas. The \vn{trunk} section is a
rectagle encomposing the two squares and has an origin labeled $O$.

Between \vn{leg1} and \vn{trunk1} sections the wall is interpolated
using these two section. Similarly for the region between \vn{leg2}
and \vn{trunk2} sections. Away from these regions interpolation is
done as outlined in \sref{s:wall.interpolation}. However, these two
regions need a different interpolation scheme since, \vn{leg1} and
\vn{trunk1}, as well as \vn{leg2} and \vn{trunk2} sections do not have
to be parallel to each other.

%-----------------------------------------------------------------
\subsection{Diffraction Plate Wall}
\label{s:wall.diff.plate}

\begin{figure}[tb]
  \centering
  \includegraphics[width=5in]{diffraction-plate.pdf}
  \caption[Example diffraction_plate element]{
A) The diffraction plate surface is divided into ``clear'' (white) and
``opaque'' (black) areas. In this example there are two clear sections
labeled \#1 and \#2. B) All wall sections must be star shaped with
respect to the section's origin. In this example, The section is {\em
not} star shaped since a line drawn from the origin point $o$ to the
point $p$ on the boundary intersects the boundary twice in between. In
this case the section can be made star shaped by moving the origin to
$o'$.
  }
  \label{f:diff.plate}
\end{figure}

The \vn{wall} of a \vn{diffraction_plate} (\sref{s:diff.plate})
specifies the topology of the plate in terms of what areas of the
plate will transmit or reflect X-rays and what areas will not.  The
areas where there is transmission or reflection are called ``clear''
areas and everything else is called ``opaque''. 

A \vn{wall} is comprised a a ordered list of \vn{sections} as
discussed in \sref{s:wall.section}. Each section of a
\vn{diffraction_plate} element must have its \vn{type} attribute set
to one of:
\begin{example}
  clear
  mask
\end{example}
A section is called ``clear'' or ``mask'' depending upon the setting
of its \vn{type} attribute. Do not confuse ``clear section'' with 
``clear area''.

A clear area is defined by one or more consecutive wall sections. The
first section that defines a clear area must be a clear section.  All
the other sections associated with a clear area must be mask sections.
That is, a clear area starts with a clear section and any preceeding
mask sections up to the next clear section or the end of the section
list. As a consequence of the above rules, the fist section of the
wall must be a clear section and the number of clear areas is equal to
the number of clear sections.

The default behavior is that a photon will be transmitted if it is
within any clear area. A photon is considered to be within a given
clear area if its $(x,y)$ coordinates put in within the corresponding
clear section but not within any \vn{mask} section of the clear area.
\vn{Mask} sections only affect the clear area they are associated
with. See the example below.

Any clear section can be given a \vn{material} and
\vn{thickness}. Available materials are listed in
\sref{s:cryst.list}. A photon transversing a clear area with a defined
material will be attenuated and have a phase shift. Note that
\vn{material} and \vn{thickness} properties are not to be assigned to
\vn{mask} sections.

To enable \bmad to quickly calculate whether a photon has landed on a
clear or mask section, All sections, both clear and mask, must be
``star shaped'' with respect to the $(x_0, y_0)$ origin used by the
section. That is, a line drawn from the section origin to any point on
the section boundary must not pass through any boundary points of the
section in between. This is illustrated in \fig{f:diff.plate}B where
the section is not star shaped since a line drawn from the origin $o$
to the point $p$ on the boundary passes through two boundary points in
between. In this case the section can trivially be made star shaped by
moving the origin to point $o'$. If it is not possible to make a
section star shaped by moving the origin, the section must be divided
into multiple sections.

An example diffraction plate geometry is shown in \fig{f:diff.plate}A.
In the figure, there are two openings labeled \#1, and \#2. A
wall that constructs this geometry is:
\begin{example}
  zone1: diffraction_plate, wall = \{
    thickness = <real>
    opaque_material = <material_type>
    clear_material = <material_type>
    section = \{           ! Clear area \# 1
      type = clear, 
      v(1) = \{0.04, 0\}, v(2) = \{0.04, 0.022\},
      v(3) = \{0, 0.03\},
    section = \{
      type = mask,
      v(1) = \{0.032, 0.016\},
    section = \{          ! Clear area \# 2
      type = clear,
      v(1) = \{0, 0, 0.03, 0.013\},
    section = \{
      type = mask,
      v(1) = \{0, 0, 0.005\},
    section = \{
      type = mask,
      x0 = 0.02,
      v(1) = \{0, 0, 0.005\} \}
\end{example}
Clear area \#1 has a clear section and one mask section. These
sections rely on the four fold symmetry of the sections so that only
points in the first quadrant need be specified. Clear area \#2 has one
clear section in the shape of an ellipse with two mask circles. Notice
that the \vn{mask} section of clear area \#1 does not affect the clear
area \#2 even though it (completely) overlaps clear area \#2.

Sections may overlap and a mask section does not have to be wholly
within the corresponding clear section. If a photon is within multiple
clear areas then, for the purposes of calculation, it is considered to
be within the first possible clear area in the list.

%-----------------------------------------------------------------
\section{Length Attributes}
\label{s:l}

\index{length of elements}
\index{l|hyperbf}
\index{l_chord|hyperbf}
\index{rbend}
\index{sbend}
The length attributes are
\begin{example}
  l       = <Real>  ! 
  l_chord = <Real>  ! Chord length of a bend. Dependent attribute.
\end{example}
The length \vn{l} is the path length of the reference particle. The
one exception is for an \vn{rbend}, the length \vn{l} set in the
lattice file is the chord length (\sref{s:bend}). internally, \bmad
converts all \vn{rbend}s to \vn{sbend}s and stores the chord length
under the \vn{l_chord} attribute.
Example:
\begin{example}
  b: rbend, l = 0.6   ! For rbends, l will be converted to l_chord
\end{example}

\index{girder}
For a \vn{girder} element the length \vn{l} is a dependent attribute
and is set by \bmad to be the difference in longitudinal position $s$
of the downstream end of the last element supported relative to the
upstream end of the first element. 

\index{wiggler}
For \vn{wiggler}s, the length \vn{l} is not the same as the
path length for a particle with the reference energy starting on the
reference orbit. See~\sref{s:ref}.

\index{patch}
For \vn{patch} elements the \vn{l} length is, by definition, equal to
\vn{z_offset}. For \vn{patch} elements, \vn{l} is a dependent
attribute and will be automatically set to \vn{z_offset} by \bmad.

\index{capillary}
The length of a \vn{capillary} element is a dependent variable and is
given by the value of \vn{s} of the last wall cross-section
(\sref{s:wall.capillary}).

\index{crystal}
The length of a crystal is zero for Bragg diffraction and is a
dependent attribute dependent upon the crystal thickness for Laue
diffraction. See \sref{s:crystal} for more details.

%-----------------------------------------------------------------
\section{Is_on Attribute}
\label{s:is.on}
\index{is_on|hyperbf}

The \vn{is_on} attribute
\begin{example}
  is_on = <Logical>
\end{example}
is used to turn an element off. Turning
an element off essentially converts it into a drift.
Example
\begin{example}
  q1: quad, l = 0.6, k1 = 0.95
  q1[is_on] = False
\end{example}

\index{aperture}
\index{reference orbit}
\index{reference energy}
\vn{is_on} does not affect any apertures that are set. Additionally,
\vn{is_on} does not affect the reference orbit. Therefore, turning 
off an \vn{lcavity} will not affect the reference energy.

%-----------------------------------------------------------------
\section{Multipole Attributes: An, Bn, KnL, Tn}
\label{s:multip}

Multipole formulas for are given in \sref{s:fields}. 

\index{multipole!knl, tn|hyperbf} 
\index{multipole}
A \vn{multipole} (\sref{s:mult}) element specifies its multipole
components using an Amplitude (\vn{KnL}) and a tilt (\vn{Tn})
\begin{example}
  KnL = <Real>
  Tn  = <Real>  ! Default is $pi$/(2n + 2)
\end{example}
Here \vn{n} ranges from 0 (dipole component) through 21.  If \vn{Tn}
is given without a value, a default of $pi$/(2n + 2) will be used
producing a skew field. Example:
\begin{example}
  m: multipole, k1l = 0.328, t1  ! Skew quadrupole
\end{example}
Following \vn{MAD}, a non-zero dipole (\vn{K0L} component will affect
the reference orbit (just like a normal dipole will). This is not true
for any other element.

\index{ab_multipole}
\index{multipole!an, bn|hyperbf} 
An \vn{ab_multipole} (\sref{s:ab.m}) specifies multipoles using normal
(\vn{Bn}) and skew (\vn{An}) components:
\begin{example}
  An = <Real>
  Bn = <Real>
\end{example}
Here \vn{n} ranges from 0 (dipole component) through 21. Example:
\begin{example}
  q1: ab_multipole, b0 = 0.12, a20 = 1e7
\end{example}

\index{radius}
Elements like \vn{quadrupoles} and \vn{sextupoles} can have assigned
to them multipole fields. In this case, the fields are specified using
the same convention as the \vn{ab_multipole}.
For such non-multipole elements, the multipole strength is scaled by a
factor $F \, r_0^{n_\text{ref}} / r_0^n$ (cf.~\Eq{ababf}) where $F$ is
the strength of the element (for example $F$ is $K1 \cdot L$ for a
quadrupole), and $r_0$ is the ``measurement radius'' and is set by the
\vn{radius} attribute. The default value of $r_0$, if the \vn{radius}
is not given, is 1.0.  This behavior may be turned off by setting the
\vn{scale_multipoles} attribute.  Example:
\begin{example}
  q1: quadrupole, b0 = 0.12, a20 = 1e7, scale_multipoles = F
\end{example}

%-----------------------------------------------------------------
\section{EM Fields -- Tables and Maps}
\label{s:em.fields}

\index{field_calc}
Three dimensional electromagnetic fields can be specified in a number
of ways.  Setting a lattice element's \vn{field_calc} switch to
\vn{custom} (\sref{s:integ}) alows for a custom calculation. The
drawback here is that the appropriate custom code must be linked into
any program that needs to do tracking (\sref{s:custom.ele}).

The other two possibilities are setting \vn{field_calc} to either
\vn{grid} or \vn{map}. \vn{grid} defines the field using a three
dimensional grid of points with interpolation used to evaluate the
field between points. \vn{map} defines the field as a sum of a number of
modes (functions). As dissused below, both \vn{grid} and \vn{map} use the 
\vn{field} attribute of an element to specify the needed parameters.
Examples:
\begin{example}
  q: quadrupole, field_type = grid, field = \{grid = \{...\}\}, ...
  r: rfcavity, field_type = map, field = \{map = \{...\}\}, ...
\end{example}
\index{lcavity}\index{rfcavity}\index{em_field}\index{field}
Fields so specified can be used with, for example, \vn{runge_kutta}
tracking (\sref{s:tkm}). Both RF and DC fields can be specified.
However RF fields can only be associated with the following elements:
\begin{example}
  e_gun
  em_field
  lcavity
  rfcavity
\end{example}
Currently there is the restriction that DC fields must use \vn{grid}.

The syntax for specifying the electromagnetic fields is
\label{v:field}
\index{m}\index{field}\index{mode}\index{freq}\index{phi0_ref}
\index{f_damp}\index{field_scale}\index{master_scale}\index{phi0_azimuth}
\index{map}\index{grid}
\begin{example}
  field = \{
    mode_to_autoscale = <Integer>, ! Default = 1.
    mode = \{
      m             = <Integer>,   ! Mode number
      harmonic      = <Integer>,   ! Harmonic number 
      phi0_ref      = <Real>,      ! Phase of oscillations.
      f_damp        = <Real>,      ! Oscillation damping factor. Default = 0.
      field_scale   = <Real>,      ! Scale factor for the E & B fields.
      master_scale  = <Name>,      ! Master scaling parameter for E & B fields.
      phi0_azimuth  = <Real>,      ! Azimuthal orientation.
      map           = \{<EM_field_map>\},     ! EM field map data
      grid          = \{<EM_field_grid>\} \}, ! EM field grid data
    mode = \{...\}\}
\end{example}
The electromagnetic field is specified as a series of \vn{modes}. Each
\vn{mode} has a \vn{harmonic} number which, if non-zero, identifies it
as an RF field. The field associated with a mode can be specified
using a \vn{grid} of data points or by a \vn{map} which specify the
coefficients of an analytical form for the field.
The \vn{mode_to_autoscale} parameter is explained in Chapter~\sref{c:autoscale}

Example:
\begin{example}
  apex: e_gun, l = 0.23, field_calc = grid, rf_frequency = 187e6, 
    field = \{ mode = \{
      m = 0, harmonic = 1,
      master_scale = voltage,
      grid = call::apex_gun_grid.bmad \}\}
\end{example}
with the file \vn{apex_gun_grid.bmad} being:
\begin{example}
  \{
    type = rotationally_symmetric_rz,
    r0 = (0, 0),
    dr = (0.001, 0.001),
    pt(0,0) = ( (0, 0), (0, 0), (1, 0),  (0, 0), (0, 0), (0, 0)),
    pt(0,1) = ( (0, 0), (0, 0), (0.99, 0),  (0, 0), (0, 0), (0, 0)),
    ... \}
\end{example}

The field is scaled by two values specified by \vn{field_scale} and
\vn{master_scale}. That is
\begin{equation}
  [E, B] (actual) = [E, B] \mbox{(from map or grid)} * 
  \mbox{field_scale} * \mbox{master_scale_value}
\end{equation}
That is, the actual field is the value as determined from the \vn{map}
or \vn{grid} data (see below) scaled by the value of \vn{field_scale}
times the ``master_scale_value''. This master_scale_value is the value
of the element parameter given by \vn{master_scale}. For example, for
a quadrupole element, if \vn{master_scale} is set to "K1" then the
fields are scaled by the quadrupole strength parameter. The purpose of
this \vn{master_scale} is to provide a way to scale the 3D fields with
the element strength parameter (K1 for a quadrupole) which is separate
from auto scaling. The \vn{master_scale} also provides a way to scale
separate \vn{mode}s jointly.

The field of a given mode oscillates as given by Eq.~\ref{eseei}  
\Begineq
  e^{-i \, 2 \, \pi ( f \, t + \theta_0)}
\Endeq
The phase of the oscillation, $\theta_0$ comes from two
sources: the phase \vn{phi0_ref} set for the mode and an overall phase
\vn{phase_ref} given by
\begin{example}
 phase_ref = phi0 + phi0_multipass
\end{example}
\index{lcavity!reference phase}\index{rfcavity!reference phase}
Unfortunately, to be consistent with \mad, the definition of
\vn{phase_ref} for an \vn{lcavity} (\sref{s:lcav}) and \vn{e_gun} differ in sign to
that for an \vn{rfcavity} (\sref{s:rfcav}). This being the case,
$\theta_0$ is
\Begineq
  \theta_0 = 
  \begin{cases}
    \text{phi0_ref} + \dsfrac{f}{f_0} \, (\text{phase_ref} + \text{phi0_err}) & 
    \text{lcavity \& e_gun element} \\
    \text{phi0_ref} - \dsfrac{f}{f_0} \, \text{phase_ref} & 
    \text{rfcavity element}
  \end{cases}
\Endeq
where $f$ is the mode frequency and $f_0$ is the frequency of the
fundamental.

The phase \vn{phi0_ref} of the fundamental mode can be auto-scaled by
Bmad (\sref{c:autoscale}) so that a particle with $z = 0$ will go
through the cavity on crest for an \vn{e_gun} or  \vn{lcavity} and on the
zero-crossing for an \vn{rfcavity}. 

%-----------------------------------------------------------------
\subsection{Map}

The \vn{map} specification has the form
\begin{example}
  map = \{
    dz        = <Real>,    ! Distance between sampled field points.
    e_coef_re = (<Real>, <Real>, ....),  ! Real part of e.
    e_coef_im = (<Real>, <Real>, ....),  ! Imaginary part of e.
    b_coef_re = (<Real>, <Real>, ....),  ! Real part of b.
    b_coef_im = (<Real>, <Real>, ....),  ! Imaginary part of b.
  \}
\end{example}
For rf fields the basic equations used for the mode decomposition of
the rf fields are given in Section~\sref{s:rf.fields.phys}. 
\vn{e_re} and \vn{e_im} give the real an imaginary part of $e$ and
\vn{b_re} and \vn{b_im} give the real and imaginary part of $b$. All
of these vectors must be present and have the same length. The
exception is with an $m = 0$ mode either the $e$ or $b$ arrays can be
omitted and will default to zero. The number of terms $N$ for the $e$
or $b$ vectors must be a power of $2$ and all modes must have the same
number of terms. The $n$\Th element in the $e$ or $b$ arrays, with $n$
running from 0 to $N-1$, is associated with a wavelength $k_n$
\begin{equation}
  k_n = \begin{cases}
    \frac{2 \, \pi \, n}{N \, dz} & n < \frac{N}{2} \\
    \frac{2 \, \pi \, (n-N)}{N \, dz} & \text{otherwise}
  \end{cases}
\end{equation}
This convention follows the convention used by Numerical
Recipes\cite{b:nr}.  

 The longitudinal length
of the field is
\begin{equation}
  L_{\text{field}} = \frac{N - 1}{dz}
\end{equation}
this may be different from the length \vn{l} specified for the
element. If there is a difference, the field is assumed to be centered
on the element and drifts will be used at the entrance and exit ends
of the element to make up the difference.

%-----------------------------------------------------------------
\subsection {Grid}
\label{ss:grid}

A grid of field points can be specified using the general format:
\begin{example}
  field = \{
    grid = \{ 
      type = <String>,
      r0   = (<Real>, <Real>, <Real>),  ! Grid origin 
      dr   = (<Real>, <Real>, <Real>),  ! Grid spacing
      ele_anchor_pt = <Position>        ! BEGINNING, CENTER, or END
      pt(<Integer>, <Integer>, <Integer>) = ( \ldots ),  ! Grid field points
      \ldots \} \}
\end{example}
The \vn{type} switch sets the type of the grid and must come before
all the other components. The possible settings of \vn{type} are:
\begin{example} 
  rotationally_symmetric_rz
  xyz
\end{example}

The \vn{rotationally_symmetric_rz} setting for \vn{type} is for fields
that are rotationally symmetric around the $z$ axis. The format for
this type of grid is
\begin{example}
  field = \{grid = \{ 
    type = rotationally_symmetric_rz,
    r0   = (<r0>, <z0>),        ! Grid origin 
    dr   = (<dr>, <dz>),        ! Grid spacing
    pt(ir, iz) = (<E_r>, <E_phi>, <E_z>, <B_r>, <B_phi>, <B_z>)
    \ldots \} \}
\end{example}

The \vn{xyz} setting for \vn{type} can be used for all fields. The
format for this type of grid is
\begin{example}
  field = \{grid = \{ 
    type = xyz,
    r0   = (<x0>,  <y0>, <z0>),   ! Grid origin 
    dr   = (<dx>, <dy>, <dz>),    ! Grid spacing
    pt(ix, iy, iz) = (<E_x>, <E_y>, <E_z>, <B_x>, <B_y>, <B_z>)
    \ldots \} \}
\end{example}

field components like \vn{<E_z>} can be complex for RF
fields or simply a real number for DC fields. When a field component
is complex, the syntax for specifying it uses the form:
\begin{example}
  (Re, Im)
\end{example}
where \vn{Re} and \vn{Im} are the real and imaginary parts of the
component. Example:
\begin{example}
  pt(0, 0, 7) = ((0.34, -4.3), (2.37, 9.34), ...)  ! Complex field
  pt(0, 0, 7) = (0.12, -0.33, ...)                 ! Real field
\end{example}

[For clarity sake, the following discusses the \vn{xyz}
case. Extension to other cases is straight forward.]  There is no
restriction on the bounds of the indexes \vn{(ix, iy, iz)} of the
\vn{pt(ix, iy, iz)} array. Treating \vn{r0} and \vn{dr} as vectors, a
point $(ix, iy, iz)$ corresponds in space to the point
\begin{example}
  (x, y, z) = r0 + dr * (ix, iy, iz) + r_anchor
\end{example}
where \vn{z} is measured from the beginning of the element and
\vn{r_anchor} is determined by the setting of \vn{ele_anchor_pt}:
\begin{example}
  ele_anchor_pt       r_anchor
  -------------       ---------
  beginning           (0, 0, 0)      ! Default
  center              (0, 0, L/2)
  end                 (0, 0, L)
\end{example}
with \vn{L} being the length of the element.

%-----------------------------------------------------------------
\section{RF Couplers}
\label{s:rf.coupler}

\index{lcavity}\index{rfcavity}
\index{coupler_at}\index{coupler_strength}
\index{coupler_angle}\index{coupler_phase}
For \vn{lcavity} and \vn{rfcavity} elements, the attributes that
characterize the dipole transverse kick due to a coupler port are:
\begin{example}
  coupler_at       = <Switch> ! What end the coupler is at
  coupler_strength = <Real>   ! Normalized strength
  coupler_angle    = <Real>   ! Polarization angle (rad/2\(\pi\))
  coupler_phase    = <Real>   ! Phase angle with respect to the RF (rad/2\(\pi\))
\end{example}
The possible \vn{coupler_at} settings are:
\begin{example}
  entrance_end
  exit_end  ! default
  both_ends
\end{example}
The kick due to the coupler is
\begin{example}
  dP_x = amp * cos(phase) * cos(angle) 
  dP_y = amp * cos(phase) * sin(angle)
  dE   = amp * (cos(angle) * x + sin(angle) * y) * sin(phase) * twopi * rf_frequency / c_light 
\end{example}
where \vn{dP_x} and \vn{dP_y} are the transverse momentum kicks, \vn{dE} is an energy kick, and
\begin{example}
  amp   = gradient * coupler_strength 
  phase = twopi * (phase_particle + phase_ref + coupler_phase)         ! For lcavity \sref{s:lcav}
        = pi/2 + twopi * (phase_particle - phase_ref + coupler_phase)  ! For rfcavity \sref{s:lcav}
  angle = twopi * coupler_angle
\end{example}
The energy kick is needed to keep things symplectic. 

Example:
\begin{example}
  rf1: lcav, l = 4.5, gradient = 1.2e6, coupler_at = both_ends,
                                                  coupler_strength = 0.037
\end{example}

%-----------------------------------------------------------------
\section{Wakefields}
\label{s:wakes}

Wake fields can be specified for many elements.
The attributes that characterize the wakes are:
\index{sr_wake_file}\index{lr_wake_file}\index{lr_freq_spread}
\begin{example}
  sr_wake_file     = <String> ! Short range wake field definition file.
  lr_wake_file     = <String> ! Long range wake field definition file.
  lr_freq_spread   = <Real>   ! Frequency spread of the LR wake fields.
\end{example}

The formulas used to compute the wake field are given in
\sref{s:wake.fields}. The wake field is only used when tracking
bunches and not when tracking single particles.

%-----------------------------------------------------------------
\subsection{Short-Range Wakes}
\label{ss:short.range.wakes}

\index{wakes!short-range}
The input file name for the short--range wake fields is specified
using the \vn{sr_wake_file} attribute. The file gives both monopole
longitudinal and dipole transverse wakes. An example input file is:
\begin{example}
  ! Pseudo Wake modes:
  !                      Amp       Damp          K      Phase  Polar-    Transverse_
  ! Longitudinal:      [V/C/m]     [1/m]      [1/m]     [rad]  ization   Dependence
  ! Transverse:      [V/C/m^2]     [1/m]      [1/m]     [rad]  

  &short_range_modes
    longitudinal(1) = 3.23e14     1.23e3     3.62e3     0.123
    longitudinal(2) = 6.95e13     5.02e2     1.90e3    -1.503
    .. etc ..
    transverse(1) =   4.23e14     2.23e3     5.62e3     0.789    X  linear_trailing
    transverse(2) =   8.40e13     5.94e2     1.92e3     1.455
     .. etc ..
    z_max = -1.3e-3
  /
\end{example}
Wakes are specified via a set of ``pseudo'' modes
(\sref{s:wake.fields}). The magnitude of \vn{z_max} should be set to
the maximum $z$ value at which the pseudo mode fit is valid. \bmad
will check the distance between particles does not exceed \vn{z_max}.
If it does, \bmad will report an error.

\index{none}\index{x_axis}\index{y_axis}
The \vn{polarizaiton} parmeter is used to specify the wake
polarization. Possible settings for this parameter are:
\begin{example}
  none    ! Default
  x_axis  
  y_axis 
\end{example}
The \vn{polarization} name may be abbreviated.  For example, if the
\vn{polarization} is set to \vn{x_axis}, there is no vertical kick
from the psudo mode.

\index{none}\index{linear_leading}\index{linear_trailing}
The \vn{transverse_dependence} parameter sets whether the wake kick
is linear in the offset of the leading or trailing particle or is
independent of the transverse offset.
Possible settings of this parameter are:
\begin{example}
  none              ! Default for longitudinal modes
  linear_leading    ! Default for transverse modes
  linear_trailing
\end{example}
The \vn{transverse_dependence} parameter may be abbreviated. Note: Due
to the way the wake file is parsed, if \vn{transverse_dependence} is
specified for a particular mode, \vn{polarization} must also be
specified.

For \vn{longitudinal} modes: If the \vn{transverse_dependence} is
\vn{none} (the default), then the \vn{polarization} must also be
\vn{none} (other combinations do not make sense). If the
\vn{transverse_dependence} is \emph{not} \vn{none} for a
\vn{longitudinal} mode, then the \vn{polarization} must be set
to \vn{x_axis} or \vn{y_axis}. 

Note: In a beam chamber with circular symmetry, the linear terms in
the \vn{longitudinal} wake are zero and the transverse wake has
no terms independent of the transverse offsets nor terms that
depend upon the trailing particle offset.

%-----------------------------------------------------------------
\subsection{Long-Range Wakes}

The input file name for the long--range wake fields is specified using
the \vn{lr_wake_file} attribute. The file gives the wake modes by
specifying the frequency (in Hz), R/Q (in $\Omega$/meter$^{2m}$), Q,
and m (order number), and optionally the polarization angle (in
radians/2pi) for each cavity mode. The input uses Fortran90 namelist
syntax: The data begins with the string \vn{\&long_range_modes} and
ends with a slash \vn{/}. Everything outside this is ignored. Each
mode is labeled \vn{lr(i)} where \vn{i} is the mode index. An example
input file is:
\begin{example}
              Freq      R/Q      Q    m   Polar   b_sin  b_cos a_sin  a_cos  t_ref 
                      [Ohm/               Angle 
              [Hz]     m^(2m)]           [Rad/2pi]
  &long_range_modes
    lr(1) = 1.650e9    0.76    7.0e4  1    unpol
    lr(2) = 1.699e9   11.21    5.0e4  1    0.15
    lr(3) =    0       0.57    1.1e6  0    unpol
  /
\end{example}
A frequency of zero is used to designate wakes that are part of the
fundamental accelerating mode. \bmad needs to know if a wake is part
of the fundamental mode due to timing issues as discussed in \sref{s:rf.time}.

If the polarization angle is set to ``\vn{unpolarized}'' the mode is
taken to be unpolarized. [Note: Technically the unpolarized mode is
actually two polarized normal modes. The axes of these two normal
modes can be chosen arbitrary as long as they are at right angles to
each other.]

\vn{lr_freq_spread} is used to randomly spread out the long range mode
frequencies among different cavities. The spread is Gaussian in shape
with an RMS of \vn{lr_freq_spread} * $F$ where $F$ is the frequency of a
mode.  After the long--range modes have been defined they can be
referenced or redefined using the notation
\begin{example}
  lr(n)%freq      ! Frequency
  lr(n)%r_over_q  ! R/Q
  lr(n)%q         ! Q
  lr(n)%angle     ! Polarization Angle
\end{example}
Example:
\begin{example}
  lcav[lr(2)%freq] = 1.1 * lcav[lr(2)%freq] ! Raise frequency by 10\%
\end{example}

Example:
\begin{example}
  rf1: lcav, l = 4.5, gradient = 1.2e6, sr_wake_file = "sr1.dat"
\end{example}

%-----------------------------------------------------------------
\section{Fringe Fields}
\label{s:fringe}
\index{fringe fields}

\index{fringe_at}
Lattice elements can have fringe fields at the element edges. Whether
fringe fields are ignored or not is determined by the setting
of the \vn{fringe_at} element parameter. The possible settings are
\begin{example}
  no_end         
  both_ends             ! Default
  entrance_end
  exit_end
\end{example}
This is particularly useful in vetoing the
fringe effect in the interior of split elements.

\index{fringe_type}
For elements that have a multipole type fringe field (dipole,
quadrupole, etc., as opposed to solenoid or RF fringes), the
\vn{fringe_type} switch is used to select how a fringe field is
simulated.  For everything except for \vn{rbend} and \vn{sbend}
elements, \vn{fringe_type} may be set to one of:
\begin{example}
  none              ! Default 
  soft_edge_only
  hard_edge_only
  full
\end{example}
The \vn{none} setting ignores any fringe fields.
The fringe field kick is divided into two pieces. 
The first piece is called the \vn{hard edge} fringe kick and is the kick in the limit
that the longitudinal extent of the fringe is zero. The second piece is the 
\vn{soft edge} fringe kick which is the fringe kick with the fringe having a finite
longitudinal extent minus the hard edge fringe kick. That is
\begin{example}
  fringe kick = hard fringe kick + soft fringe kick
\end{example}
The advantage of separating the fringe kick in this way is that the hard fringe can
be used without having to know anything about the longitudinal extent of the fringe.
In many cases, this is a good enough approximation. Note that using the soft fringe
without the hard fringe is not physical but can be useful in understanding how
the soft edge component affects tracking.
See~\sref{s:multi.fringe.std} for details.

For \vn{rbend} and \vn{sbend} elements, the possible \vn{fringe_type}
settings are:
\begin{example}
  none
  soft_edge_only
  hard_edge_only
  full
  linear_edge
  basic_bend        ! Default 
  sad_soft_edge_only
  sad_full
\end{example}
The \vn{basic_bend} setting, which is the default, is essentially the
basic vertical focusing effect that is present when there is a finite
\vn{e1} or \vn{e2} face angle. With \vn{bmad_standard} tracking,
\vn{basic_bend} also includes second order terms.  The
\vn{linear_edge} setting ignores these second order terms.  In some
cases, for instance in a chicane, \vn{basic_bend} is not good
enough. With \vn{fringe_type} set to \vn{full}, higher order effects
are taken into account.

PTC does not have a \vn{linear_edge} fringe model.
With PTC tracking, \vn{basic_bend} tracking is used if \vn{linear_edge} is chosen.

Additionally, for use with PTC, the \vn{ptc_fringe_geometry} switch can be used
to define the symmetry of the fringe fields. Possible settings are:
\begin{example}
  x_invariant
  multipole_symmetry
\end{example}
\index{ptc_max_fringe_order}
Additionally, when using PTC tracking (\sref{s:ptc.intro}), the
\vn{parameter[ptc_max_fringe_order]} (\sref{s:param}) determines the maximum
order of the calculated fringe fields.

The difference between \vn{full_bend} and \vn{full_straight} is that
with \vn{full_straight} the fringe field is assumed to have the
perfect symmetry of the multipole. At the bend edge, Maxwell's
equations leads to next order terms with the same symmetry of the
multipole. With \vn{full_bend}, the fringe field is calculated
assuming that there is translational invariance along the horizontal
$x$ axis. This differes from \vn{full_straight} by adding an infinite
number of multipoles consistent with the dipole symmetry. See Etienne
Forest's book\cite{b:forest} for more details.

Example:
\begin{example}
  b1: rbend, angle = pi/4, g = 0.3, fringe_type = full
\end{example}

In a bend element, the \vn{fringe_type} setting only pertains to the
dipole fringe.  For higher order multipole fields in a bend, the
\vn{higher_order_fringe_type} selects the fringe type. Possible
settings are the same as for the non-bend \vn{fringe_type} elements
\begin{example}
  none              ! Default 
  soft_edge_only
  hard_edge_only
  full
\end{example}

\index{sad}\index{sbend}\index{rbend}
The \vn{soft_edge_only}, \vn{hard_edge_only} and \vn{sad_full} settings
of \vn{fringe_type} emulate the fringe field tracking used in the SAD
program\cite{b:sad}.  The \vn{soft_edge_only} setting only uses the linear
part of the fringe, \vn{hard_edge_only} ignores the linear part of
the fringe, and \vn{sad_full} uses the full fringe.  For an \vn{sbend}
or \vn{rbend} element, these SAD fringe fields are in addition to the
fringe fields that occurs with a finite \vn{e1} or \vn{e2} face
angle. 

\index{permfringe}\index{bendfringe}
For programmers who deal with PTC directly: The translation between
\vn{ptc_fringe_geometry} on the \bmad side and \vn{bendfringe} on the
PTC side is:

\begin{center}
\begin{tabular}{lll} \hline 
{\em ptc_fringe_geometry} & {\em bendfringe} \\ \hline
  x_invariant             & True  \\
  multipole_symmetry      & False \\
\end{tabular}
\end{center}

%-----------------------------------------------------------------
\section{Instrumental Measurement Attributes}
\label{s:meas.attrib}

\index{instrument}\index{monitor}\index{marker}
\index{x_gain_err}\index{y_gain_err}\index{crunch}\index{noise}
\index{x_gain_calib}\index{y_gain_calib}\index{crunch_calib}
\index{x_offset}\index{y_offset}\index{tilt}
\index{x_offset_calib}\index{y_offset_calib}\index{tilt_calib}
\index{de_eta_meas}\index{n_sample}\index{osc_amplitude}

\vn{instrument}, \vn{monitor}, and \vn{marker} elements have special
attributes to describe orbit, betatron phase, dispersion and coupling
measurements. These attributes are:
\hfill\break
\hspace*{0.1in}
\begin{tabular}{llll}
  {\em Attribute}     &            &! {\em Symbol} (\sref{s:meas.calc}) & \\
  \vn{tilt}           &= <Real>    &! $\theta_t$            & See \sref{s:offset} \\ 
  \vn{x_offset}       &= <Real>    &! $x_{\text{err}}$       & See \sref{s:offset} \\ 
  \vn{y_offset}       &= <Real>    &! $y_{\text{err}}$       & See \sref{s:offset} \\ 
  \vn{x_gain_err}     &= <Real>    &! $dg_{x,\text{err}}$    & Horizontal gain error \\ 
  \vn{y_gain_err}     &= <Real>    &! $dg_{y,\text{err}}$    & Vertical gain error \\ 
  \vn{crunch}         &= <Real>    &! $\psi_{\text{err}}$    & Crunch angle \\ 
  \vn{tilt_calib}     &= <Real>    &! $\theta_{\text{err}}$  & tilt angle calibration \\ 
  \vn{x_offset_calib} &= <Real>    &! $x_{\text{cal}}$       & Horizontal offset calibration \\ 
  \vn{y_offset_calib} &= <Real>    &! $y_{\text{cal}}$       & Vertical offset calibration \\ 
  \vn{x_gain_calib}   &= <Real>    &! $dg_{x,\text{cal}}$    & Horizontal gain calibration \\ 
  \vn{y_gain_calib}   &= <Real>    &! $dg_{y,\text{cal}}$    & Vertical gain calibration \\ 
  \vn{crunch_calib}   &= <Real>    &! $\psi_{\text{cal}}$    & Crunch angle calibration \\ 
  \vn{noise}          &= <Real>    &! $n_f$                 & Noise factor \\ 
  \vn{de_eta_meas}    &= <Real>    &! $dE/E$                & Percent change in energy \\ 
  \vn{n_sample}       &= <Real>    &! $N_s$                 & Number of sampling points \\ 
  \vn{osc_amplitude}  &= <Real>    &! $A_{\text{osc}}$       & Oscillation amplitude \\ 
\end{tabular}
\hfill\break
A program can use these quantities to calculate ``measured'' values from the
``laboratory'' values. Here, ``laboratory'' means as calculated from some model lattice.
See \sref{s:meas.calc} for the conversion formulas.
