\chapter{Introduction to Bmad programming}
\label{c:program.info}

To get the general feel for how \bmad works before
getting into the nitty--gritty details in subsequent chapters, this
chapter analyzes an example test program.

%-----------------------------------------------------------------------------
\section{A First Program}
\label{s:first.program}
\index{programming!example program}

Consider the example program shown in Figure~\ref{f:program}.
This program is provided with the \bmad distribution in a file called
\vn{simple_program.f90}. \vn{simple_program.f90} is in the \vn{bmad}
library area in a directory called \vn{bmad/simple_program}.

\begin{figure}[htp]
\index{routine!bmad_parser}
\index{routine!twiss_at_start}
\index{routine!twiss_propagate_all}
\index{routine!lat_ele_locator}
\index{routine!type_ele}
\index{ele_struct}
\index{lat_struct}
\index{ele_pointer_struct}
\index{lattice_type}
\begin{listing}{1}
program test

  use bmad                 ! Define the structures we need to know about.
  implicit none
  type (lat_struct), target :: lat   ! This structure holds the lattice info
  type (ele_struct), pointer :: ele
  type (ele_pointer_struct), allocatable :: eles(:)
  integer i, ix, n_loc
  logical err

  ! Read in a lattice and calculate the twiss parameters.

  call bmad_parser ("simple_program/lat.bmad", lat) ! Read in a lattice.
  if (lat%param%lattice_type == circular_lattice$) &
           call twiss_at_start (lat)  ! Calculate starting Twiss params.
  call twiss_propagate_all (lat)      ! Propagate Twiss parameters

  ! Print info on the first 11 elements

  print *, ' Ix  Name              Ele_type                   S      Beta_a'
  do i = 0, 10
    ele => lat%ele(i)
    print '(i4,2x,a16,2x,a,2f12.4)', i, ele%name, key_name(ele%key), ele%s, ele%a%beta
  enddo

  ! Find the CLEO_SOL element and print information on it.

  call lat_ele_locator ('CLEO_SOL', lat, eles, n_loc, err)
  print *
  print *, '!---------------------------------------------------------'
  print *, '! Information on element: CLEO_SOL'
  print *
  call type_ele (eles(1)%ele, .false., 0, .false., 0, .true., lat)

  deallocate (eles)

end program
\end{listing}
\caption{Example Bmad program}
\label{f:program}
\end{figure}

%-----------------------------------------------------------------------------
\section{Explanation of the Simple_Program}

\index{lat_struct!example use of}
A line by line explanation of the example program follows. The \vn{use
bmad} statement at line 3 defines the \bmad structures and defines the
interfaces (argument lists) for the \bmad subroutines. In particular,
the \vn{lat_struct} (\sref{s:lat.struct}) structure (line 5) holds all
of the lattice information: The list of elements, their attributes, etc.
\hyperref[r:bmad.parser]{bmad_parser} (line 13) is the routine which parses a lattice file
and transfers the information to a \vn{lat_struct} variable. To get a
listing of the \vn{lat_struct} components or to find out more about
\vn{bmad_parser} use the \vn{getf} command as discussed in \sref{s:getf}.

\index{routine!bmad_parser}
\index{routine!twiss_at_start}
\index{routine!twiss_propagate_all}
After \hyperref[r:bmad.parser]{bmad_parser} is called, the program checks if the lattice 
is circular (\sref{s:param}) and, if so, uses the
routine \hyperref[r:twiss.at.start]{twiss_at_start} (line 15) to multiply the transfer
matrices of the individual elements together to form the 1--turn
matrix from the start of the lat back to the start. From this matrix
\vn{twiss_at_start} calculates the Twiss parameters at the start of
the lattice and puts the information into \vn{lat%ele(0)} (\sref{s:twiss}). 
The next call, to \hyperref[r:twiss.propagate.all]{twiss_propagate_all}, takes the starting
Twiss parameters and, using the transfer matrices of the individual
elements, calculates the Twiss parameters at all the elements. Notice that
if the lattice is not circular, The starting Twiss parameters will need
to have been defined in the lattice file.

\index{ele_struct!\%x}
\index{ele_struct!\%key}
\index{ele_struct!\%s}
\index{lat_struct!\%ele(:)}
The program is now ready to print out some information on the first 11
elements in the lattice which it does on lines 20 through 24 of the
program. The do-loop is over the array \vn{lat%ele(:)}.  Each element of
the array holds the information about an individual lattice element as
explained in Chapter~\ref{c:lat.struct}. The \vn{lat%ele(0)} element is
basically a marker element to denote the beginning of the array
(\sref{c:sequence}). Using the pointer \vn{ele} to point to the
individual elements (line 22) makes for a cleaner syntax and reduces
typing. The table that is produced is shown in
lines 1 through 12 of Figure~\ref{f:output}.
The first column is the element index $i$. The second column,
\vn{ele%name}, is the name of the element. The third column,
key_name(ele%key), is the name of the element class. \vn{ele%key} is an
integer denoting what type of element (quadrupole, wiggler, etc.) it is.
\vn{key_name} is an array that translates the integer key of an element
to a printable string. The fourth column, \vn{ele%s}, is the longitudinal 
position at the
exit end of the element. Finally, the last column, \vn{ele%x%beta},
is the $a$--mode (nearly
horizontal mode) beta function.

The final section of the program, lines 28 through 33, uses the routine
\hyperref[r:lat.ele.locator]{lat_ele_locator} 
(\sref{s:lat.ele.change}) to find the element 
in the lattice with the name \vn{CLEO_SOL}.
\hyperref[r:type.ele]{type_ele} is used to type out the element's attributes and other
information as shown on lines 14 through 41 of the output (more on this later).

This brings us to the lattice file used for the input to the program.
The call to \vn{bmad_parser} shows that this file is called 
\vn{simple_program/lat.bmad}.
In this file there is a call to another file
  \begin{example}
  call, file = "layout.bmad"
  \end{example}
\index{line}
It is in this second file
that the layout of the lattice is defined. In particular, the \vn{line} used
to define the element order looks like
\begin{example}
  cesr: line = (IP_L0, d001, DET_00W, d002, Q00W, d003, ...)
  use, cesr
\end{example}
If you compare this to the listing of the elements in
Figure~\ref{f:output} you will find differences. For example, element
\#2 in the program listing is named \vn{CLEO_SOL\B3}. From the
definition of the \vn{cesr} line this should be \vn{d001} which, if
you look up its definition in \vn{layout.bmad} is a drift.  The
difference between lattice file and output is due to the presence
the \vn{CLEO_SOL} element which appears in \vn{lat.bmad}:
\begin{example}
  ks_solenoid    := -1.0e-9 * clight * solenoid_tesla / beam[energy]
  cleo_sol: solenoid, l = 3.51, ks = ks_solenoid, superimpose 
\end{example}
\index{superimpose!example}
The solenoid is 3.51 meters long
and it is superimposed upon the lattice with its center at $s = 0$ (this
is the default if the position is not specified). 
When \vn{bmad_parser} constructs the lattice list of elements
the superposition of \vn{IP_L0}, which is a zero--length marker, with the
solenoid does not modify \vn{IP_L0}. The superposition of the
\vn{d001} drift with the solenoid gives a solenoid with the same
length as the drift. Since this is a ``new'' element, \vn{bmad_parser}
makes up a name that reflects that it is basically a section of the
solenoid it came from.  Next, since the \vn{CLEO_SOL} element happens to
only cover
part of the \vn{Q00W} quadrupole, \vn{bmad_parser} breaks the
quadrupole into two pieces. The piece that is inside the solenoid is a
\vn{sol_quad} and the piece outside the solenoid is a regular
quadrupole. See \sref{s:super} for more details. Since the
center of the \vn{CLEO_SOL} is at $s = 0$, half of it extends to
negative $s$. In this situation, \vn{bmad_parser} will wrap this half
back and superimpose it on the elements at the end of the lattice list
near $s = s_{lat}$ where $s_{lat}$ is the length of the lattice.  As
explained in Chapter~\ref{c:lat.struct}, the lattice list that is used
for tracking extends from \vn{lat%ele(0)} through \vn{lat%ele(n)}
where \vn{n = lat%n_ele_track}. The \vn{CLEO_SOL} element is put in the
section of \vn{lat%ele(n)} with \vn{n > lat%n_ele_track} since it is
not an element to be tracked through. The \vn{Q00W} quadrupole also
gets put in this part of the list.  The bookkeeping information that
the \vn{cleo_sol\B3} element is derived from the \vn{cleo_sol} is put
in the \vn{cleo_sol} element as shown in lines 33 through 41 of the
output.  It is now possible in the program to vary, say, the strength
of the \vn{ks} attribute of the \vn{CLEO_SOL} and have the \vn{ks}
attributes of the dependent (``\vn{super_slave}'') elements updated
with one subroutine call. For example, the following code increases the
solenoid strength by 1\%
\index{routine!lattice_bookkeeper}
\index{routine!lat_ele_locator}
\begin{example}
  call lat_ele_locator ('CLEO_SOL', lat, eles, n_loc, err)
  eles(1)%ele(ix)%value(ks$) = eles(1)%ele%value(ks$) * 1.01 
  call lattice_bookkeeper (lat)
\end{example}
\bmad takes care of the bookkeeping. In fact \vn{control_bookkeeper} is
automatically called when transfer matrices are remade so the direct call
to \vn{control_bookkeeper} may not be necessary.

\index{programming!gmake}
\index{programming!production executable}
\index{programming!debug executable}
Making \vn{bmad} the working directory, the \vn{gmake -f M.simple_program}
command will compiling and link the program.  The
executables, \vn{simple_program} and \vn{simple_program_g}, are to be
found in \vn{../bin/}. Running the program with the command
\vn{../bin/simple_program} gives the output as shown in
Figure~\ref{f:output}.

\begin{figure}[ht]
\small
\begin{listing}{1}
  Ix  Name              Ele_type                   S      Beta_a
   0  BEGINNING         INIT_ELEMENT          0.0000      0.9381
   1  IP_L0             MARKER                0.0000      0.9381
   2  CLEO_SOL#3        SOLENOID              0.6223      1.3500
   3  DET_00W           MARKER                0.6223      1.3500
   4  CLEO_SOL#4        SOLENOID              0.6380      1.3710
   5  Q00W\CLEO_SOL     SOL_QUAD              1.7550      7.8619
   6  Q00W#1            QUADRUPOLE            2.1628     16.2350
   7  D003              DRIFT                 2.4934     27.4986
   8  DET_01W           MARKER                2.4934     27.4986
   9  D004              DRIFT                 2.9240     46.6018
  10  Q01W              QUADRUPOLE            3.8740     68.1771

 !---------------------------------------------------------
 ! Information on element: CLEO_SOL 

  Element #         871
  Element Name: CLEO_SOL
  Key: SOLENOID
  S:              1.7550
  Ref_time:   0.0000E+00
 
  Attribute values [Only non-zero values shown]:
      1   L                      =  3.5100000E+00
      7   KS                     = -8.5023386E-02
     32   P0C                    =  5.2890000E+09
     33   E_TOT                  =  5.2890000E+09
     34   BS_FIELD               = -1.5000000E+00
     50   DS_STEP                =  2.0000000E-01
 
          TRACKING_METHOD        =  Bmad_Standard
          MAT6_CALC_METHOD       =  Bmad_Standard
          FIELD_CALC             =  Bmad_Standard
          APERTURE_AT            =  Exit_End
          OFFSET_MOVES_APERTURE  =  F
          INTEGRATOR_ORDER:      =     2
          NUM_STEPS              =    18
          SYMPLECTIFY            =  F
          FIELD_MASTER           =  F
          CSR_CALC_ON            =  T
 
 Lord_status:  SUPER_LORD
 Slave_status: FREE
 Slaves: Number:   6
      Name                           Lat_index  Attribute           Coefficient
      Q00E\CLEO_SOL                        865  --------              3.182E-01
      CLEO_SOL#1                           866  --------              4.460E-03
      CLEO_SOL#2                           868  --------              1.773E-01
      CLEO_SOL#3                             2  --------              1.773E-01
      CLEO_SOL#4                             4  --------              4.460E-03
      Q00W\CLEO_SOL                          5  --------              3.182E-01
\end{listing}
\caption{Output from the example program}
\label{f:output}
\end{figure}

