\chapter{The Ele_struct}
\label{c:ele.struct}
\index{ele_struct|hyperbf}

This chapter describes the \vn{ele_struct} which is the structure that
holds all the information about an individual lattice element:
quadrupoles, separators, wigglers, etc. The \vn{ele_struct} structure is
shown in Figures~\ref{f:ele.struct1}  and \ref{f:ele.struct2}. This
structure is somewhat complicated, however, in practice, a lot of the
complexity is generally hidden  by the \bmad bookkeeping routines.

As a general rule, for variables like the Twiss parameters that are not
constant along the length of an element, the value stored in the
corresponding component in the \vn{ele_struct} is the value at the exit
end of the element.

For printing information about an element, the
\Hyperref{r:type.ele}{type_ele} or \Hyperref{r:type2.ele}{type2_ele} routines
can be used (\sref{s:first.program}). The difference between the two is
that \vn{type_ele} will print to the terminal window while \vn{type2_ele}
will return an array of strings containing the element information.

\begin{figure}[tb]
\centering
\footnotesize
\begin{verbatim}
type ele_struct
  character(40) name                   ! name of element \sref{c:ele.string}.
  character(40) type                   ! type name \sref{c:ele.string}.
  character(40) alias                  ! Another name \sref{c:ele.string}.
  character(40) component_name         ! Used by overlays, multipass patch, etc.
  character(200), pointer :: descrip => null() ! Description string.
  type (twiss_struct)  a, b, z         ! Twiss parameters at end of element \sref{c:twiss}.
  type (xy_disp_struct) x, y           ! Projected dispersions \sref{c:twiss}.
  type (floor_position_struct) floor   ! Global floor position at end of ele.
  type (mode3_struct), pointer :: mode3 => null()
  type (coord_struct) map_ref_orb_in   ! Ref orbit at entrance of element.
  type (coord_struct) map_ref_orb_out  ! Ref orbit at exit of element.
  type (genfield), pointer :: gen_field => null() ! For symp_map
  type (taylor_struct) :: taylor(6)               ! Taylor terms
  type (wake_struct), pointer :: wake => null()   ! Wakefields
  type (wig_term_struct), pointer :: wig_term(:) => null()   ! Wiggler Coefs
  type (trans_space_charge_struct), pointer :: trans_sc => null()
  real(rp) value(n_attrib_maxx)      ! attribute values.
  real(rp) old_value(n_attrib_maxx)  ! Used to see if %value(:) array has changed.
  real(rp) gen0(6)                   ! constant part of the genfield map.
  real(rp) vec0(6)                   ! 0th order transport vector.
  real(rp) mat6(6,6)                 ! 1st order transport matrix.
  real(rp) c_mat(2,2)                ! 2x2 C coupling matrix
  real(rp) gamma_c                   ! gamma associated with C matrix
  real(rp) s                         ! longitudinal position at the exit end.
  real(rp) ref_time                  ! Time ref particle passes exit end.
  real(rp), pointer :: r(:,:) => null()           ! For general use. Not used by Bmad.
  real(rp), pointer :: a_pole(:) => null()        ! multipole
  real(rp), pointer :: b_pole(:) => null()        ! multipoles
  real(rp), pointer :: const(:) => null()         ! Working constants.
    ele_struct definition continued on next figure...
\end{verbatim}
\caption[The \vn{ele_struct} (part 1).]{The \vn{ele_struct}. structure definition. 
The complete structure is shown in this and the following figure.}
\label{f:ele.struct1}
\end{figure}

%--------------------------------------------------------------------------

\begin{figure}[tb]
\centering
\footnotesize
\begin{verbatim}
    ... ele_struct definition continued from previous figure.
  integer key                ! key value
  integer sub_key            ! For wigglers: map_type$, periodic_type$
  integer ix_ele             ! Index in lat%branch(n)%ele(:) array [n = 0 <==> lat%ele(:)].
  integer ix_branch          ! Index in lat%branch(:) array [0 => In lat%ele(:)].
  integer ix_value           ! Overlays: Index of control attribute. 
  integer slave_status       ! super_slave$, etc.
  integer n_slave            ! Number of slaves
  integer ix1_slave          ! Start index for slave elements
  integer ix2_slave          ! Stop  index for slave elements
  integer lord_status        ! overlay_lord$, etc.
  integer n_lord             ! Number of lords
  integer ic1_lord           ! Start index for lord elements
  integer ic2_lord           ! Stop  index for lord elements
  integer ix_pointer         ! For general use. Not used by Bmad.
  integer ixx                ! Index for Bmad internal use
  integer mat6_calc_method   ! bmad_standard$, taylor$, etc.
  integer tracking_method    ! bmad_standard$, taylor$, etc.
  integer field_calc         ! Used with Boris, Runge-Kutta integrators.
  integer num_steps          ! number of slices for DA_maps
  integer integrator_order   ! For Etiennes' PTC: 2, 4, or 6.
  integer ref_orbit          ! Multipass ref orb: single_ref$, match_global_coords$, etc.
  integer taylor_order       ! Order of the taylor series.
  integer aperture_at        ! Aperture location: exit_end$, ...
  integer aperture_type      ! Type of aperture: rectanular$, or elliptical$.
  integer coupler_at         ! Lcavity coupler location: exit_end$, ...
  logical symplectify        ! Symplectify mat6 matrices.
  logical mode_flip          ! Have the normal modes traded places?
  logical multipoles_on      ! For turning multipoles on/off
  logical scale_multipoles   ! multipole components scaled by the strength of element?
  logical map_with_offsets   ! Taylor map calculated with element offsets?
  logical field_master       ! Calculate strength from the field value?
  logical is_on              ! For turning element on/off.
  logical old_is_on          ! For saving the element on/off state.
  logical logic              ! For general use. Not used by Bmad.
  logical bmad_logic         ! For Bmad internal use only.
  logical on_a_girder        ! Have an Girder overlay_lord?
  logical csr_calc_on        ! Coherent synchrotron radiation calculation
  logical offset_moves_aperture  ! element offsets affects aperture?          
end type
\end{verbatim}
\caption[The \vn{ele_struct} (part 2).]{The \vn{ele_struct}. 
The complete structure is shown in this and the preceeding figure.}
\label{f:ele.struct2}
\end{figure}

%--------------------------------------------------------------------------
\section{Initialization and Pointers}
\index{ele_struct!initialization}
\index{ele_struct!pointer components}

The \vn{ele_struct} has a number of components and subcomponents 
that are pointers and this raises a deallocation issue.
Generally, most \vn{ele_struct} elements are part of a \vn{lat_struct}
variable (\sref{s:lat:point})
and such elements in a \vn{lat_struct} are handled by the
\vn{lat_struct} allocation/deallocation routines. 
In the case where a local \vn{ele_struct}
variable is used within a subroutine or function, the \vn{ele_struct} 
variable must either be defined with the \vn{save} attribute 
\begin{example}
  type (ele_struct), save :: ele          ! Use the save attribute
  logical, save :: init_needed = .false.
  ...
  if (init_needed) then
    call init_ele (ele)                ! Initialize element once
    init_needed = .false.
  endif
\end{example}
or the pointers within the variable must be deallocated  with a call to
\Hyperref{r:deallocate.ele.pointers}{deallocate_ele_pointers}:
\begin{example}
  type (ele_struct) ele  
  ...
  call init_ele (ele)                ! Initialize element each time
  ...
  call deallocate_ele_pointers (ele) ! And deallocate.
\end{example}

In the normal course of events, the pointers of an \vn{ele_struct} variable
should not be pointing to the same memory locations as the pointers
of any other \vn{ele_struct} variable. To make sure of this,
the equal sign in the assignment \vn{ele1 = ele2}
is overloaded by the routine \Hyperref{r:ele.equal.ele}{ele_equal_ele}
and this routine will allocate as necessary.

%--------------------------------------------------------------------------
\section{String Components}
\label{s:ele.string}

\index{ele_struct!\%descrip}\index{ele_struct!\%alias}
\index{ele_struct!\%type}\index{ele_struct!\%name}
The \vn{%name}, \vn{%type}, \vn{%alias}, and \vn{%descrip} components
of the \vn{ele_struct} all have a direct correspondence with
the \vn{name}, \vn{type}, \vn{alias}, and \vn{descrip} element attributes in
an input lattice file (\sref{s:string}). On input (\sref{s:lat.readin}), 
from a lattice file,  
\vn{name}, \vn{type}, and \vn{alias} attributes will be converted to
to uppercase before being loaded 
into an \vn{ele_struct}. To save memory, since \vn{%descrip} is not frequently used,
\vn{%descrip} is a pointer that is only allocated if \vn{descrip} is set for 
a given element.

%--------------------------------------------------------------------------
\section{Element Key}
\label{s:ele.key}

\index{ele_struct!\%key}
The \vn{%key} integer component gives the class of element
(\vn{quadrupole}, \vn{rfcavity}, etc.). In general, to get the
corresponding integer parameter for an element class, just add a ``\$''
character to the class name. For example \vn{quadrupole\$} is the integer
parameter for \vn{quadrupole} elements. The \vn{key_name} array converts from
integer to the appropriate string. For example:
\begin{example}
  type (ele_struct) ele
  if (ele%key == wiggler\$) then       ! Test if element is a wiggler.
  print *, 'This element: ', key_name(ele%key) ! Prints, for example, 'WIGGLER'
\end{example}
Note: The call to \vn{init_ele} is needed for any \vn{ele_struct} defined
outside of a \vn{lat_struct} structure.

\index{wiggler}\index{rbend}\index{sbend}\index{ele_struct!\%sub_key}
The \vn{%sub_key} component is only used for \vn{Wiggler}, \vn{Rbend} and
\vn{Sbend} elements. For \vn{Wiggler} elements, \vn{%sub_key} is either set to
\begin{example}
  map_type$ or
  periodic_type$
\end{example}
depending upon the type of wiggler. For bend elements,
when a lattice file is parsed (\sref{s:lat.readin}), 
all \vn{rbend} elements are converted into
\vn{sbend} elements (\sref{s:bend}). To keep track of what the original definition
of the element was, the \vn{%sub_key} component will be set to \vn{sbend\$} or
\vn{rbend\$} whatever is appropriate. In the case of bends, the \vn{%sub_key} component
does not affect any calculations and is only used in the routines that recreate
lattice files from a \vn{lat_struct} (\sref{s:lat.write}).

%--------------------------------------------------------------------------
\section{The \%value(:) array}
\label{s:ele.dep}
\index{ele_struct!attribute values}

\index{ele_struct!\%value(:)}
Most of the real valued attributes of an element are held in the
\vn{%value(:)} array. For example, the value of the \vn{k1} attribute
for a quadrupole element is stored in \vn{%value(k1\$)} where
\vn{k1\$} is an integer parameter that \bmad defines. 
In general, to get the correct index
in \vn{%value(:)} for a given attribute, add a ``\$" as a
suffix. To convert from an attribute name to its index in the
\vn{%value} array use the \Hyperref{r:attribute.index}{attribute_index} 
routine.  To go back
from an index in the \vn{%value} array to a name use the
\Hyperref{r:attribute.name}{attribute_name} routine. Example:
\begin{example}
  type (ele_struct) ele
  call init_ele (ele)    ! Initialize element
  ele%key = quadrupole$  ! Set element to be a quadrupole
  ele%value(k1$) = 0.3                                        ! Set K1 value
  print *, 'Index for Quad K1:  ', attribute_index(ele, 'K1') ! prints: `4' (= k1\$)
  print *, 'Name for Quad k1\$: ', attribute_name (ele, k1\$)   ! prints: `K1' 
\end{example}
The list of attributes for a given element
type is given in the writeup for the different element in
Chapter~\ref{c:elements}. 

There are also 5 slots in the \vn{%value(:)} array for general use.
they have indexes labeled \vn{general1\$} through \vn{general5\$}. These
slots are not used by \bmad so a program can take advantage of them.
The index names can be redefined to fit a particular need. For example, suppose
a program needs to store a time stamp number. The code to do this could look
like:
\begin{example}
  integer, parameter :: time_stamp\$ = general1\$
  ...
  lat%ele(i)%value(time_stamp$) = ...
\end{example}

\index{ele_struct!\%field_master}
The \vn{%field_master} logical within an element 
sets whether it is the normalized strength or field strength that is
the independent variable. See \sref{s:depend} for more details.

\index{ele_struct!\%old_value(:)}
The \vn{%old_value(:)} component of the \vn{ele_struct} is used by the 
\href[r:attribute.bookkeeper]{attribute_bookkeeper} routine to check for
changes for changes in the \vn{%value(:)} array since the last time 
the \vn{attribute_bookkeeper} routine had been called. 
If nothing has been changed, the \vn{attribute_bookkeeper} routine knows
not to waste time recalculating dependent values. Essentially what
this means is that the \vn{%old_value(:)} 
array should not be modified outside of \vn{attribute_bookkeeper}.

%--------------------------------------------------------------------------
\section{Limits}
\index{aperture}
\index{x_limit}\index{x1_limit}\index{x2_limit}
\index{x_limit}\index{x1_limit}\index{x2_limit}

The aperture limits (\sref{s:limit}) in the \vn{ele_struct} are:
\begin{example}
  %value(x1_limit$)
  %value(x2_limit$)
  %value(y1_limit$)
  %value(y2_limit$)
\end{example}
The values of these limits along with the \vn{%aperture_at}, \vn{%aperture_type},
and \vn{%offset_moves_aperture} components are used in tracking to determine
if a particle has hit the vacuum chamber wall. See Section~\sref{s:tracking.apertures}
for more details.

%--------------------------------------------------------------------------
\section{Twiss Parameters, etc.}
\label{s:ele.twiss}

\index{ele_struct!\%gamma_c}
\index{ele_struct!\%c_mat}
\index{ele_struct!\%a}\index{ele_struct!\%b}\index{ele_struct!\%z}
\index{ele_struct!\%mode3}\index{ele_struct!\%mode_flip}

The components \vn{%a}, \vn{%b}, \vn{%z}, \vn{%x}, \vn{%y}, \vn{%c_mat}, 
\vn{%gamma_c}, \vn{%mode_flip}, and \vn{mode3} 
hold information on the Twiss parameters, dispersion, and coupling
at the exit end of the element. See \cref{c:twiss} for more details.

%--------------------------------------------------------------------------
\section{Element Lords and Element Slaves}
\label{s:ele.control}

\index{ele_struct!\%slave_status}
\index{ele_struct!\%n_slave}
\index{ele_struct!\%ix1_slave}
\index{ele_struct!\%ix2_slave}
\index{ele_struct!\%lord_status}
\index{ele_struct!\%n_lord}
\index{ele_struct!\%ic1_lord}
\index{ele_struct!\%ic2_lord}
\index{ele_struct!\%component_name}
In \bmad, elements in a lattice can control other elements.
The components that determine this control are:
\begin{example}
  %slave_status
  %n_slave
  %ix1_slave
  %ix2_slave
  %lord_status
  %n_lord
  %ic1_lord
  %ic2_lord
  %component_name
\end{example}
\index{lat_struct}
This is explained fully in the chapter on the \vn{lat_struct} (\sref{c:lat.struct}).

%--------------------------------------------------------------------------
\section{Coordinates, Offsets, etc.}
\index{global coordinates!in ele_struct}

\index{ele_struct!\%floor}
\index{floor_position_struct}
The \vn{%floor} component gives the global ``floor'' coordinates (\sref{s:global})
at the exit end of the element. The components of the \vn{%floor} structure are
\begin{example}
  type floor_position_struct
    real(rp) x, y, z            ! offset from origin
    real(rp) theta, phi, psi    ! angular orientation
  end type
\end{example}
The routine \Hyperref{r:ele.geometry}{ele_geometry} will calculate an element's 
floor coordinates given the floor coordinates at the beginning of the element.
In a lattice, the \Hyperref{r:lat.geometry}{lat_geometry} routine will calculate
the floor coordinates for the entire lattice using repeated calls to \vn{ele_geometry}.

\index{x_offset}\index{y_offset}\index{x_pitch}\index{y_pitch}
\index{tilt}\index{x_offset_tot}\index{y_offset_tot}\index{x_pitch_tot}
\index{y_pitch_tot}\index{tilt_tot}
The positional offsets (\sref{s:offset}) for an element 
from the reference orbit are stored in
\begin{example}
  %value(x_offset\$)
  %value(y_offset\$)
  %value(x_pitch\$)
  %value(y_pitch\$)
  %value(tilt\$)
\end{example}
\index{girder}
If the element is supported by a \vn{girder} element (\sref{s:girder})
then the \vn{girder} offsets are added to the element offsets 
and the total offset with respect to the
reference coordinate system is stored in:
\begin{example}
  %value(x_offset_tot\$)
  %value(y_offset_tot\$)
  %value(x_pitch_tot\$)
  %value(y_pitch_tot\$)
  %value(tilt_tot\$)
\end{example}
If there is no \vn{girder}, the values for \vn{%value(x_offset_tot\$)}, etc.
are set to the corresponding values in \vn{%value(x_offset\$)}, etc.
Thus, to vary the position of an individual
element the values of \vn{%value(x_offset\$)}, etc. are changed and to
read the position of an element a program should look at
\vn{%value(x_offset_tot\$)}, etc.

\index{ele_struct!\%s}
\index{ele_struct!\%ref_time}
The longitudinal position at the exit end of an element is stored in \vn{%s}
and the reference time is stored in \vn{%ref_time}. See \sref{s:global}
for more details.

%--------------------------------------------------------------------------
\section{Transfer Maps: Linear and Non-linear (Taylor)}
\index{ele_struct!transfer maps}
\index{transfer map!in ele_struct}
\index{ele_struct!\%mat6}
\index{ele_struct!\%vec0}
\index{ele_struct!\%map_ref_orb_in}
\index{ele_struct!\%map_ref_orb_out}

The routine \Hyperref{r:make.mat6}{make_mat6} computes the linear 
transfer matrix (Jacobian) along with the zeroth order transfer vector. 
This matrix is stored in \vn{%mat6(6,6)} and the
zeroth order vector is stored in \vn{%vec0(6)}. The reference orbit at
the entrance end of the element about
which the transfer matrix is computed is stored in \vn{%map_ref_orb_in}
and the the reference orbit at the exit end is stored in \vn{%map_ref_orb_out}.
In the calculation of the transfer map, the vector \vn{%vec0} is set so that
\begin{example}
  map_ref_orb_out = %mat6 * map_ref_orbit_in + %vec0
\end{example}
The reason redundant information is stored in the element is to save
computation time.

To compute the transfer maps for an entire lattice use the routine 
\Hyperref{r:lat.make.mat6}{lat_make_mat6}.

\index{ele_struct!Taylor maps}
\index{taylor map!structure in ele_struct}
The Taylor map (\sref{c:methods})  for an element is stored in
\vn{%taylor(1:6)}. Each \vn{%taylor(i)} is a \vn{taylor_struct}
structure that defines a Taylor series:
\begin{example}
  type taylor_struct
    real (rp) ref
    type (taylor_term_struct), pointer :: term(:) => null()
  end type
\end{example}
Each Taylor series has an array of \vn{taylor_term_struct} terms defined as
\begin{example}
  type taylor_term_struct
    real(rp) :: coef
    integer :: exp(6)
  end type
\end{example}
The coefficient for a Taylor term is stored in \vn{%coef} and the
six exponents are stored in \vn{%exp(6)}. 

To see if there is a Taylor map associated with an element the
association status of \vn{%taylor(1)%term} needs to be checked.
As an example the following finds the order of a Taylor map.
\begin{example}
  type (ele_struct) ele
  ...
  if (associated(ele%taylor(1)%term) then  ! Taylor map exists
    taylor_order = 0
    do i = 1, 6
      do j = 1, size(ele%taylor(i)%term)
        taylor_order = max(taylor_order, sum(ele%taylor(i)%term(j)%exp)
      enddo
    enddo
  else  ! Taylor map does not exist
    taylor_order = -1  ! flag non-existence
  endif
\end{example}

The Taylor map is made up around some reference phase space point
corresponding to the coordinates at the entrance of the element.
This reference point is saved in \vn{%taylor(1:6)%ref}.  Once a Taylor map is
made, the reference point is not needed in subsequent
calculations. However, the Taylor map itself will depend upon what
reference point is chosen (\sref{s:taylor.phys}).

\index{ele_struct!\%gen_field}
\index{ele_struct!\%gen0}
When using the \vn{symp_map\$} tracking method (\sref{s:tkm}), the pointer
to the partially inverted Taylor map is stored in the \vn{%gen_field} component
of the \vn{ele_struct}. The actual storage of the map is handled by the
PTC library (\sref{s:libs}). The PTC partially inverted map does not have any
zeroth order terms so the zeroth order terms are stored in the \vn{%gen0(6)} vector.

%--------------------------------------------------------------------------
\section {Wake fields}
\index{wake fields!in ele_struct}

\index{ele_struct!\%wake}
See \sref{s:wake fields} for the equations used in wake field
calculations.  Wake fields are stored in the \vn{%wake} struct:
\begin{example}
  type wake_struct
    character(200) :: sr_file = ' '
    character(200) :: lr_file = ' '
    type (sr_table_wake_struct), pointer :: sr_table(0:) => null()
    type (sr_mode_wake_struct), pointer :: sr_mode_long(:) => null()
    type (sr_mode_wake_struct), pointer :: sr_mode_trans(:) => null()
    type (lr_wake_struct), pointer :: lr(:) => null()
    real(rp) :: z_sr_mode_max = 0   
  end type
\end{example}
Since \vn{%wake} is a pointer its association status must be tested
before any of its sub--components are accessed.
\begin{example}
  type (ele_struct) ele
  ...
  if (associated(ele%wake)) then
    ...
\end{example}

\bmad observes the following rule: If \vn{%wake} is associated then it
is assumed that all the sub--components (\vn{%wake%sr_table}, etc.) are
associated. This simplifies programming in that you do not have to
test directly the association status of the sub--components.

The short--range wake can be parameterized in either of two ways.
One parameterization uses a table of wake verses z position. 
If this parameterization utilizes the \vn{%wake%sr_table(0:)} array
The structure of each element in this array is:
\begin{example}
  type sr_table_wake_struct  ! Tabular short-Range Wake struct
    real(rp) z               ! Distance behind the leading particle
    real(rp) long            ! Longitudinal wake in V/C/m
    real(rp) trans           ! Transverse wake in V/C/m^2
  end type
\end{example}
All \vn{%wake%sr_table(0:)%z} must be negative except \vn{%wake%sr_table(0)%z} 
= 0. Wake field kicks are applied using \Eqs{delvp} and \eq{pelqxw}.

The alternative short--range wake parameterization uses pseudo--modes (\Eq{wadzk}).
This parameterization utilizes the \vn{%wake%sr_mode_long}, and \vn{%wake%sr_mode_trans}
arrays for the longitudinal and transverse modes respectively.
The structure used for the elements of these arrays are:
\begin{example}
  type sr_mode_wake_struct  ! Pseudo-mode short-range wake struct 
    real(rp) amp        ! Amplitude
    real(rp) damp       ! Damping factor.
    real(rp) freq       ! Frequency in Hz
    real(rp) phi        ! Phase in radians/2pi
    real(rp) norm_sin   ! non-skew sin-like component of the wake
    real(rp) norm_cos   ! non-skew cos-like component of the wake
    real(rp) skew_sin   ! skew sin-like component of the wake
    real(rp) skew_cos   ! skew cos-like component of the wake
  end type
\end{example}
The wake field kick is calculated from \Eq{wadzk}. \vn{%amp},
\vn{%damp}, \vn{%freq}, and \vn{%phi} are the input parameters from
the lattice file. the last four components (\vn{%norm_sin}, etc.)
store the accumulated wake: Before the bunch passes through these are
set to zero and as each particle passes through the cavity the
contribution to the wake due to the particle is calculated and added
the components.

\vn{%wake%z_sr_mode_max} is the maximum $z$ value beyond which the pseudo
mode representation is not valid. This is set in the input lattice file.

\index{lr_wake_struct}
The \vn{%wake%lr} array stores the long--range wake modes. The
structure definition is:
\begin{example}
  type lr_wake_struct   ! Long-Range Wake struct 
    real(rp) freq       ! Actual Frequency in Hz
    real(rp) freq_in    ! Input frequency in Hz
    real(rp) R_over_Q   ! Strength in V/C/m^2
    real(rp) Q          ! Quality factor
    real(rp) angle      ! polarization angle (radians/2pi).
    integer m           ! Order (1 = dipole, 2 = quad, etc.)
    real(rp) norm_sin   ! non-skew sin-like component of the wake
    real(rp) norm_cos   ! non-skew cos-like component of the wake
    real(rp) skew_sin   ! skew sin-like component of the wake
    real(rp) skew_cos   ! skew cos-like component of the wake
    logical polarized   ! Polarized mode?
  end type
\end{example}
\index{lr_freq_spread}
This is similar to the \vn{sr_mode_wake_struct}. \vn{%freq_in} is the
actual frequency in the input file. \Hyperref{r:bmad.parser}{bmad_parser} will set
\vn{%freq} to \vn{%freq_in} except when the \vn{lr_freq_spread} attribute
is non-zero in which case \vn{bmad_parser} will vary \vn{%freq} as
explained in \sref{s:lcav}. \vn{%polarized} is a logical that
indicates whether the the mode has a polarization angle. If so, then
\vn{%angle} is the polarization angle.

%--------------------------------------------------------------------------
\section {Wiggler Types}
\index{wiggler!types}

The \vn{%sub_key} component of the \vn{ele_struct} is used to distinguish
between \vn{map type} and \vn{periodic type} wigglers (\sref{s:ele.key}):
\begin{example}
  if (ele%key == wiggler\$ .and. ele%sub_key == map_type$) ...
  if (ele%key == wiggler\$ .and. ele%sub_key == periodic_type$) ...
\end{example}
For a \vn{map} type wiggler, the wiggler field terms
(\sref{s:wiggler.phys}) are stored in the \vn{%wig_term(:)} array of
the \vn{element_struct}. This is an array of \vn{wig_term_struct}
structure. A \vn{wig_term_struct} looks like:
\index{wig_term_struct}
\begin{example}
  type wig_term_struct
    real(rp) coef
    real(rp) kx, ky, kz
    real(rp) phi_z
    integer type      ! hyper_y\$, hyper_xy\$, or hyper_x\$
  end type
\end{example}
A \vn{periodic} wiggler will have a single \vn{%wig_term(:)} term that
can be used for tracking purposes, etc. The setting for this
\vn{wig_term} element is
\begin{example}
  ele%wig_term(1)%ky     = pi / ele%value(l_pole$)
  ele%wig_term(1)%coef   = ele%value(b_max$)
  ele%wig_term(1)%kx     = 0
  ele%wig_term(1)%kz     = ele%wig_term(1)%ky
  ele%wig_term(1)%phi_z  = (ele%value(l_pole$) - ele%value(l$)) / 2
  ele%wig_term(1)%type   = hyper_y$
\end{example}

%--------------------------------------------------------------------------
\section {Multipoles}
\index{ele_struct!multipoles}

\index{ele_struct!\%b(:)}\index{ele_struct!\%a(:)}
\index{multipole!an, bn!in ele_struct}
\index{multipole!KnL, Tn!in ele_struct}
\index{multipole!\%scale_multipoles}
The multipole components of an element (See \sref{s:fields}) are
stored in the pointers \vn{%a(:)} and \vn{%b(:)}. If \vn{%a} and
\vn{%b} are allocated they always have a range \vn{%a(0:n_pole_maxx)}
and \vn{%b(0:n_pole_maxx)}. Currently \vn{n_pole_maxx} = 20. For a
\vn{Multipole} element, the \vn{%a(n)} array stores the integrated
multipole strength \vn{KnL}, and the \vn{%b(n)} array stores the tilt
\vn{Tn}.

A list of \bmad routines for manipulating multipoles can be found in
\sref{r:multipoles}.

%--------------------------------------------------------------------------
\section{Tracking Methods}
\label{s:ele.tracking.methods}

A number of \vn{ele_struct} components control tracking and transfer
map calculations.  These are:
\begin{example}
  %mat6_calc_method
  %tracking_method
  %num_steps
  %integrator_order
  %taylor_order
  %symplectify
  %multipoles_on
  %map_with_offsets
  %is_on
  %csr_calc_on
  %offset_moves_apaerture
\end{example}
See Chapter~\sref{c:tracking} for more details.

%--------------------------------------------------------------------------
\section{General Use Components}
\index{ele_struct!components not used by Bmad}

\index{ele_struct!\%r}
\index{ele_struct!\%ix_pointer}
\index{ele_struct!\%logic}
There are three components of an \vn{ele_struct} that are guaranteed
to never be used by any \bmad routine and so are available for use by
someone writing a program. These components are
\begin{example}
   real(rp), pointer :: r(:) => null()  
   integer ix_pointer                 
   logical logic                      
\end{example}

%--------------------------------------------------------------------------
\section{Bmad Reserved Variables}

index{ele_struct!\%ixx}
index{ele_struct!\%old_is_on}
index{ele_struct!\%bmad_logic}
index{ele_struct!\%const}
A number of \vn{ele_struct} components are reserved for use by \bmad routines
only. These are:
\begin{example}
  %ixx
  %old_is_on
  %bmad_logic
  %const(:)
\end{example}

%--------------------------------------------------------------------------
\section{Creating Element Slices}

\index{sbend}\index{rbend}\index{wiggler}
It is sometimes convenient to split an element longitudinally into
``slices'' that represent a part of the element.  This is complicated
by the fact that elements are not necessarily uniform.  For example,
map type wigglers are nonuniform and bend elements have end effects.
Furthermore, attributes like \vn{hkick} need to be scaled with the
element length.

To create an element slice, the routine
\Hyperref{r:create.element.slice}{create_element_slice} can be used.
Example:
\begin{example}
  type (ele_struct) ele, sliced_ele
  ...
  sliced_ele = ele
  sliced_ele%value(l$) = l_slice ! Set the sliced element's length
  call create_element_slice (sliced_ele, ele, l_start, param, include_entrance, include_exit)
\end{example}
See the documentation on \vn{create_element_slice} for more details (sref{s:getf}).