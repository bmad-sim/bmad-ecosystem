\chapter{Twiss Parameters, Coupling, Chromaticity, Etc.}
\label{c:twiss}

%-----------------------------------------------------------------------------
\section{Components in the Ele\_struct}
\label{s:twiss.ele}

\index{ele_struct!\%gamma_c}
\index{ele_struct!\%c_mat}
\index{ele_struct!\%a}\index{ele_struct!\%b}\index{ele_struct!\%z}
The \vn{ele_struct} (\sref{c:ele.struct}) has a number of components that
hold information on the Twiss parameters, dispersion, and coupling
at the exit end of the element. The Twiss parameters of the three 
normal modes (\sref{s:coupling})
are contained in the \vn{ele%a}, \vn{ele%b}, and \vn{ele%z} 
components which are of type \vn{twiss_struct}:
\index{twiss_struct}
\begin{example}
  type twiss_struct
    real(rp) beta         ! Twiss Beta function
    real(rp) alpha        ! Twiss Alpha function
    real(rp) gamma        ! Twiss gamma function
    real(rp) phi          ! Normal mode Phase advance
    real(rp) eta          ! Normal mode dispersion
    real(rp) etap         ! Normal mode dispersion derivative
    real(rp) sigma        ! Normal mode beam size
    real(rp) sigma_p      ! Normal mode beam size derivative
    real(rp) emit         ! Geometric emittance
    real(rp) norm_emit    ! Normalized emittance
  end type 
\end{example}
\index{xy_disp_struct}
The projected horizontal and vertical dispersions in an
\vn{ele_struct} are contained in the \vn{ele%x} and \vn{ele%y}
components. These components are of type \vn{xy_disp_struct}:
\index{xy_disp_struct}
\begin{example}
  type xy_disp_struct
    real(rp) eta     ! Projected dispersion 
    real(rp) etap    ! Projected dispersion derivative.
  end type 
\end{example}

\index{ele_struct!\%c}\index{ele_struct!\%gamma_c}
The relationship between the projected and normal mode dispersions are
given by \Eq{avx}. The 2x2 coupling matrix $\bfC$ (\Eq{vgicc1}) is
stored in the \vn{ele%c(2,2)} component of the \vn{ele_struct} and the
$\gamma$ factor of \Eq{vgicc1} is stored in the \vn{ele%gamma_c}
component. There are several routines to manipulate the coupling
factors. For example:
\begin{example}
  \Hyperref{r:c.to.cbar}{c_to_cbar}(ele, cbar_mat)             ! Form Cbar(2,2) matrix
  \Hyperref{r:make.v.mats}{make_v_mats}(ele, v_mat, v_inv_mat)   ! Form V coupling matrices.
\end{example}
See \sref{r:mat} for a complete listing of such routines.

Since the normal mode and projected dispersions are related, when one
is changed within a program the appropriate change must be made to the
other. To make sure everything is consistent, the
\Hyperref{r:changed.attribute.bookkeeper}{changed_attribute_bookkeeper}
routine can be used. Example:
\begin{example}
  type (lat_struct), target :: lat
  real(rp), pointer :: attrib_ptr
  ...
  attrib_ptr => lat%ele(ix_ele)%value(k1$) ! Point to some attribute.
  attrib_ptr = value                       ! Change the value.
  call changed_attribute_bookkeeper (lat, lat%ele(ix_ele), attrib_ptr)
\end{example}

The \vn{%mode_flip} logical component of an \vn{ele_struct} indicates
whether the $a$ and $b$ normal modes have been flipped relative to the
beginning of the lattice. See Sagan and Rubin\cite{b:coupling} for a
discussion of this. The convention adopted  by \bmad is that the
\vn{%a} component of all the elements in a lattice will all correspond
to the same physical normal mode. Similarly, the \vn{%b} component of all
the elements will all correspond to some (other) physical normal mode.
That is, at an element where there is a mode flip (with \vn{%mode_flip} 
set to True), 
the \vn{%a} component actually corresponds to the $\bfB$ matrix
element in \Eq{ua00b} and vice versa. The advantage of this convention
is that routines that calculate properties of the modes (for example the
emittance), can ignore whether the modes are flipped or not.

The normal mode analysis of Sagan and Rubin,
while it has the benefit of simplicity, is strictly
only applicable to lattices where the RF cavities are turned off. 
The full 6-dimensional analysis is summarized by Wolski\cite{b:wolski.coupling}. 
The \Hyperref{r:normal.mode3.calc}{normal_mode3_calc} routine perform 
the full analysis. The results are put in
the \vn{%mode3} component of the \vn{ele_struct} which is of type \vn{mode3_struct}:
\index{ele_struct!\%mode3}
\index{mode3_struct}
\begin{example}
  type mode3_struct
    real(rp) v(6,6)
    type (twiss_struct) a, b, c
    type (twiss_struct) x, y
  end type
\end{example}
The 6-dimensional \vn{mode3%v(6,6)} component is the analog of the 4-dimensional
$\bfV$ matrix appearing in \Eq{tvuv}.

%-----------------------------------------------------------------------------
\section{Twiss Parameter Calculations}
\label{s:twiss}
\index{twiss parameters}
\index{twiss parameters!calculation}

A calculation of the Twiss parameters starts with the Twiss parameters
at the beginning of the lattice. For linear machines, these Twiss parameters
are generally set in the input lattice file (\sref{s:beginning}). For
circular machines, 
the routine \Hyperref{r:twiss.at.start}{twiss_at_start} 
may be used (\sref{s:beginning})
\begin{example}
  type (lat_struct) lat
  ...
  if (lat%param%lattice_type == circular_lattice$) call twiss_at_start(lat)
\end{example}
In either case, the initial Twiss parameters are placed in \vn{lat%ele(0)}. 
The tune is placed in the variables \vn{lat%a%tune} and \vn{lat%b%tune}.

To propagate the Twiss, coupling and dispersion parameters from the
start of the lattice to the end, the routine,
\Hyperref{r:twiss.propagate.all}{twiss_propagate_all} can be
used. This routine works by repeated calls to
\Hyperref{r:twiss.propagate1}{twiss_propagate1} which does a single
propagation from one element to another. The Twiss propagation depends
upon the transfer matrices having already computed
(\sref{c:tracking}).  \vn{twiss_propagate_all} also computes the Twiss
parameters for all the lattice branches. 

Before any Twiss parameters can be calculated, the transfer matrices
stored in the lattice elements must be computed. 
\Hyperref{r:bmad.parser}{bmad_parser} does
this automatically about the zero orbit. If, to see nonlinear effects,
a different orbit needs to be used for the reference, The routine
\Hyperref{r:lat.make.mat6}{lat_make_mat6} can be used. For example
\begin{example}
  type (lat_struct) lat
  type (coord_struct), allocatable :: orbit(:)
  call bmad_parser ('my_lattice', lat)
  call closed_orbit_calc (lat, orbit, 4)
  call lat_make_mat6 (lat, -1, orbit)
\end{example}
This example reads in a lattice, finds the closed orbit which may be
non--zero due to, say, non-zero kickers or quadrupole offsets, and
then remakes the transfer matrices, which are stored in
\vn{lat%ele(i)%mat6}, around the closed orbit.

Once the starting Twiss parameters are set,
\Hyperref{r:twiss.propagate.all}{twiss_propagate_all} can be used to
propagate the Twiss parameters to the rest of the elements
\begin{example}
  call twiss_propagate_all (lat)
\end{example}

The routine \Hyperref{r:twiss.and.track.at.s}{twiss_and_track_at_s}
can be used to calculate the Twiss parameters at any given
longitudinal location. Alternatively, to propagate the Twiss
parameters partially through a given element use the the routine
\Hyperref{r:twiss.and.track.partial}{twiss_and_track_partial}.

%-----------------------------------------------------------------------------
\section{Tune Calculation}
\label{s:tune}
\index{tune calculation}

The routine \Hyperref{r:set.tune}{set_tune} can be used
to set the transverse tunes:
\begin{example}
  set_tune (phi_a_set, phi_b_set, dk1, lat, orb_, ok)
\end{example}
\vn{set_tune} varies quadrupole strengths until the desired tunes are
achieved. As input,\vn{set_tune} takes an argument \vn{dk1(:)} which is an array
that specifies the relative change to be make to the quadrupoles in the lattice.

To set the longitudinal (synchrotron) tune, the routine
\Hyperref{r:set.z.tune}{set_z_tune} can be used. 
\Hyperref{r:set.z.tune}{set_z_tune} works by varying rf cavity
voltages until the desired tune is achieved.

%-----------------------------------------------------------------------------
\section{Chromaticity Calculation}
\label{s:chrom}

\index{chromaticity}
For a circular lattice, \Hyperref{r:chrom.calc}{chrom_calc} 
calculates the chromaticity by calculating
the tune change with change in beam energy.

\Hyperref{r:chrom.tune}{chrom_tune} sets the chromaticity by 
varying the sextupoles. This is a 
very simple routine that simply divides the sextupoles into two families
based upon the local beta functions at the sextupoles.



