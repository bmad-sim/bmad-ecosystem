\chapter{Tracking and Transfer Matrix Calculation Methods}
\label{c:methods}

\index{element!class}
\index{tracking_method}
\index{mat6_calc_method}
Typically, there are several ways to do tracking and transfer matrix
calculations for a given element class within \bmad. What method is
used is selected on an element--by--element basis using the attributes
\begin{example}
  tracking_method = Switch   ! Method for tracking.
  mat6_calc_method = Switch  ! Method for 6x6 transfer matrix calculation.
\end{example}
These switches are discussed in more detail in sections \sref{s:tkm} 
and \sref{s:xfer}. Example:
\begin{example}
  q2: quadrupole, tracking_method = boris
  q2[tracking_method] = boris
  quadrupole[tracking_method] = boris
\end{example}
The first two lines of this example have exactly the same effect in
terms of setting the \vn{tracking_method}. The third line shows how to
set the \vn{tracking_method} for an entire class of elements.

\index{sympliectify}
\index{map_with_offsets}
Two element attributes that can affect the way the transfer matrix is
calculated are \vn{symplectify} and \vn{map_with_offsets}. These are
discussed in \sref{s:symp} and \sref{s:mapoff} respectively.

%----------------------------------------------------------------------------
\section{tracking_method Switches}
\label{s:tkm}
\index{tracking methods|hyperbf}

The \vn{tracking_method} attribute of an element sets the algorithm that is
used for single particle tracking through that element.
A table giving which methods are available with which element classes is
given in Table~\ref{t:track.methods}.

A note on terminology: Adaptive step size control used with the
\vn{adaptive_boris} and \vn{Runge_Kutta} integrators means that 
instead of taking fixed step sizes the integrator chooses the proper
step size so that the error in the tracking is below the maximum
allowable error set by \vn{rel_tol} and \vn{abs_tol} tolerances. The
advantage of step size control is that the integrator uses a smaller
step size when needed (the fields are rapidly varying), but makes
larger steps when it can. The disadvantage is that a step is more
computationally intensive since the error in a step is estimated by
repeating a step using two mini steps. If the fields are rather
uniform and you know what a good step size is you can save time by using
a fixed step size.

\begin{description}
\index{adaptive_boris!tracking method}
\item[\vn{adaptive_boris}]
Second order Boris integration\cite{b:boris} with adaptive step size control.
This should be nearly symplectic but slow.

\index{boris}
\item[\vn{Boris!tracking method}]
Second order Boris Integration\cite{b:boris}. Like \vn{Runge_Kutta},
\vn{Boris} does tracking by integrating the equation of
motion. \vn{Boris} handles both electric and magnetic fields and does
not assume that the particle is ultra--relativistic. \vn{Boris} preserves
conserved quantities more accurately than \vn{Runge_Kutta}.

\index{bmad_standard}
\item[\vn{Bmad_Standard!tracking method}]
Uses formulas for tracking. The emphasis here is on speed. Note: If an
element has non-zero multipole values, \vn{Bmad_Standard} tracking
will generally put half the multipole kick at the beginning of the
element and half at the end. This is generally a good approximation
but in it can result in differences between this and tracking methods
like \vn{Symp_Lie_PTC} which model multipoles as as distributed evenly
throughout an element.

\index{custom}
\item[\vn{Custom!tracking method}]
This method will call a routine \vn{track1_custom} which must be
supplied by the programmer implementing the custom tracking. The
default \vn{track1_custom} supplied with the \bmad\ release will print
an error message and stop the program if it is called which probably
indicates a program linking problem.

\index{linear!tracking method}
\item[\vn{Linear}]
Linear just uses the 0th order vector with the 1st order 6x6 transfer
matrix for an element. Very simple.  Depending upon how the transfer
matrix was generated this may or may not be symplectic.

\index{MAD!tracking method}
\item[\vn{MAD}]
This uses the MAD 2nd order transfer map.

\index{none}
\item[\vn{None!tracking method}]
This prevents the transfer matrix from being recomputed.
Using \vn{None} in the input file is generally not a good idea since
it prevents the matrix from being computed in the first place.
Typically \vn{None} is used internally in a program to prevent recomputation.

\index{runge_kutta}
\item[\vn{runge_kutta!tracking method}]
This uses a 4\Th order Runge Kutta integration algorithm with adaptive
step size control.  This is essentially the \vn{ODEINT} subroutine
from Numerical Recipes\cite{b:nr}. This may be slow but it should be
accurate. This method is non-symplectic.

\index{symp_lie_Bmad}
\item[\vn{Symp_Lie_Bmad!tracking method}]
Symplectic tracking using a Hamiltonian with Lie operation techniques.
This is similar to \vn{Symp_Lie_PTC} (see below) except this uses a
\bmad\ routine. By bypassing some of the generality inherent in PTC's routines
\vn{Symp_Lie_Bmad} achieves about a factor of 10 improvement in speed over
\vn{Symp_Lie_PTC}. However, \vn{Symp_Lie_Bmad} is
currently only implemented for Wigglers.

\index{symp_lie_ptc!tracking method}
\item[\vn{Symp_Lie_PTC}]
Symplectic tracking using a Hamiltonian with Lie operator techniques.
This uses Etienne's PTC software for the calculation. This method is
symplectic but can be slow.

\index{symp_map!tracking method}
\item[\vn{Symp_Map}]
This uses a partially inverted, implicit Taylor map. The calculation
uses Etienne's PTC software.  Since the map is implicit, a Newton
search method must be used. This will slow things down from the Taylor
method but this is guaranteed symplectic. Note: Due to memory limitations
in PTC, the number of elements using symp_map is limited to be of order 50.

\index{taylor!tracking method}
\item[\vn{Taylor}]
This uses a Taylor map generated from Etienne's PTC
package. Generating the map may take time but once you have it it
should be very fast. One possible problem with using a Taylor map is
that you have to worry about the accuracy if you do tracking at points
that are far from the expansion point about which the map was
made. This method is non-symplectic away from the expansion
point. Whether the Taylor map is generated taking into account the
offset an element has is governed by the \vn{map_with_offsets}
attribute (\sref{s:mapoff}). Note: Taylor maps for \vn{lcavity}, \vn{match},
and \vn{patch} elements are limited to first order.

\end{description}

%----------------------------------------------------------------------------

\index{ab_multipole}\index{beambeam}\index{bend_sol_quad}\index{custom}
\index{drift}\index{ecollimator}\index{elseparator}\index{hkicker}
\index{instrument}\index{kicker}\index{lcavity}\index{marker}
\index{match}\index{monitor}\index{multipole}\index{octupole}
\index{patch}\index{quadrupole}\index{rbend}\index{rcollimator}
\index{rfcavity}\index{sbend}\index{sextupole}\index{solenoid}
\index{sol_quad}\index{taylor}\index{vkicker}\index{wiggler}
\index{element!table of class types}
\begin{table}[pht]
\centering {
\begin{tabular}{lccccccccccc} \toprule
\rule{0pt}{80pt} 
{\em Element Class} &
\begin{sideways}\vn{Adaptive_Boris}\end{sideways} &
\begin{sideways}\vn{Bmad_Standard}\end{sideways} &
\begin{sideways}\vn{Boris}\end{sideways} &
\begin{sideways}\vn{Custom}\end{sideways} &
\begin{sideways}\vn{Linear}\end{sideways} &
\begin{sideways}\vn{MAD}\end{sideways} &
\begin{sideways}\vn{Runge_Kutta}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_Bmad}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_PTC}\end{sideways} &
\begin{sideways}\vn{Symp_Map}\end{sideways} &
\begin{sideways}\vn{Taylor}\end{sideways}
\\ \midrule
%                               AB  BS   B   C   L   M   RK    SLB   SLP   SM     T  
  \vn{ab_multipole}            &   & D &   & X & X &   &     &     &  X  &  X  &  X   \\  
  \vn{beambeam}                &   & D &   & X & X &   &     &     &     &     &      \\  
  \vn{bend_sol_quad}           &   &   &   &   &   &   &     &  D  &     &     &      \\  
  \vn{custom}                  & X &   & X & D & X &   &  X  &     &     &     &      \\  
  \vn{drift}                   & X & D & X & X & X & X &  X  &     &  X  &  X  &  X   \\  
  \vn{ecollimator}             & X & D & X & X & X &   &  X  &     &  X  &  X  &  X   \\  
  \vn{elseparator}             & X & D & X & X & X & X &  X  &     &  X  &  X  &  X   \\  
  \vn{hkicker}                 & X & D & X & X & X &   &  X  &     &  X  &  X  &  X   \\  
  \vn{instrument}              & X & D & X & X & X &   &  X  &     &  X  &  X  &  X   \\  
  \vn{kicker}                  & X & D & X & X & X &   &  X  &     &  X  &  X  &  X   \\  
  \vn{lcavity}                 &   & D &   & X & X &   &     &     &     &     &  *   \\  
  \vn{marker}                  &   & D &   & X & X &   &     &     &  X  &  X  &  X   \\  
  \vn{match}                   &   & D &   &   &   &   &     &     &     &     &  *   \\ 
  \vn{monitor}                 & X & D & X & X & X &   &  X  &     &  X  &  X  &  X   \\  
  \vn{multipole}               &   & D &   & X & X &   &     &     &  X  &  X  &  X   \\  
  \vn{octupole}                & X & D & X & X & X &   &  X  &     &  X  &  X  &  X   \\ 
  \vn{patch}                   &   & D &   & X &   &   &     &     &     &     &  *   \\ 
  \vn{quadrupole}              & X & D & X & X & X & X &  X  &     &  X  &  X  &  X   \\ 
  \vn{rbend}                   &   & D &   & X & X & X &     &     &  X  &  X  &  X   \\ 
  \vn{rcollimator}             & X & D & X & X & X &   &  X  &     &  X  &  X  &  X   \\ 
  \vn{rfcavity}                &   & D &   & X & X & X &     &     &  X  &  X  &  X   \\ 
  \vn{sbend}                   &   & D &   & X & X & X &     &     &  X  &  X  &  X   \\ 
  \vn{sextupole}               & X & D & X & X & X & X &  X  &     &  X  &  X  &  X   \\ 
  \vn{solenoid}                & X & D & X & X & X & X &  X  &     &  X  &  X  &  X   \\ 
  \vn{sol_quad}                & X & D & X & X & X & X &  X  &     &  X  &  X  &  X   \\ 
  \vn{taylor}                  &   & D &   & X & X &   &     &     &     &     &      \\ 
  \vn{vkicker}                 & X & D & X & X & X &   &  X  &     &  X  &  X  &  X   \\ 
  \vn{wiggler} (map type)      & X & D & X & X & X &   &  X  &  X  &  X  &  X  &  X   \\ 
  \vn{wiggler} (periodic type) &   & D &   & X & X &   &X$^a$&X$^a$&X$^a$&X$^a$&X$^a$ \\ \bottomrule
   \multicolumn{12}{l}{$^a$See \sref{s:wiggler.phys} for more details} \\
\end{tabular}
} 
\caption[Table of available {\bf tracking_method}\ switches for a
given element class.]{Table of available {\bf tracking_method}\
switches for a given element class. ``D'' denotes the default
method. ``X'' denotes an available method. ``*'' denotes that the
Taylor map will only be first order. 
}

\label{t:track.methods}
\end{table}

\vfill \break

%----------------------------------------------------------------------------
\section{mat6_calc_method Switches}
\label{s:xfer}
\index{mat6_calc_method|hyperbf}


The \vn{mat6_calc_method} attribute sets how the 6x6 Jacobian transfer
matrix for a given element is computed. A table giving which methods
are available with which element classes is give in
Table~\ref{t:mat6.methods}.

For methods that do not necessarily produce a symplectic matrix the
\vn{symplectify} attribute of an element can be set to \vn{True} to
solve the problem. See \sref{s:symp.method}. 

Symplectic integration is like ordinary integration of a function f(x)
but what is integrated here is a Taylor map. Truncating the map to
0\Th order gives the particle trajectory and truncating to 1\St\
order gives the transfer matrix (Jacobian).  The order at which a
Taylor series is truncated at is set by \vn{taylor_order} (see
\sref{s:param}. Like ordinary integration there are various
formulas that one can use to do symplectic integration. In \bmad\ (or
more precisely Etienne's PTC) you can use one of 3 methods. This is
set by \vn{integrator_order}.  \vn{integrator_order} = n where $n$ is
allowed by PTC to be 2, 4, or 6. With an integration order of $n$ the
error in an integration step scales as $dz^n$ where $dz$ is step
size. The step size $dz$ is set by the length of the element and the
value of \vn{ds_step}. Remember, as in ordinary integration, higher
integration order does not necessarily imply higher accuracy.

\begin{description}

\index{bmad_standard!transfer map method}
\item[\vn{Bmad_Standard}]
Uses formulas for the calculation. The emphasis here is on speed

\index{custom}
\item[\vn{Custom}]
This method will call a routine \vn{make_mat6_custom} which must be
supplied by the programmer implementing the custom transfer matrix
calculation. The default \vn{make_mat6_custom} supplied with the
\bmad\ release will print an error message and stop the program if it
is called which probably indicates a program linking problem.

\index{MAD!Mat6_calc_method!transfer map method}
\item[\vn{MAD}]
This uses the MAD 2nd transfer map.

\index{none}
\item[\vn{None}]
This prevents the transfer matrix from being recomputed.
Using \vn{None} in the input file is generally not a good idea since
it prevents the matrix from being computed in the first place.
Typically \vn{None} is used internally in a program to prevent recomputation.

\index{symp_lie_bmad!transfer map method}
\item[\vn{Symp_Lie_Bmad}]
A Symplectic calculation using a Hamiltonian with Lie operator techniques.
This is similar to \vn{Symp_Lie_PTC} (see below) except this uses a
\bmad\ routine. By bypassing some of the generality inherent in PTC's routines
\vn{Symp_Lie_Bmad} achieves about a factor of 10 improvement in speed over
\vn{Symp_Lie_PTC}. However, \vn{Symp_Lie_Bmad} is
currently only implemented for Wigglers.

\index{symp_lie_ptc!transfer map method}
\item[\vn{Symp_Lie_PTC}]
Symplectic integration using a Hamiltonian and Lie operators.
This uses Etienne's PTC software for the calculation.
This method is symplectic but can be slow.

\index{taylor!transfer map method}
\item[\vn{Taylor}]
This uses a Taylor map generated from Etienne's PTC
package. Generating the map may take time but once you have it it
should be very fast. One possible problem with using a Taylor map is
that you have to worry about the accuracy if you do a calculation at
points that are far from the expansion point about which the map was
made. This method is non-symplectic away from the expansion
point. Whether the Taylor map is generated taking into account the
offset an element has is governed by the \vn{map_with_offsets}
attribute (\sref{s:mapoff}).
Note: Taylor maps for \vn{lcavity}, \vn{match},
and \vn{patch} elements are limited to first order.

\index{tracking!transfer map method}
\item[\vn{Tracking}]
This uses the tracking method set by \vn{tracking_method} to track 6
particles around the central orbit. This method is susceptible to inaccuracies
caused by nonlinearities. Furthermore this method
is almost surely slow. While non--symplectic, the advantage of this method
is that it is directly related to any tracking results.

\end{description}

\index{ab_multipole}\index{beambeam}\index{bend_sol_quad}\index{custom}
\index{drift}\index{ecollimator}\index{elseparator}\index{hkicker}
\index{instrument}\index{kicker}\index{lcavity}\index{marker}
\index{match}\index{monitor}\index{multipole}\index{octupole}
\index{patch}\index{quadrupole}\index{rbend}\index{rcollimator}
\index{rfcavity}\index{sbend}\index{sextupole}\index{solenoid}
\index{sol_quad}\index{taylor}\index{vkicker}\index{wiggler}
\begin{table}[pth]
\centering {
\begin{tabular}{lcccccccc} \toprule
\rule{0pt}{80pt} &
\begin{sideways}\vn{Bmad_Standard}\end{sideways} &
\begin{sideways}\vn{Custom}\end{sideways} &
\begin{sideways}\vn{MAD}\end{sideways} &
\begin{sideways}\vn{None}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_Bmad}\end{sideways} &
\begin{sideways}\vn{Symp_Lie_PTC}\end{sideways} &
\begin{sideways}\vn{Taylor}\end{sideways} &
\begin{sideways}\vn{Tracking}\end{sideways}
\\ \midrule
%                               BS   C   M   N   SLB   SLP   Tlr  Trk 
  \vn{ab_multipole}            & D & X &   & X &     &  X  &  X  &   \\  
  \vn{beambeam}                & D & X &   & X &     &     &     & X \\  
  \vn{bend_sol_quad}           &   &   &   & X &  D  &     &     & X \\  
  \vn{custom}                  &   & D &   & X &     &     &     & X \\  
  \vn{drift}                   & D & X & X & X &     &  X  &  X  & X \\  
  \vn{ecollimator}             & D & X &   & X &     &  X  &  X  & X \\  
  \vn{elseparator}             & D & X & X & X &     &  X  &  X  & X \\  
  \vn{hkicker}                 & D & X &   & X &     &  X  &  X  & X \\  
  \vn{instrument}              & D & X &   & X &     &  X  &  X  & X \\  
  \vn{kicker}                  & D & X &   & X &     &  X  &  X  & X \\  
  \vn{lcavity}                 & D & X &   & X &     &     &     & X \\  
  \vn{marker}                  & D & X &   & X &     &  X  &  X  & X \\  
  \vn{match}                   & D &   &   & X &     &     &     &   \\  
  \vn{monitor}                 & D & X &   & X &     &  X  &  X  & X \\  
  \vn{multipole}               & D & X &   & X &     &  X  &  X  &   \\  
  \vn{octupole}                & D & X &   & X &     &  X  &  X  & X \\ 
  \vn{patch}                   & D & X &   & X &     &     &     &   \\ 
  \vn{quadrupole}              & D & X & X & X &     &  X  &  X  & X \\ 
  \vn{rbend}                   & D & X & X & X &     &  X  &  X  & X \\ 
  \vn{rcollimator}             & D & X &   & X &     &  X  &  X  & X \\ 
  \vn{rfcavity}                & D & X & X & X &     &  X  &  X  & X \\ 
  \vn{sbend}                   & D & X & X & X &     &  X  &  X  & X \\ 
  \vn{sextupole}               & D & X & X & X &     &  X  &  X  & X \\ 
  \vn{solenoid}                & D & X & X & X &     &  X  &  X  & X \\ 
  \vn{sol_quad}                & D & X & X & X &     &  X  &  X  & X \\ 
  \vn{taylor}                  & D & X &   & X &     &     &     &   \\ 
  \vn{vkicker}                 & D & X &   & X &     &  X  &  X  & X \\ 
  \vn{wiggler} (map type)      & D & X &   & X &  X  &  X  &  X  & X \\ 
  \vn{wiggler} (periodic type) & D & X &   & X &X$^a$&X$^a$&X$^a$& X \\ \bottomrule
  \multicolumn{9}{l}{$^a$See \sref{s:wiggler.phys} for more details} \\
\end{tabular}
}

\caption[Table of available \vn{mat6_calc_method}\ switches for a
given element class.]{Table of available \vn{mat6_calc_method}\
switches for a given element class. ``D'' denotes the default
method. ``X'' denotes an available method.}

\label{t:mat6.methods}
\end{table}

\vfill \break

%-----------------------------------------------------------------
\section{Integration Methods}
\label{s:integ}
\index{integration methods}

\index{symp_lie_bmad!and Taylor maps}
\index{symp_lie_ptc!and Taylor maps}
\index{taylor!and Taylor maps}
Integration methods are split into two classes: Those that involve
Taylor maps and those that simply track a particle's position.  The
Taylor map methods are
\begin{example}
  symp_lie_bmad
  symp_lie_ptc
  taylor
\end{example}
See section \sref{s:taylor.phys} for more information on Taylor maps
and symplectic integration.  The methods that do not involve Taylor
maps are
\index{adaptive_boris!and Taylor maps}
\index{boris!and Taylor maps}
\index{runge_kutta!and Taylor maps}
\begin{example}
  adaptive_boris
  boris
  runge_kutta
\end{example}

\index{ds_step}\index{num_steps}\index{integrator_order}\index{rel_tol}
\index{abs_tol}\index{field_calc}
there are a number of attributes that can affect the calculation. They are
\begin{example}
  ds_step = <Real>              ! Integration step length
  num_steps = <Integer>         ! Number of integration steps.
  integrator_order = <Integer>  ! Integrator order
  rel_tol = <Real>              ! Relative tolerance
  abs_tol = <Real>              ! Absolute tolerance
  field_calc = Switch           ! How the field is calculated
\end{example}

Example:
\begin{example}
  q1: quadrupole, l = 0.6, tracking_method = bmad_standard, &
        mat6_calc_method = symp_lie_ptc, ds_step = 0.2, field_calc = custom
\end{example}

\index{ds_step}
\index{num_steps}
\index{taylor}\index{symp_lie_ptc}\index{symp_lie_bmad}\index{runge_kutta}\index{boris}
One way to create a transfer map through an element is to divide the
element up into slices and then to propagate the transfer map slice by
slice.  There are several ways to do this integration. The \vn{boris}
and \vn{runge_kutta} methods integrate the equations of motion to
give the 0\Th order Taylor map which just represents a particle's
orbit.  Symplectic integration\index{symplectic!integration} using Lie
algebraic techniques, on the other hand, can generate Taylor maps to
any order.  The \vn{ds_step} attribute determines the slice thickness.
Alternatively, \vn{num_steps} attribute can be used in place of
\vn{ds_step} to specify the number of slices.
This is applicable to \vn{Boris}, \vn{symp_lie_bmad}, and
\vn{symp_lie_ptc} integration.

\index{integrator_order}
\index{ds_step}\index{symp_lie_bmad}
\vn{integrator_order} is the order of the integration formula for 
\vn{Symp_Lie_PTC}. Possible values are
\begin{example}
  integrator_order = 2 (default), 4, or 6
\end{example}
Essentially, an integration order of $n$ means that the error in an
integration step scales as $dz^{n+1}$ where $dz$ is the slice
thickness.  For a given number of steps a higher order will give more
accurate results but a higher order integrator will take more time per
step. It turns out that for wigglers, after adjusting \vn{ds_step}
for a given accuracy, the order 2 integrator is the fastest. This is
not surprising given the highly nonlinear nature of a wiggler. Note
that \vn{symp_lie_bmad} always uses an order 2 integrator
independent of the setting of \vn{integrator_order}.

\index{ds_step}
\index{rel_tol}
\index{abs_tol}\index{runge_kutta}\index{adaptive_boris}
\vn{adaptive_boris} and \vn{runge_kutta} use adaptive step
control independent of \vn{ds_step}. These methods use the \vn{rel_tol} and
\vn{abs_tol} attributes to try to keep the estimated error of the integration
such that
\begin{example}
  error < abs_tol + |orbit| * rel_tol
\end{example}
lowering the error bounds makes for greater accuracy (as long as round-off 
doesn't hurt) but for slower tracking. 

\index{field_calc}\index{runge_kutta}\index{adaptive_boris}\index{boris}
The \vn{boris}, \vn{adaptive_boris}, and \vn{runge_kutta} tracking all use
as input the electric and magnetic fields of an element. How the EM fields
are calculated is determined by the \vn{field_calc} attribute for an element.
Possible values for \vn{field_calc} are:
\begin{example}
  Bmad_Standard     ! This is the default
  Custom
\end{example}
\index{custom}
\vn{Custom} means that the field calculations are done outside of the
\bmad software. A program doing \vn{Custom} field calculations will
need the appropriate custom routine. See \sref{s:custom.field} for more
details.

\index{boris}\index{adaptive_boris}
Both \vn{boris} and \vn{adaptive_boris} tracking do not
assume that a particle is relativistic so these tracking methods can be
used with non--relativistic particles. The phase space coordinates
used in these tracking methods are not the usual \bmad coordinates Rather
what is used is
\begin{example}
    (x, p_x/p_0, y, p_y/p_0, s-ct, dE/(cP_0))
\end{example}
At high energy $s-ct = z$ which is the distance of the particle from
the reference particle and $c \, P_0 = v \, E_0/C = E_0$ so that
$dE/cP_0 = dE/E$ giving the standard \bmad coordinates.

%-----------------------------------------------------------------
\section{Symplectify Attribute}
\label{s:symp}
\index{symplectify|hyperbf}

The \vn{symplectify} attribute
\begin{example}
  symplectify = <Logical>
\end{example}
is used to make the transfer matrix for an element symplectic. The
linear transport matrix may be non--symplectic for a number of
reasons.  For example, the linear matrix that comes from expanding a
Taylor Map around any point that is not the origin of the map is
generally not symplectic. The transfer matrix for an element can be
symplectified by setting the \vn{symplectify} attribute to True. See
section \ref{s:symp.method} for details on how a matrix is
symplectified. The default value of \vn{symplectify}, if it is not
present, is \vn{False}. If it is present without a value then it
defaults to true. Examples:
\begin{example}
  s1: sextupole, l = 0.34                       ! symplectify = False
  s1: sextupole, symplectify = True, l = 0.34   ! symplectify = True
  s1: sextupole, symplectify, l = 0.34          ! symplectify = True
\end{example}

%-----------------------------------------------------------------
\section{Map_with_offsets Attribute}
\label{s:mapoff}
\index{map_with_offsets|hyperbf}

The \vn{map_with_offsets} attribute sets whether the Taylor map
generated for an element includes the affect due to the elements
(mis)orientation in space. That is, the affect of any pitches, offsets
or tilt (\sref{s:offset}). The default is \vn{True} which means that
the Taylor map will include such effects. 

How \vn{map_with_offsets} is set will not affect the results of
tracking or the Jacobian matrix calculation. What is affected is the
speed of the calculations. With \vn{map_with_offsets} set to \vn{True}
the Taylor map will have to be recalculated each time an element is
reoriented in space. On the other hand, with \vn{map_with_offsets} set
to \vn{False} each tracking and Jacobian matrix calculation will
include the extra computation involving the effect of the
orientation. Thus if an element's orientation is fixed it is faster to
set \vn{map_with_offsets} to \vn{True} and if the orientation is
varying it is faster to set \vn{map_with_offsets} to \vn{False}.

If the global parameter \vn{bmad_com%conserve_taylor_maps}
(\sref{s:bmad.params}) is set to True (the default), then, if an
element is offset within a program, and if \vn{map_with_offset} is set
to True for that element, \bmad will toggle \vn{map_with_offset} to
False to conserve the map.
