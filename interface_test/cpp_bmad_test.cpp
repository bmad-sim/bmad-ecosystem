
//+
// C++ classes definitions for Bmad / C++ structure interface.
//
// This file is generated as part of the Bmad/C++ interface code generation.
// The code generation files can be found in cpp_bmad_interface.
//
// DO NOT EDIT THIS FILE DIRECTLY! 
//-

#include <stdio.h>
#include <iostream>
#include "cpp_bmad_classes.h"

using namespace std;

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_spline (CPP_spline&, bool&);

void set_CPP_spline_test_pattern (CPP_spline& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.x0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.y0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.x1 = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.coef.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.coef[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_spline (Opaque_spline_class* F, bool& c_ok) {

  CPP_spline C, C2;

  c_ok = true;

  spline_to_c (F, C);
  set_CPP_spline_test_pattern (C2, 1);

  if (C == C2) {
    cout << " spline: C side convert F->C: Good" << endl;
  } else {
    cout << " spline: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_spline_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_spline (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_spline_test_pattern (C, 3);
  if (C == C2) {
    cout << " spline: F side convert F->C: Good" << endl;
  } else {
    cout << " spline: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_spline_test_pattern (C2, 4);
  spline_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_spin_polar (CPP_spin_polar&, bool&);

void set_CPP_spin_polar_test_pattern (CPP_spin_polar& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.polarization = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.theta = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.xi = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_spin_polar (Opaque_spin_polar_class* F, bool& c_ok) {

  CPP_spin_polar C, C2;

  c_ok = true;

  spin_polar_to_c (F, C);
  set_CPP_spin_polar_test_pattern (C2, 1);

  if (C == C2) {
    cout << " spin_polar: C side convert F->C: Good" << endl;
  } else {
    cout << " spin_polar: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_spin_polar_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_spin_polar (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_spin_polar_test_pattern (C, 3);
  if (C == C2) {
    cout << " spin_polar: F side convert F->C: Good" << endl;
  } else {
    cout << " spin_polar: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_spin_polar_test_pattern (C2, 4);
  spin_polar_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_surface_orientation (CPP_surface_orientation&, bool&);

void set_CPP_surface_orientation_test_pattern (CPP_surface_orientation& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.dz_dx = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.dz_dy = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.dz_dx_rms = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.dz_dy_rms = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.dz2_dxdy = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_surface_orientation (Opaque_surface_orientation_class* F, bool& c_ok) {

  CPP_surface_orientation C, C2;

  c_ok = true;

  surface_orientation_to_c (F, C);
  set_CPP_surface_orientation_test_pattern (C2, 1);

  if (C == C2) {
    cout << " surface_orientation: C side convert F->C: Good" << endl;
  } else {
    cout << " surface_orientation: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_orientation_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_surface_orientation (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_surface_orientation_test_pattern (C, 3);
  if (C == C2) {
    cout << " surface_orientation: F side convert F->C: Good" << endl;
  } else {
    cout << " surface_orientation: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_orientation_test_pattern (C2, 4);
  surface_orientation_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_ac_kicker_time (CPP_ac_kicker_time&, bool&);

void set_CPP_ac_kicker_time_test_pattern (CPP_ac_kicker_time& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.amp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.time = rhs;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_spline_test_pattern(C.spline, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_ac_kicker_time (Opaque_ac_kicker_time_class* F, bool& c_ok) {

  CPP_ac_kicker_time C, C2;

  c_ok = true;

  ac_kicker_time_to_c (F, C);
  set_CPP_ac_kicker_time_test_pattern (C2, 1);

  if (C == C2) {
    cout << " ac_kicker_time: C side convert F->C: Good" << endl;
  } else {
    cout << " ac_kicker_time: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ac_kicker_time_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_ac_kicker_time (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_ac_kicker_time_test_pattern (C, 3);
  if (C == C2) {
    cout << " ac_kicker_time: F side convert F->C: Good" << endl;
  } else {
    cout << " ac_kicker_time: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ac_kicker_time_test_pattern (C2, 4);
  ac_kicker_time_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_ac_kicker_freq (CPP_ac_kicker_freq&, bool&);

void set_CPP_ac_kicker_freq_test_pattern (CPP_ac_kicker_freq& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.f = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.amp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.phi = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.rf_clock_harmonic = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_ac_kicker_freq (Opaque_ac_kicker_freq_class* F, bool& c_ok) {

  CPP_ac_kicker_freq C, C2;

  c_ok = true;

  ac_kicker_freq_to_c (F, C);
  set_CPP_ac_kicker_freq_test_pattern (C2, 1);

  if (C == C2) {
    cout << " ac_kicker_freq: C side convert F->C: Good" << endl;
  } else {
    cout << " ac_kicker_freq: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ac_kicker_freq_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_ac_kicker_freq (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_ac_kicker_freq_test_pattern (C, 3);
  if (C == C2) {
    cout << " ac_kicker_freq: F side convert F->C: Good" << endl;
  } else {
    cout << " ac_kicker_freq: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ac_kicker_freq_test_pattern (C2, 4);
  ac_kicker_freq_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_ac_kicker (CPP_ac_kicker&, bool&);

void set_CPP_ac_kicker_test_pattern (CPP_ac_kicker& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.amp_vs_time.resize(0);
  else {
    C.amp_vs_time.resize(3);
    for (unsigned int i = 0; i < C.amp_vs_time.size(); i++)  {set_CPP_ac_kicker_time_test_pattern(C.amp_vs_time[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.frequency.resize(0);
  else {
    C.frequency.resize(3);
    for (unsigned int i = 0; i < C.frequency.size(); i++)  {set_CPP_ac_kicker_freq_test_pattern(C.frequency[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_ac_kicker (Opaque_ac_kicker_class* F, bool& c_ok) {

  CPP_ac_kicker C, C2;

  c_ok = true;

  ac_kicker_to_c (F, C);
  set_CPP_ac_kicker_test_pattern (C2, 1);

  if (C == C2) {
    cout << " ac_kicker: C side convert F->C: Good" << endl;
  } else {
    cout << " ac_kicker: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ac_kicker_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_ac_kicker (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_ac_kicker_test_pattern (C, 3);
  if (C == C2) {
    cout << " ac_kicker: F side convert F->C: Good" << endl;
  } else {
    cout << " ac_kicker: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ac_kicker_test_pattern (C2, 4);
  ac_kicker_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_interval1_coef (CPP_interval1_coef&, bool&);

void set_CPP_interval1_coef_test_pattern (CPP_interval1_coef& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.c0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.c1 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.n_exp = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_interval1_coef (Opaque_interval1_coef_class* F, bool& c_ok) {

  CPP_interval1_coef C, C2;

  c_ok = true;

  interval1_coef_to_c (F, C);
  set_CPP_interval1_coef_test_pattern (C2, 1);

  if (C == C2) {
    cout << " interval1_coef: C side convert F->C: Good" << endl;
  } else {
    cout << " interval1_coef: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_interval1_coef_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_interval1_coef (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_interval1_coef_test_pattern (C, 3);
  if (C == C2) {
    cout << " interval1_coef: F side convert F->C: Good" << endl;
  } else {
    cout << " interval1_coef: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_interval1_coef_test_pattern (C2, 4);
  interval1_coef_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_reflect_table (CPP_photon_reflect_table&, bool&);

void set_CPP_photon_reflect_table_test_pattern (CPP_photon_reflect_table& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, ALLOC]
  if (ix_patt < 3) 
    C.angle.resize(0);
  else {
    C.angle.resize(3);
    for (unsigned int i = 0; i < C.angle.size(); i++)
      {int rhs = 101 + i + 1 + offset; C.angle[i] = rhs;}  }

  // c_side.test_pat[real, 1, ALLOC]
  if (ix_patt < 3) 
    C.energy.resize(0);
  else {
    C.energy.resize(3);
    for (unsigned int i = 0; i < C.energy.size(); i++)
      {int rhs = 101 + i + 3 + offset; C.energy[i] = rhs;}  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.int1.resize(0);
  else {
    C.int1.resize(3);
    for (unsigned int i = 0; i < C.int1.size(); i++)  {set_CPP_interval1_coef_test_pattern(C.int1[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 2, ALLOC]
  if (ix_patt < 3) 
    C.p_reflect.resize(0);
  else {
    C.p_reflect.resize(3);
    for (unsigned int i = 0; i < C.p_reflect.size(); i++)
      C.p_reflect[i].resize(2);
    for (unsigned int i = 0; i < C.p_reflect.size(); i++)  for (unsigned int j = 0; j < C.p_reflect[0].size(); j++) 
      {int rhs = 101 + i + 10*(j+1) + 7 + offset; C.p_reflect[i][j] = rhs;}  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.max_energy = rhs;

  // c_side.test_pat[real, 1, ALLOC]
  if (ix_patt < 3) 
    C.p_reflect_scratch.resize(0);
  else {
    C.p_reflect_scratch.resize(3);
    for (unsigned int i = 0; i < C.p_reflect_scratch.size(); i++)
      {int rhs = 101 + i + 11 + offset; C.p_reflect_scratch[i] = rhs;}  }


}

//--------------------------------------------------------------

extern "C" void test_c_photon_reflect_table (Opaque_photon_reflect_table_class* F, bool& c_ok) {

  CPP_photon_reflect_table C, C2;

  c_ok = true;

  photon_reflect_table_to_c (F, C);
  set_CPP_photon_reflect_table_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_reflect_table: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_reflect_table: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_reflect_table_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_reflect_table (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_reflect_table_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_reflect_table: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_reflect_table: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_reflect_table_test_pattern (C2, 4);
  photon_reflect_table_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_reflect_surface (CPP_photon_reflect_surface&, bool&);

void set_CPP_photon_reflect_surface_test_pattern (CPP_photon_reflect_surface& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.description.resize(80);
  for (unsigned int i = 0; i < C.description.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.description[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.reflectivity_file.resize(200);
  for (unsigned int i = 0; i < C.reflectivity_file.size(); i++)
    {int rhs = 101 + i + 3 + offset; C.reflectivity_file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.table.resize(0);
  else {
    C.table.resize(3);
    for (unsigned int i = 0; i < C.table.size(); i++)  {set_CPP_photon_reflect_table_test_pattern(C.table[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.surface_roughness_rms = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.roughness_correlation_len = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 8 + offset; C.initialized = (rhs % 2 == 0);

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.ix_surface = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_photon_reflect_surface (Opaque_photon_reflect_surface_class* F, bool& c_ok) {

  CPP_photon_reflect_surface C, C2;

  c_ok = true;

  photon_reflect_surface_to_c (F, C);
  set_CPP_photon_reflect_surface_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_reflect_surface: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_reflect_surface: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_reflect_surface_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_reflect_surface (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_reflect_surface_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_reflect_surface: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_reflect_surface: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_reflect_surface_test_pattern (C2, 4);
  photon_reflect_surface_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_coord (CPP_coord&, bool&);

void set_CPP_coord_test_pattern (CPP_coord& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.vec.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.vec[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.s = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.t = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.spin.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.spin[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.field.size(); i++)
    {int rhs = 101 + i + 5 + offset; C.field[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.phase.size(); i++)
    {int rhs = 101 + i + 6 + offset; C.phase[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.charge = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.dt_ref = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.r = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.p0c = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 11 + offset; C.e_potential = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 12 + offset; C.beta = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 13 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 14 + offset; C.ix_branch = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 15 + offset; C.ix_user = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 16 + offset; C.state = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 17 + offset; C.direction = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 18 + offset; C.species = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 19 + offset; C.location = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_coord (Opaque_coord_class* F, bool& c_ok) {

  CPP_coord C, C2;

  c_ok = true;

  coord_to_c (F, C);
  set_CPP_coord_test_pattern (C2, 1);

  if (C == C2) {
    cout << " coord: C side convert F->C: Good" << endl;
  } else {
    cout << " coord: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_coord_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_coord (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_coord_test_pattern (C, 3);
  if (C == C2) {
    cout << " coord: F side convert F->C: Good" << endl;
  } else {
    cout << " coord: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_coord_test_pattern (C2, 4);
  coord_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_coord_array (CPP_coord_array&, bool&);

void set_CPP_coord_array_test_pattern (CPP_coord_array& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.orbit.resize(0);
  else {
    C.orbit.resize(3);
    for (unsigned int i = 0; i < C.orbit.size(); i++)  {set_CPP_coord_test_pattern(C.orbit[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_coord_array (Opaque_coord_array_class* F, bool& c_ok) {

  CPP_coord_array C, C2;

  c_ok = true;

  coord_array_to_c (F, C);
  set_CPP_coord_array_test_pattern (C2, 1);

  if (C == C2) {
    cout << " coord_array: C side convert F->C: Good" << endl;
  } else {
    cout << " coord_array: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_coord_array_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_coord_array (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_coord_array_test_pattern (C, 3);
  if (C == C2) {
    cout << " coord_array: F side convert F->C: Good" << endl;
  } else {
    cout << " coord_array: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_coord_array_test_pattern (C2, 4);
  coord_array_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_bpm_phase_coupling (CPP_bpm_phase_coupling&, bool&);

void set_CPP_bpm_phase_coupling_test_pattern (CPP_bpm_phase_coupling& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.k_22a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.k_12a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.k_11b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.k_12b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.cbar22_a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.cbar12_a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.cbar11_b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.cbar12_b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.phi_a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.phi_b = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_bpm_phase_coupling (Opaque_bpm_phase_coupling_class* F, bool& c_ok) {

  CPP_bpm_phase_coupling C, C2;

  c_ok = true;

  bpm_phase_coupling_to_c (F, C);
  set_CPP_bpm_phase_coupling_test_pattern (C2, 1);

  if (C == C2) {
    cout << " bpm_phase_coupling: C side convert F->C: Good" << endl;
  } else {
    cout << " bpm_phase_coupling: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bpm_phase_coupling_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_bpm_phase_coupling (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_bpm_phase_coupling_test_pattern (C, 3);
  if (C == C2) {
    cout << " bpm_phase_coupling: F side convert F->C: Good" << endl;
  } else {
    cout << " bpm_phase_coupling: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bpm_phase_coupling_test_pattern (C2, 4);
  bpm_phase_coupling_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_expression_atom (CPP_expression_atom&, bool&);

void set_CPP_expression_atom_test_pattern (CPP_expression_atom& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.type = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.value = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_expression_atom (Opaque_expression_atom_class* F, bool& c_ok) {

  CPP_expression_atom C, C2;

  c_ok = true;

  expression_atom_to_c (F, C);
  set_CPP_expression_atom_test_pattern (C2, 1);

  if (C == C2) {
    cout << " expression_atom: C side convert F->C: Good" << endl;
  } else {
    cout << " expression_atom: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_expression_atom_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_expression_atom (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_expression_atom_test_pattern (C, 3);
  if (C == C2) {
    cout << " expression_atom: F side convert F->C: Good" << endl;
  } else {
    cout << " expression_atom: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_expression_atom_test_pattern (C2, 4);
  expression_atom_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wake_sr_mode (CPP_wake_sr_mode&, bool&);

void set_CPP_wake_sr_mode_test_pattern (CPP_wake_sr_mode& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.amp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.damp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.k = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.b_sin = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.b_cos = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.a_sin = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.a_cos = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.polarization = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 10 + offset; C.position_dependence = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_wake_sr_mode (Opaque_wake_sr_mode_class* F, bool& c_ok) {

  CPP_wake_sr_mode C, C2;

  c_ok = true;

  wake_sr_mode_to_c (F, C);
  set_CPP_wake_sr_mode_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wake_sr_mode: C side convert F->C: Good" << endl;
  } else {
    cout << " wake_sr_mode: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_sr_mode_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wake_sr_mode (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wake_sr_mode_test_pattern (C, 3);
  if (C == C2) {
    cout << " wake_sr_mode: F side convert F->C: Good" << endl;
  } else {
    cout << " wake_sr_mode: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_sr_mode_test_pattern (C2, 4);
  wake_sr_mode_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wake_sr (CPP_wake_sr&, bool&);

void set_CPP_wake_sr_test_pattern (CPP_wake_sr& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.long_wake.resize(0);
  else {
    C.long_wake.resize(3);
    for (unsigned int i = 0; i < C.long_wake.size(); i++)  {set_CPP_wake_sr_mode_test_pattern(C.long_wake[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.trans_wake.resize(0);
  else {
    C.trans_wake.resize(3);
    for (unsigned int i = 0; i < C.trans_wake.size(); i++)  {set_CPP_wake_sr_mode_test_pattern(C.trans_wake[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.z_ref_long = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.z_ref_trans = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.z_max = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.amp_scale = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.z_scale = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 11 + offset; C.scale_with_length = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_wake_sr (Opaque_wake_sr_class* F, bool& c_ok) {

  CPP_wake_sr C, C2;

  c_ok = true;

  wake_sr_to_c (F, C);
  set_CPP_wake_sr_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wake_sr: C side convert F->C: Good" << endl;
  } else {
    cout << " wake_sr: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_sr_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wake_sr (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wake_sr_test_pattern (C, 3);
  if (C == C2) {
    cout << " wake_sr: F side convert F->C: Good" << endl;
  } else {
    cout << " wake_sr: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_sr_test_pattern (C2, 4);
  wake_sr_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wake_lr_mode (CPP_wake_lr_mode&, bool&);

void set_CPP_wake_lr_mode_test_pattern (CPP_wake_lr_mode& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.freq = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.freq_in = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.r_over_q = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.q = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.damp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.angle = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.b_sin = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.b_cos = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.a_sin = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 11 + offset; C.a_cos = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 12 + offset; C.m = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 13 + offset; C.polarized = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_wake_lr_mode (Opaque_wake_lr_mode_class* F, bool& c_ok) {

  CPP_wake_lr_mode C, C2;

  c_ok = true;

  wake_lr_mode_to_c (F, C);
  set_CPP_wake_lr_mode_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wake_lr_mode: C side convert F->C: Good" << endl;
  } else {
    cout << " wake_lr_mode: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_lr_mode_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wake_lr_mode (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wake_lr_mode_test_pattern (C, 3);
  if (C == C2) {
    cout << " wake_lr_mode: F side convert F->C: Good" << endl;
  } else {
    cout << " wake_lr_mode: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_lr_mode_test_pattern (C2, 4);
  wake_lr_mode_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wake_lr (CPP_wake_lr&, bool&);

void set_CPP_wake_lr_test_pattern (CPP_wake_lr& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.mode.resize(0);
  else {
    C.mode.resize(3);
    for (unsigned int i = 0; i < C.mode.size(); i++)  {set_CPP_wake_lr_mode_test_pattern(C.mode[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.t_ref = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.freq_spread = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.amp_scale = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.time_scale = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 8 + offset; C.self_wake_on = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_wake_lr (Opaque_wake_lr_class* F, bool& c_ok) {

  CPP_wake_lr C, C2;

  c_ok = true;

  wake_lr_to_c (F, C);
  set_CPP_wake_lr_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wake_lr: C side convert F->C: Good" << endl;
  } else {
    cout << " wake_lr: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_lr_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wake_lr (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wake_lr_test_pattern (C, 3);
  if (C == C2) {
    cout << " wake_lr: F side convert F->C: Good" << endl;
  } else {
    cout << " wake_lr: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_lr_test_pattern (C2, 4);
  wake_lr_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_lat_ele_loc (CPP_lat_ele_loc&, bool&);

void set_CPP_lat_ele_loc_test_pattern (CPP_lat_ele_loc& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.ix_branch = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_lat_ele_loc (Opaque_lat_ele_loc_class* F, bool& c_ok) {

  CPP_lat_ele_loc C, C2;

  c_ok = true;

  lat_ele_loc_to_c (F, C);
  set_CPP_lat_ele_loc_test_pattern (C2, 1);

  if (C == C2) {
    cout << " lat_ele_loc: C side convert F->C: Good" << endl;
  } else {
    cout << " lat_ele_loc: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_ele_loc_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_lat_ele_loc (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_lat_ele_loc_test_pattern (C, 3);
  if (C == C2) {
    cout << " lat_ele_loc: F side convert F->C: Good" << endl;
  } else {
    cout << " lat_ele_loc: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_ele_loc_test_pattern (C2, 4);
  lat_ele_loc_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wake (CPP_wake&, bool&);

void set_CPP_wake_test_pattern (CPP_wake& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_wake_sr_test_pattern(C.sr, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_wake_lr_test_pattern(C.lr, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_wake (Opaque_wake_class* F, bool& c_ok) {

  CPP_wake C, C2;

  c_ok = true;

  wake_to_c (F, C);
  set_CPP_wake_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wake: C side convert F->C: Good" << endl;
  } else {
    cout << " wake: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wake (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wake_test_pattern (C, 3);
  if (C == C2) {
    cout << " wake: F side convert F->C: Good" << endl;
  } else {
    cout << " wake: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_test_pattern (C2, 4);
  wake_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_taylor_term (CPP_taylor_term&, bool&);

void set_CPP_taylor_term_test_pattern (CPP_taylor_term& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.coef = rhs;

  // c_side.test_pat[integer, 1, NOT]
  for (unsigned int i = 0; i < C.expn.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.expn[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_taylor_term (Opaque_taylor_term_class* F, bool& c_ok) {

  CPP_taylor_term C, C2;

  c_ok = true;

  taylor_term_to_c (F, C);
  set_CPP_taylor_term_test_pattern (C2, 1);

  if (C == C2) {
    cout << " taylor_term: C side convert F->C: Good" << endl;
  } else {
    cout << " taylor_term: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_taylor_term_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_taylor_term (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_taylor_term_test_pattern (C, 3);
  if (C == C2) {
    cout << " taylor_term: F side convert F->C: Good" << endl;
  } else {
    cout << " taylor_term: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_taylor_term_test_pattern (C2, 4);
  taylor_term_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_taylor (CPP_taylor&, bool&);

void set_CPP_taylor_test_pattern (CPP_taylor& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.ref = rhs;

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.term.resize(0);
  else {
    C.term.resize(3);
    for (unsigned int i = 0; i < C.term.size(); i++)  {set_CPP_taylor_term_test_pattern(C.term[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_taylor (Opaque_taylor_class* F, bool& c_ok) {

  CPP_taylor C, C2;

  c_ok = true;

  taylor_to_c (F, C);
  set_CPP_taylor_test_pattern (C2, 1);

  if (C == C2) {
    cout << " taylor: C side convert F->C: Good" << endl;
  } else {
    cout << " taylor: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_taylor_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_taylor (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_taylor_test_pattern (C, 3);
  if (C == C2) {
    cout << " taylor: F side convert F->C: Good" << endl;
  } else {
    cout << " taylor: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_taylor_test_pattern (C2, 4);
  taylor_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_taylor_term (CPP_em_taylor_term&, bool&);

void set_CPP_em_taylor_term_test_pattern (CPP_em_taylor_term& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.coef = rhs;

  // c_side.test_pat[integer, 1, NOT]
  for (unsigned int i = 0; i < C.expn.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.expn[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_em_taylor_term (Opaque_em_taylor_term_class* F, bool& c_ok) {

  CPP_em_taylor_term C, C2;

  c_ok = true;

  em_taylor_term_to_c (F, C);
  set_CPP_em_taylor_term_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_taylor_term: C side convert F->C: Good" << endl;
  } else {
    cout << " em_taylor_term: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_taylor_term_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_taylor_term (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_taylor_term_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_taylor_term: F side convert F->C: Good" << endl;
  } else {
    cout << " em_taylor_term: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_taylor_term_test_pattern (C2, 4);
  em_taylor_term_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_taylor (CPP_em_taylor&, bool&);

void set_CPP_em_taylor_test_pattern (CPP_em_taylor& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.ref = rhs;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.term.resize(0);
  else {
    C.term.resize(3);
    for (unsigned int i = 0; i < C.term.size(); i++)  {set_CPP_em_taylor_term_test_pattern(C.term[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_em_taylor (Opaque_em_taylor_class* F, bool& c_ok) {

  CPP_em_taylor C, C2;

  c_ok = true;

  em_taylor_to_c (F, C);
  set_CPP_em_taylor_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_taylor: C side convert F->C: Good" << endl;
  } else {
    cout << " em_taylor: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_taylor_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_taylor (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_taylor_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_taylor: F side convert F->C: Good" << endl;
  } else {
    cout << " em_taylor: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_taylor_test_pattern (C2, 4);
  em_taylor_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_cartesian_map_term1 (CPP_cartesian_map_term1&, bool&);

void set_CPP_cartesian_map_term1_test_pattern (CPP_cartesian_map_term1& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.coef = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.kx = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.ky = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.kz = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.x0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.y0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.phi_z = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.family = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.form = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_cartesian_map_term1 (Opaque_cartesian_map_term1_class* F, bool& c_ok) {

  CPP_cartesian_map_term1 C, C2;

  c_ok = true;

  cartesian_map_term1_to_c (F, C);
  set_CPP_cartesian_map_term1_test_pattern (C2, 1);

  if (C == C2) {
    cout << " cartesian_map_term1: C side convert F->C: Good" << endl;
  } else {
    cout << " cartesian_map_term1: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cartesian_map_term1_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_cartesian_map_term1 (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_cartesian_map_term1_test_pattern (C, 3);
  if (C == C2) {
    cout << " cartesian_map_term1: F side convert F->C: Good" << endl;
  } else {
    cout << " cartesian_map_term1: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cartesian_map_term1_test_pattern (C2, 4);
  cartesian_map_term1_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_cartesian_map_term (CPP_cartesian_map_term&, bool&);

void set_CPP_cartesian_map_term_test_pattern (CPP_cartesian_map_term& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_link = rhs;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.term.resize(0);
  else {
    C.term.resize(3);
    for (unsigned int i = 0; i < C.term.size(); i++)  {set_CPP_cartesian_map_term1_test_pattern(C.term[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_cartesian_map_term (Opaque_cartesian_map_term_class* F, bool& c_ok) {

  CPP_cartesian_map_term C, C2;

  c_ok = true;

  cartesian_map_term_to_c (F, C);
  set_CPP_cartesian_map_term_test_pattern (C2, 1);

  if (C == C2) {
    cout << " cartesian_map_term: C side convert F->C: Good" << endl;
  } else {
    cout << " cartesian_map_term: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cartesian_map_term_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_cartesian_map_term (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_cartesian_map_term_test_pattern (C, 3);
  if (C == C2) {
    cout << " cartesian_map_term: F side convert F->C: Good" << endl;
  } else {
    cout << " cartesian_map_term: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cartesian_map_term_test_pattern (C2, 4);
  cartesian_map_term_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_cartesian_map (CPP_cartesian_map&, bool&);

void set_CPP_cartesian_map_test_pattern (CPP_cartesian_map& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.field_scale = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r0.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.r0[i] = rhs;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.master_parameter = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.ele_anchor_pt = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.field_type = rhs;

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.ptr = NULL;
  else {
    C.ptr = new CPP_cartesian_map_term;
    set_CPP_cartesian_map_term_test_pattern((*C.ptr), ix_patt);
  }


}

//--------------------------------------------------------------

extern "C" void test_c_cartesian_map (Opaque_cartesian_map_class* F, bool& c_ok) {

  CPP_cartesian_map C, C2;

  c_ok = true;

  cartesian_map_to_c (F, C);
  set_CPP_cartesian_map_test_pattern (C2, 1);

  if (C == C2) {
    cout << " cartesian_map: C side convert F->C: Good" << endl;
  } else {
    cout << " cartesian_map: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cartesian_map_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_cartesian_map (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_cartesian_map_test_pattern (C, 3);
  if (C == C2) {
    cout << " cartesian_map: F side convert F->C: Good" << endl;
  } else {
    cout << " cartesian_map: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cartesian_map_test_pattern (C2, 4);
  cartesian_map_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_cylindrical_map_term1 (CPP_cylindrical_map_term1&, bool&);

void set_CPP_cylindrical_map_term1_test_pattern (CPP_cylindrical_map_term1& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[complex, 0, NOT]
  rhs = 1 + offset; C.e_coef = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 2 + offset; C.b_coef = Complex(rhs, 100+rhs);


}

//--------------------------------------------------------------

extern "C" void test_c_cylindrical_map_term1 (Opaque_cylindrical_map_term1_class* F, bool& c_ok) {

  CPP_cylindrical_map_term1 C, C2;

  c_ok = true;

  cylindrical_map_term1_to_c (F, C);
  set_CPP_cylindrical_map_term1_test_pattern (C2, 1);

  if (C == C2) {
    cout << " cylindrical_map_term1: C side convert F->C: Good" << endl;
  } else {
    cout << " cylindrical_map_term1: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cylindrical_map_term1_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_cylindrical_map_term1 (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_cylindrical_map_term1_test_pattern (C, 3);
  if (C == C2) {
    cout << " cylindrical_map_term1: F side convert F->C: Good" << endl;
  } else {
    cout << " cylindrical_map_term1: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cylindrical_map_term1_test_pattern (C2, 4);
  cylindrical_map_term1_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_cylindrical_map_term (CPP_cylindrical_map_term&, bool&);

void set_CPP_cylindrical_map_term_test_pattern (CPP_cylindrical_map_term& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_link = rhs;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.term.resize(0);
  else {
    C.term.resize(3);
    for (unsigned int i = 0; i < C.term.size(); i++)  {set_CPP_cylindrical_map_term1_test_pattern(C.term[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_cylindrical_map_term (Opaque_cylindrical_map_term_class* F, bool& c_ok) {

  CPP_cylindrical_map_term C, C2;

  c_ok = true;

  cylindrical_map_term_to_c (F, C);
  set_CPP_cylindrical_map_term_test_pattern (C2, 1);

  if (C == C2) {
    cout << " cylindrical_map_term: C side convert F->C: Good" << endl;
  } else {
    cout << " cylindrical_map_term: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cylindrical_map_term_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_cylindrical_map_term (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_cylindrical_map_term_test_pattern (C, 3);
  if (C == C2) {
    cout << " cylindrical_map_term: F side convert F->C: Good" << endl;
  } else {
    cout << " cylindrical_map_term: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cylindrical_map_term_test_pattern (C2, 4);
  cylindrical_map_term_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_cylindrical_map (CPP_cylindrical_map&, bool&);

void set_CPP_cylindrical_map_test_pattern (CPP_cylindrical_map& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.m = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.harmonic = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.phi0_fieldmap = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.theta0_azimuth = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.field_scale = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 6 + offset; C.master_parameter = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.ele_anchor_pt = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.dz = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r0.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.r0[i] = rhs;}
  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.ptr = NULL;
  else {
    C.ptr = new CPP_cylindrical_map_term;
    set_CPP_cylindrical_map_term_test_pattern((*C.ptr), ix_patt);
  }


}

//--------------------------------------------------------------

extern "C" void test_c_cylindrical_map (Opaque_cylindrical_map_class* F, bool& c_ok) {

  CPP_cylindrical_map C, C2;

  c_ok = true;

  cylindrical_map_to_c (F, C);
  set_CPP_cylindrical_map_test_pattern (C2, 1);

  if (C == C2) {
    cout << " cylindrical_map: C side convert F->C: Good" << endl;
  } else {
    cout << " cylindrical_map: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cylindrical_map_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_cylindrical_map (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_cylindrical_map_test_pattern (C, 3);
  if (C == C2) {
    cout << " cylindrical_map: F side convert F->C: Good" << endl;
  } else {
    cout << " cylindrical_map: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_cylindrical_map_test_pattern (C2, 4);
  cylindrical_map_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_grid_field_pt1 (CPP_grid_field_pt1&, bool&);

void set_CPP_grid_field_pt1_test_pattern (CPP_grid_field_pt1& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[complex, 1, NOT]
  for (unsigned int i = 0; i < C.e.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.e[i] = Complex(rhs, 100+rhs);}
  // c_side.test_pat[complex, 1, NOT]
  for (unsigned int i = 0; i < C.b.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.b[i] = Complex(rhs, 100+rhs);}

}

//--------------------------------------------------------------

extern "C" void test_c_grid_field_pt1 (Opaque_grid_field_pt1_class* F, bool& c_ok) {

  CPP_grid_field_pt1 C, C2;

  c_ok = true;

  grid_field_pt1_to_c (F, C);
  set_CPP_grid_field_pt1_test_pattern (C2, 1);

  if (C == C2) {
    cout << " grid_field_pt1: C side convert F->C: Good" << endl;
  } else {
    cout << " grid_field_pt1: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_grid_field_pt1_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_grid_field_pt1 (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_grid_field_pt1_test_pattern (C, 3);
  if (C == C2) {
    cout << " grid_field_pt1: F side convert F->C: Good" << endl;
  } else {
    cout << " grid_field_pt1: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_grid_field_pt1_test_pattern (C2, 4);
  grid_field_pt1_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_grid_field_pt (CPP_grid_field_pt&, bool&);

void set_CPP_grid_field_pt_test_pattern (CPP_grid_field_pt& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_link = rhs;

  // c_side.test_pat[type, 3, ALLOC]
  if (ix_patt < 3) 
    C.pt.resize(0);
  else {
    C.pt.resize(3);
    for (unsigned int i = 0; i < C.pt.size(); i++) {
      C.pt[i].resize(2);
      for (unsigned int j = 0; j < C.pt[0].size(); j++) {
        C.pt[i][j].resize(1);
        for (unsigned int k = 0; k < C.pt[0][0].size(); k++) {
          set_CPP_grid_field_pt1_test_pattern(C.pt[i][j][k], ix_patt+i+2*j+3*k+6);
    } } }
  }


}

//--------------------------------------------------------------

extern "C" void test_c_grid_field_pt (Opaque_grid_field_pt_class* F, bool& c_ok) {

  CPP_grid_field_pt C, C2;

  c_ok = true;

  grid_field_pt_to_c (F, C);
  set_CPP_grid_field_pt_test_pattern (C2, 1);

  if (C == C2) {
    cout << " grid_field_pt: C side convert F->C: Good" << endl;
  } else {
    cout << " grid_field_pt: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_grid_field_pt_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_grid_field_pt (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_grid_field_pt_test_pattern (C, 3);
  if (C == C2) {
    cout << " grid_field_pt: F side convert F->C: Good" << endl;
  } else {
    cout << " grid_field_pt: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_grid_field_pt_test_pattern (C2, 4);
  grid_field_pt_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_grid_field (CPP_grid_field&, bool&);

void set_CPP_grid_field_test_pattern (CPP_grid_field& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.geometry = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.harmonic = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.phi0_fieldmap = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.field_scale = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.field_type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 6 + offset; C.master_parameter = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.ele_anchor_pt = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.interpolation_order = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.dr.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.dr[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r0.size(); i++)
    {int rhs = 101 + i + 10 + offset; C.r0[i] = rhs;}
  // c_side.test_pat[logical, 0, NOT]
  rhs = 11 + offset; C.curved_ref_frame = (rhs % 2 == 0);

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.ptr = NULL;
  else {
    C.ptr = new CPP_grid_field_pt;
    set_CPP_grid_field_pt_test_pattern((*C.ptr), ix_patt);
  }


}

//--------------------------------------------------------------

extern "C" void test_c_grid_field (Opaque_grid_field_class* F, bool& c_ok) {

  CPP_grid_field C, C2;

  c_ok = true;

  grid_field_to_c (F, C);
  set_CPP_grid_field_test_pattern (C2, 1);

  if (C == C2) {
    cout << " grid_field: C side convert F->C: Good" << endl;
  } else {
    cout << " grid_field: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_grid_field_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_grid_field (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_grid_field_test_pattern (C, 3);
  if (C == C2) {
    cout << " grid_field: F side convert F->C: Good" << endl;
  } else {
    cout << " grid_field: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_grid_field_test_pattern (C2, 4);
  grid_field_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_floor_position (CPP_floor_position&, bool&);

void set_CPP_floor_position_test_pattern (CPP_floor_position& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.r[i] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.w.size(); i++)  for (unsigned int j = 0; j < C.w[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 2 + offset; C.w[i][j] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.theta = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.psi = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_floor_position (Opaque_floor_position_class* F, bool& c_ok) {

  CPP_floor_position C, C2;

  c_ok = true;

  floor_position_to_c (F, C);
  set_CPP_floor_position_test_pattern (C2, 1);

  if (C == C2) {
    cout << " floor_position: C side convert F->C: Good" << endl;
  } else {
    cout << " floor_position: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_floor_position_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_floor_position (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_floor_position_test_pattern (C, 3);
  if (C == C2) {
    cout << " floor_position: F side convert F->C: Good" << endl;
  } else {
    cout << " floor_position: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_floor_position_test_pattern (C2, 4);
  floor_position_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_high_energy_space_charge (CPP_high_energy_space_charge&, bool&);

void set_CPP_high_energy_space_charge_test_pattern (CPP_high_energy_space_charge& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.closed_orb, ix_patt);

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.kick_const = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.sig_x = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.sig_y = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.sin_phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.cos_phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.sig_z = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_high_energy_space_charge (Opaque_high_energy_space_charge_class* F, bool& c_ok) {

  CPP_high_energy_space_charge C, C2;

  c_ok = true;

  high_energy_space_charge_to_c (F, C);
  set_CPP_high_energy_space_charge_test_pattern (C2, 1);

  if (C == C2) {
    cout << " high_energy_space_charge: C side convert F->C: Good" << endl;
  } else {
    cout << " high_energy_space_charge: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_high_energy_space_charge_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_high_energy_space_charge (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_high_energy_space_charge_test_pattern (C, 3);
  if (C == C2) {
    cout << " high_energy_space_charge: F side convert F->C: Good" << endl;
  } else {
    cout << " high_energy_space_charge: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_high_energy_space_charge_test_pattern (C2, 4);
  high_energy_space_charge_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_xy_disp (CPP_xy_disp&, bool&);

void set_CPP_xy_disp_test_pattern (CPP_xy_disp& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.eta = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.etap = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.sigma = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_xy_disp (Opaque_xy_disp_class* F, bool& c_ok) {

  CPP_xy_disp C, C2;

  c_ok = true;

  xy_disp_to_c (F, C);
  set_CPP_xy_disp_test_pattern (C2, 1);

  if (C == C2) {
    cout << " xy_disp: C side convert F->C: Good" << endl;
  } else {
    cout << " xy_disp: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_xy_disp_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_xy_disp (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_xy_disp_test_pattern (C, 3);
  if (C == C2) {
    cout << " xy_disp: F side convert F->C: Good" << endl;
  } else {
    cout << " xy_disp: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_xy_disp_test_pattern (C2, 4);
  xy_disp_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_twiss (CPP_twiss&, bool&);

void set_CPP_twiss_test_pattern (CPP_twiss& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.beta = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.alpha = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.gamma = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.eta = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.etap = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.sigma = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.sigma_p = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.emit = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.norm_emit = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_twiss (Opaque_twiss_class* F, bool& c_ok) {

  CPP_twiss C, C2;

  c_ok = true;

  twiss_to_c (F, C);
  set_CPP_twiss_test_pattern (C2, 1);

  if (C == C2) {
    cout << " twiss: C side convert F->C: Good" << endl;
  } else {
    cout << " twiss: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_twiss_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_twiss (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_twiss_test_pattern (C, 3);
  if (C == C2) {
    cout << " twiss: F side convert F->C: Good" << endl;
  } else {
    cout << " twiss: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_twiss_test_pattern (C2, 4);
  twiss_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_mode3 (CPP_mode3&, bool&);

void set_CPP_mode3_test_pattern (CPP_mode3& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.v.size(); i++)  for (unsigned int j = 0; j < C.v[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 1 + offset; C.v[i][j] = rhs;}
  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.a, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.b, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.c, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.x, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.y, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_mode3 (Opaque_mode3_class* F, bool& c_ok) {

  CPP_mode3 C, C2;

  c_ok = true;

  mode3_to_c (F, C);
  set_CPP_mode3_test_pattern (C2, 1);

  if (C == C2) {
    cout << " mode3: C side convert F->C: Good" << endl;
  } else {
    cout << " mode3: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_mode3_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_mode3 (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_mode3_test_pattern (C, 3);
  if (C == C2) {
    cout << " mode3: F side convert F->C: Good" << endl;
  } else {
    cout << " mode3: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_mode3_test_pattern (C2, 4);
  mode3_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_bookkeeping_state (CPP_bookkeeping_state&, bool&);

void set_CPP_bookkeeping_state_test_pattern (CPP_bookkeeping_state& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.attributes = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.control = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.floor_position = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.s_position = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.ref_energy = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 6 + offset; C.mat6 = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.rad_int = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.ptc = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_bookkeeping_state (Opaque_bookkeeping_state_class* F, bool& c_ok) {

  CPP_bookkeeping_state C, C2;

  c_ok = true;

  bookkeeping_state_to_c (F, C);
  set_CPP_bookkeeping_state_test_pattern (C2, 1);

  if (C == C2) {
    cout << " bookkeeping_state: C side convert F->C: Good" << endl;
  } else {
    cout << " bookkeeping_state: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bookkeeping_state_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_bookkeeping_state (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_bookkeeping_state_test_pattern (C, 3);
  if (C == C2) {
    cout << " bookkeeping_state: F side convert F->C: Good" << endl;
  } else {
    cout << " bookkeeping_state: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bookkeeping_state_test_pattern (C2, 4);
  bookkeeping_state_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_rad_map (CPP_rad_map&, bool&);

void set_CPP_rad_map_test_pattern (CPP_rad_map& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.ref_orb.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.ref_orb[i] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.damp_dmat.size(); i++)  for (unsigned int j = 0; j < C.damp_dmat[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 2 + offset; C.damp_dmat[i][j] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.xfer_damp_vec.size(); i++)
    {int rhs = 101 + i + 3 + offset; C.xfer_damp_vec[i] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.xfer_damp_mat.size(); i++)  for (unsigned int j = 0; j < C.xfer_damp_mat[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 4 + offset; C.xfer_damp_mat[i][j] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.stoc_mat.size(); i++)  for (unsigned int j = 0; j < C.stoc_mat[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 5 + offset; C.stoc_mat[i][j] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_rad_map (Opaque_rad_map_class* F, bool& c_ok) {

  CPP_rad_map C, C2;

  c_ok = true;

  rad_map_to_c (F, C);
  set_CPP_rad_map_test_pattern (C2, 1);

  if (C == C2) {
    cout << " rad_map: C side convert F->C: Good" << endl;
  } else {
    cout << " rad_map: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_map_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_rad_map (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_rad_map_test_pattern (C, 3);
  if (C == C2) {
    cout << " rad_map: F side convert F->C: Good" << endl;
  } else {
    cout << " rad_map: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_map_test_pattern (C2, 4);
  rad_map_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_rad_map_ele (CPP_rad_map_ele&, bool&);

void set_CPP_rad_map_ele_test_pattern (CPP_rad_map_ele& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_rad_map_test_pattern(C.rm0, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_rad_map_test_pattern(C.rm1, ix_patt);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 3 + offset; C.stale = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_rad_map_ele (Opaque_rad_map_ele_class* F, bool& c_ok) {

  CPP_rad_map_ele C, C2;

  c_ok = true;

  rad_map_ele_to_c (F, C);
  set_CPP_rad_map_ele_test_pattern (C2, 1);

  if (C == C2) {
    cout << " rad_map_ele: C side convert F->C: Good" << endl;
  } else {
    cout << " rad_map_ele: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_map_ele_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_rad_map_ele (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_rad_map_ele_test_pattern (C, 3);
  if (C == C2) {
    cout << " rad_map_ele: F side convert F->C: Good" << endl;
  } else {
    cout << " rad_map_ele: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_map_ele_test_pattern (C2, 4);
  rad_map_ele_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_gen_grad1 (CPP_gen_grad1&, bool&);

void set_CPP_gen_grad1_test_pattern (CPP_gen_grad1& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.m = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.sincos = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.n_deriv_max = rhs;

  // c_side.test_pat[real, 2, ALLOC]
  if (ix_patt < 3) 
    C.deriv.resize(0);
  else {
    C.deriv.resize(3);
    for (unsigned int i = 0; i < C.deriv.size(); i++)
      C.deriv[i].resize(2);
    for (unsigned int i = 0; i < C.deriv.size(); i++)  for (unsigned int j = 0; j < C.deriv[0].size(); j++) 
      {int rhs = 101 + i + 10*(j+1) + 4 + offset; C.deriv[i][j] = rhs;}  }


}

//--------------------------------------------------------------

extern "C" void test_c_gen_grad1 (Opaque_gen_grad1_class* F, bool& c_ok) {

  CPP_gen_grad1 C, C2;

  c_ok = true;

  gen_grad1_to_c (F, C);
  set_CPP_gen_grad1_test_pattern (C2, 1);

  if (C == C2) {
    cout << " gen_grad1: C side convert F->C: Good" << endl;
  } else {
    cout << " gen_grad1: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_gen_grad1_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_gen_grad1 (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_gen_grad1_test_pattern (C, 3);
  if (C == C2) {
    cout << " gen_grad1: F side convert F->C: Good" << endl;
  } else {
    cout << " gen_grad1: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_gen_grad1_test_pattern (C2, 4);
  gen_grad1_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_gen_grad_map (CPP_gen_grad_map&, bool&);

void set_CPP_gen_grad_map_test_pattern (CPP_gen_grad_map& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.gg.resize(0);
  else {
    C.gg.resize(3);
    for (unsigned int i = 0; i < C.gg.size(); i++)  {set_CPP_gen_grad1_test_pattern(C.gg[i], ix_patt+i+1);}
  }

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.ele_anchor_pt = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.field_type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 6 + offset; C.iz0 = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.iz1 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.dz = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r0.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.r0[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.field_scale = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 11 + offset; C.master_parameter = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 12 + offset; C.curved_ref_frame = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_gen_grad_map (Opaque_gen_grad_map_class* F, bool& c_ok) {

  CPP_gen_grad_map C, C2;

  c_ok = true;

  gen_grad_map_to_c (F, C);
  set_CPP_gen_grad_map_test_pattern (C2, 1);

  if (C == C2) {
    cout << " gen_grad_map: C side convert F->C: Good" << endl;
  } else {
    cout << " gen_grad_map: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_gen_grad_map_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_gen_grad_map (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_gen_grad_map_test_pattern (C, 3);
  if (C == C2) {
    cout << " gen_grad_map: F side convert F->C: Good" << endl;
  } else {
    cout << " gen_grad_map: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_gen_grad_map_test_pattern (C2, 4);
  gen_grad_map_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_surface_grid_pt (CPP_surface_grid_pt&, bool&);

void set_CPP_surface_grid_pt_test_pattern (CPP_surface_grid_pt& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_surface_orientation_test_pattern(C.orientation, ix_patt);

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.z0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.x0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.y0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.dz_dx = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.dz_dy = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.d2z_dxdy = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_surface_grid_pt (Opaque_surface_grid_pt_class* F, bool& c_ok) {

  CPP_surface_grid_pt C, C2;

  c_ok = true;

  surface_grid_pt_to_c (F, C);
  set_CPP_surface_grid_pt_test_pattern (C2, 1);

  if (C == C2) {
    cout << " surface_grid_pt: C side convert F->C: Good" << endl;
  } else {
    cout << " surface_grid_pt: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_grid_pt_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_surface_grid_pt (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_surface_grid_pt_test_pattern (C, 3);
  if (C == C2) {
    cout << " surface_grid_pt: F side convert F->C: Good" << endl;
  } else {
    cout << " surface_grid_pt: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_grid_pt_test_pattern (C2, 4);
  surface_grid_pt_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_surface_grid (CPP_surface_grid&, bool&);

void set_CPP_surface_grid_test_pattern (CPP_surface_grid& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 1 + offset; C.active = (rhs % 2 == 0);

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.type = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.dr.size(); i++)
    {int rhs = 101 + i + 3 + offset; C.dr[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r0.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.r0[i] = rhs;}
  // c_side.test_pat[type, 2, ALLOC]
  if (ix_patt < 3) 
    C.pt.resize(0);
  else {
    C.pt.resize(3);
    for (unsigned int i = 0; i < C.pt.size(); i++) {
      C.pt[i].resize(2);

      for (unsigned int j = 0; j < C.pt[0].size(); j++) {
        set_CPP_surface_grid_pt_test_pattern(C.pt[i][j], ix_patt+i+2*j+3);
      }
    }
  }


}

//--------------------------------------------------------------

extern "C" void test_c_surface_grid (Opaque_surface_grid_class* F, bool& c_ok) {

  CPP_surface_grid C, C2;

  c_ok = true;

  surface_grid_to_c (F, C);
  set_CPP_surface_grid_test_pattern (C2, 1);

  if (C == C2) {
    cout << " surface_grid: C side convert F->C: Good" << endl;
  } else {
    cout << " surface_grid: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_grid_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_surface_grid (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_surface_grid_test_pattern (C, 3);
  if (C == C2) {
    cout << " surface_grid: F side convert F->C: Good" << endl;
  } else {
    cout << " surface_grid: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_grid_test_pattern (C2, 4);
  surface_grid_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_target_point (CPP_target_point&, bool&);

void set_CPP_target_point_test_pattern (CPP_target_point& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.r[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_target_point (Opaque_target_point_class* F, bool& c_ok) {

  CPP_target_point C, C2;

  c_ok = true;

  target_point_to_c (F, C);
  set_CPP_target_point_test_pattern (C2, 1);

  if (C == C2) {
    cout << " target_point: C side convert F->C: Good" << endl;
  } else {
    cout << " target_point: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_target_point_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_target_point (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_target_point_test_pattern (C, 3);
  if (C == C2) {
    cout << " target_point: F side convert F->C: Good" << endl;
  } else {
    cout << " target_point: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_target_point_test_pattern (C2, 4);
  target_point_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_surface_curvature (CPP_surface_curvature&, bool&);

void set_CPP_surface_curvature_test_pattern (CPP_surface_curvature& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.xy.size(); i++)  for (unsigned int j = 0; j < C.xy[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 1 + offset; C.xy[i][j] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.spherical = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.elliptical.size(); i++)
    {int rhs = 101 + i + 3 + offset; C.elliptical[i] = rhs;}
  // c_side.test_pat[logical, 0, NOT]
  rhs = 4 + offset; C.has_curvature = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_surface_curvature (Opaque_surface_curvature_class* F, bool& c_ok) {

  CPP_surface_curvature C, C2;

  c_ok = true;

  surface_curvature_to_c (F, C);
  set_CPP_surface_curvature_test_pattern (C2, 1);

  if (C == C2) {
    cout << " surface_curvature: C side convert F->C: Good" << endl;
  } else {
    cout << " surface_curvature: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_curvature_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_surface_curvature (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_surface_curvature_test_pattern (C, 3);
  if (C == C2) {
    cout << " surface_curvature: F side convert F->C: Good" << endl;
  } else {
    cout << " surface_curvature: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_curvature_test_pattern (C2, 4);
  surface_curvature_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_target (CPP_photon_target&, bool&);

void set_CPP_photon_target_test_pattern (CPP_photon_target& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_corner = rhs;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_lat_ele_loc_test_pattern(C.ele_loc, ix_patt);

  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.corner.size(); i++)
    {int rhs = 101 + i + 4 + offset; set_CPP_target_point_test_pattern(C.corner[i], ix_patt+i+1);}
  // c_side.test_pat[type, 0, NOT]
  set_CPP_target_point_test_pattern(C.center, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_photon_target (Opaque_photon_target_class* F, bool& c_ok) {

  CPP_photon_target C, C2;

  c_ok = true;

  photon_target_to_c (F, C);
  set_CPP_photon_target_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_target: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_target: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_target_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_target (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_target_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_target: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_target: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_target_test_pattern (C2, 4);
  photon_target_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_material (CPP_photon_material&, bool&);

void set_CPP_photon_material_test_pattern (CPP_photon_material& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[complex, 0, NOT]
  rhs = 1 + offset; C.f0_m1 = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 2 + offset; C.f0_m2 = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 3 + offset; C.f_0 = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 4 + offset; C.f_h = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 5 + offset; C.f_hbar = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 6 + offset; C.f_hkl = Complex(rhs, 100+rhs);

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.h_norm.size(); i++)
    {int rhs = 101 + i + 7 + offset; C.h_norm[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.l_ref.size(); i++)
    {int rhs = 101 + i + 8 + offset; C.l_ref[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_photon_material (Opaque_photon_material_class* F, bool& c_ok) {

  CPP_photon_material C, C2;

  c_ok = true;

  photon_material_to_c (F, C);
  set_CPP_photon_material_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_material: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_material: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_material_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_material (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_material_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_material: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_material: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_material_test_pattern (C2, 4);
  photon_material_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_pixel_pt (CPP_pixel_pt&, bool&);

void set_CPP_pixel_pt_test_pattern (CPP_pixel_pt& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer8, 0, NOT]
  rhs = 1 + offset; C.n_photon = rhs;

  // c_side.test_pat[complex, 0, NOT]
  rhs = 2 + offset; C.e_x = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 3 + offset; C.e_y = Complex(rhs, 100+rhs);

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.intensity_x = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.intensity_y = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.intensity = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.orbit.size(); i++)
    {int rhs = 101 + i + 7 + offset; C.orbit[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.orbit_rms.size(); i++)
    {int rhs = 101 + i + 8 + offset; C.orbit_rms[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.init_orbit.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.init_orbit[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.init_orbit_rms.size(); i++)
    {int rhs = 101 + i + 10 + offset; C.init_orbit_rms[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_pixel_pt (Opaque_pixel_pt_class* F, bool& c_ok) {

  CPP_pixel_pt C, C2;

  c_ok = true;

  pixel_pt_to_c (F, C);
  set_CPP_pixel_pt_test_pattern (C2, 1);

  if (C == C2) {
    cout << " pixel_pt: C side convert F->C: Good" << endl;
  } else {
    cout << " pixel_pt: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_pixel_pt_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_pixel_pt (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_pixel_pt_test_pattern (C, 3);
  if (C == C2) {
    cout << " pixel_pt: F side convert F->C: Good" << endl;
  } else {
    cout << " pixel_pt: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_pixel_pt_test_pattern (C2, 4);
  pixel_pt_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_pixel_detec (CPP_pixel_detec&, bool&);

void set_CPP_pixel_detec_test_pattern (CPP_pixel_detec& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.dr.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.dr[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r0.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.r0[i] = rhs;}
  // c_side.test_pat[integer8, 0, NOT]
  rhs = 3 + offset; C.n_track_tot = rhs;

  // c_side.test_pat[integer8, 0, NOT]
  rhs = 4 + offset; C.n_hit_detec = rhs;

  // c_side.test_pat[integer8, 0, NOT]
  rhs = 5 + offset; C.n_hit_pixel = rhs;

  // c_side.test_pat[type, 2, ALLOC]
  if (ix_patt < 3) 
    C.pt.resize(0);
  else {
    C.pt.resize(3);
    for (unsigned int i = 0; i < C.pt.size(); i++) {
      C.pt[i].resize(2);

      for (unsigned int j = 0; j < C.pt[0].size(); j++) {
        set_CPP_pixel_pt_test_pattern(C.pt[i][j], ix_patt+i+2*j+3);
      }
    }
  }


}

//--------------------------------------------------------------

extern "C" void test_c_pixel_detec (Opaque_pixel_detec_class* F, bool& c_ok) {

  CPP_pixel_detec C, C2;

  c_ok = true;

  pixel_detec_to_c (F, C);
  set_CPP_pixel_detec_test_pattern (C2, 1);

  if (C == C2) {
    cout << " pixel_detec: C side convert F->C: Good" << endl;
  } else {
    cout << " pixel_detec: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_pixel_detec_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_pixel_detec (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_pixel_detec_test_pattern (C, 3);
  if (C == C2) {
    cout << " pixel_detec: F side convert F->C: Good" << endl;
  } else {
    cout << " pixel_detec: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_pixel_detec_test_pattern (C2, 4);
  pixel_detec_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_element (CPP_photon_element&, bool&);

void set_CPP_photon_element_test_pattern (CPP_photon_element& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_surface_curvature_test_pattern(C.curvature, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_photon_target_test_pattern(C.target, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_photon_material_test_pattern(C.material, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_surface_grid_test_pattern(C.grid, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_pixel_detec_test_pattern(C.pixel, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_photon_element (Opaque_photon_element_class* F, bool& c_ok) {

  CPP_photon_element C, C2;

  c_ok = true;

  photon_element_to_c (F, C);
  set_CPP_photon_element_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_element: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_element: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_element_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_element (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_element_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_element: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_element: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_element_test_pattern (C2, 4);
  photon_element_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wall3d_vertex (CPP_wall3d_vertex&, bool&);

void set_CPP_wall3d_vertex_test_pattern (CPP_wall3d_vertex& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.x = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.y = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.radius_x = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.radius_y = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.tilt = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.angle = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.x0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.y0 = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.type = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_wall3d_vertex (Opaque_wall3d_vertex_class* F, bool& c_ok) {

  CPP_wall3d_vertex C, C2;

  c_ok = true;

  wall3d_vertex_to_c (F, C);
  set_CPP_wall3d_vertex_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wall3d_vertex: C side convert F->C: Good" << endl;
  } else {
    cout << " wall3d_vertex: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_vertex_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wall3d_vertex (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wall3d_vertex_test_pattern (C, 3);
  if (C == C2) {
    cout << " wall3d_vertex: F side convert F->C: Good" << endl;
  } else {
    cout << " wall3d_vertex: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_vertex_test_pattern (C2, 4);
  wall3d_vertex_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wall3d_section (CPP_wall3d_section&, bool&);

void set_CPP_wall3d_section_test_pattern (CPP_wall3d_section& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.material.resize(20);
  for (unsigned int i = 0; i < C.material.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.material[i] = 'a' + rhs % 26;}
  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.v.resize(0);
  else {
    C.v.resize(3);
    for (unsigned int i = 0; i < C.v.size(); i++)  {set_CPP_wall3d_vertex_test_pattern(C.v[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.surface = NULL;
  else {
    C.surface = new CPP_photon_reflect_surface;
    set_CPP_photon_reflect_surface_test_pattern((*C.surface), ix_patt);
  }

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.n_vertex_input = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 10 + offset; C.ix_branch = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 11 + offset; C.vertices_state = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 12 + offset; C.patch_in_region = (rhs % 2 == 0);

  // c_side.test_pat[real, 0, NOT]
  rhs = 13 + offset; C.thickness = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 14 + offset; C.s = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r0.size(); i++)
    {int rhs = 101 + i + 15 + offset; C.r0[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 16 + offset; C.dx0_ds = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 17 + offset; C.dy0_ds = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.x0_coef.size(); i++)
    {int rhs = 101 + i + 18 + offset; C.x0_coef[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.y0_coef.size(); i++)
    {int rhs = 101 + i + 19 + offset; C.y0_coef[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 20 + offset; C.dr_ds = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.p1_coef.size(); i++)
    {int rhs = 101 + i + 21 + offset; C.p1_coef[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.p2_coef.size(); i++)
    {int rhs = 101 + i + 22 + offset; C.p2_coef[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_wall3d_section (Opaque_wall3d_section_class* F, bool& c_ok) {

  CPP_wall3d_section C, C2;

  c_ok = true;

  wall3d_section_to_c (F, C);
  set_CPP_wall3d_section_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wall3d_section: C side convert F->C: Good" << endl;
  } else {
    cout << " wall3d_section: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_section_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wall3d_section (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wall3d_section_test_pattern (C, 3);
  if (C == C2) {
    cout << " wall3d_section: F side convert F->C: Good" << endl;
  } else {
    cout << " wall3d_section: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_section_test_pattern (C2, 4);
  wall3d_section_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wall3d (CPP_wall3d&, bool&);

void set_CPP_wall3d_test_pattern (CPP_wall3d& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.ix_wall3d = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.n_link = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.thickness = rhs;

  // c_side.test_pat[character, 0, NOT]
  C.clear_material.resize(20);
  for (unsigned int i = 0; i < C.clear_material.size(); i++)
    {int rhs = 101 + i + 6 + offset; C.clear_material[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.opaque_material.resize(20);
  for (unsigned int i = 0; i < C.opaque_material.size(); i++)
    {int rhs = 101 + i + 7 + offset; C.opaque_material[i] = 'a' + rhs % 26;}
  // c_side.test_pat[logical, 0, NOT]
  rhs = 8 + offset; C.superimpose = (rhs % 2 == 0);

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.ele_anchor_pt = rhs;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.section.resize(0);
  else {
    C.section.resize(3);
    for (unsigned int i = 0; i < C.section.size(); i++)  {set_CPP_wall3d_section_test_pattern(C.section[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_wall3d (Opaque_wall3d_class* F, bool& c_ok) {

  CPP_wall3d C, C2;

  c_ok = true;

  wall3d_to_c (F, C);
  set_CPP_wall3d_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wall3d: C side convert F->C: Good" << endl;
  } else {
    cout << " wall3d: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wall3d (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wall3d_test_pattern (C, 3);
  if (C == C2) {
    cout << " wall3d: F side convert F->C: Good" << endl;
  } else {
    cout << " wall3d: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_test_pattern (C2, 4);
  wall3d_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_control (CPP_control&, bool&);

void set_CPP_control_test_pattern (CPP_control& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.value = rhs;

  // c_side.test_pat[real, 1, ALLOC]
  if (ix_patt < 3) 
    C.y_knot.resize(0);
  else {
    C.y_knot.resize(3);
    for (unsigned int i = 0; i < C.y_knot.size(); i++)
      {int rhs = 101 + i + 2 + offset; C.y_knot[i] = rhs;}  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.stack.resize(0);
  else {
    C.stack.resize(3);
    for (unsigned int i = 0; i < C.stack.size(); i++)  {set_CPP_expression_atom_test_pattern(C.stack[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_lat_ele_loc_test_pattern(C.slave, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_lat_ele_loc_test_pattern(C.lord, ix_patt);

  // c_side.test_pat[character, 0, NOT]
  C.attribute.resize(40);
  for (unsigned int i = 0; i < C.attribute.size(); i++)
    {int rhs = 101 + i + 8 + offset; C.attribute[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.slave_name.resize(40);
  for (unsigned int i = 0; i < C.slave_name.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.slave_name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 10 + offset; C.ix_attrib = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_control (Opaque_control_class* F, bool& c_ok) {

  CPP_control C, C2;

  c_ok = true;

  control_to_c (F, C);
  set_CPP_control_test_pattern (C2, 1);

  if (C == C2) {
    cout << " control: C side convert F->C: Good" << endl;
  } else {
    cout << " control: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_control_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_control (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_control_test_pattern (C, 3);
  if (C == C2) {
    cout << " control: F side convert F->C: Good" << endl;
  } else {
    cout << " control: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_control_test_pattern (C2, 4);
  control_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_controller_var1 (CPP_controller_var1&, bool&);

void set_CPP_controller_var1_test_pattern (CPP_controller_var1& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.value = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.old_value = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_controller_var1 (Opaque_controller_var1_class* F, bool& c_ok) {

  CPP_controller_var1 C, C2;

  c_ok = true;

  controller_var1_to_c (F, C);
  set_CPP_controller_var1_test_pattern (C2, 1);

  if (C == C2) {
    cout << " controller_var1: C side convert F->C: Good" << endl;
  } else {
    cout << " controller_var1: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_controller_var1_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_controller_var1 (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_controller_var1_test_pattern (C, 3);
  if (C == C2) {
    cout << " controller_var1: F side convert F->C: Good" << endl;
  } else {
    cout << " controller_var1: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_controller_var1_test_pattern (C2, 4);
  controller_var1_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_controller (CPP_controller&, bool&);

void set_CPP_controller_test_pattern (CPP_controller& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.type = rhs;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.var.resize(0);
  else {
    C.var.resize(3);
    for (unsigned int i = 0; i < C.var.size(); i++)  {set_CPP_controller_var1_test_pattern(C.var[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.ramp.resize(0);
  else {
    C.ramp.resize(3);
    for (unsigned int i = 0; i < C.ramp.size(); i++)  {set_CPP_control_test_pattern(C.ramp[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 1, ALLOC]
  if (ix_patt < 3) 
    C.x_knot.resize(0);
  else {
    C.x_knot.resize(3);
    for (unsigned int i = 0; i < C.x_knot.size(); i++)
      {int rhs = 101 + i + 6 + offset; C.x_knot[i] = rhs;}  }


}

//--------------------------------------------------------------

extern "C" void test_c_controller (Opaque_controller_class* F, bool& c_ok) {

  CPP_controller C, C2;

  c_ok = true;

  controller_to_c (F, C);
  set_CPP_controller_test_pattern (C2, 1);

  if (C == C2) {
    cout << " controller: C side convert F->C: Good" << endl;
  } else {
    cout << " controller: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_controller_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_controller (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_controller_test_pattern (C, 3);
  if (C == C2) {
    cout << " controller: F side convert F->C: Good" << endl;
  } else {
    cout << " controller: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_controller_test_pattern (C2, 4);
  controller_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_ellipse_beam_init (CPP_ellipse_beam_init&, bool&);

void set_CPP_ellipse_beam_init_test_pattern (CPP_ellipse_beam_init& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.part_per_ellipse = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_ellipse = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.sigma_cutoff = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_ellipse_beam_init (Opaque_ellipse_beam_init_class* F, bool& c_ok) {

  CPP_ellipse_beam_init C, C2;

  c_ok = true;

  ellipse_beam_init_to_c (F, C);
  set_CPP_ellipse_beam_init_test_pattern (C2, 1);

  if (C == C2) {
    cout << " ellipse_beam_init: C side convert F->C: Good" << endl;
  } else {
    cout << " ellipse_beam_init: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ellipse_beam_init_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_ellipse_beam_init (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_ellipse_beam_init_test_pattern (C, 3);
  if (C == C2) {
    cout << " ellipse_beam_init: F side convert F->C: Good" << endl;
  } else {
    cout << " ellipse_beam_init: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ellipse_beam_init_test_pattern (C2, 4);
  ellipse_beam_init_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_kv_beam_init (CPP_kv_beam_init&, bool&);

void set_CPP_kv_beam_init_test_pattern (CPP_kv_beam_init& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 1, NOT]
  for (unsigned int i = 0; i < C.part_per_phi.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.part_per_phi[i] = rhs;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_i2 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.a = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_kv_beam_init (Opaque_kv_beam_init_class* F, bool& c_ok) {

  CPP_kv_beam_init C, C2;

  c_ok = true;

  kv_beam_init_to_c (F, C);
  set_CPP_kv_beam_init_test_pattern (C2, 1);

  if (C == C2) {
    cout << " kv_beam_init: C side convert F->C: Good" << endl;
  } else {
    cout << " kv_beam_init: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_kv_beam_init_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_kv_beam_init (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_kv_beam_init_test_pattern (C, 3);
  if (C == C2) {
    cout << " kv_beam_init: F side convert F->C: Good" << endl;
  } else {
    cout << " kv_beam_init: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_kv_beam_init_test_pattern (C2, 4);
  kv_beam_init_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_grid_beam_init (CPP_grid_beam_init&, bool&);

void set_CPP_grid_beam_init_test_pattern (CPP_grid_beam_init& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.n_x = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_px = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.x_min = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.x_max = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.px_min = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.px_max = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_grid_beam_init (Opaque_grid_beam_init_class* F, bool& c_ok) {

  CPP_grid_beam_init C, C2;

  c_ok = true;

  grid_beam_init_to_c (F, C);
  set_CPP_grid_beam_init_test_pattern (C2, 1);

  if (C == C2) {
    cout << " grid_beam_init: C side convert F->C: Good" << endl;
  } else {
    cout << " grid_beam_init: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_grid_beam_init_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_grid_beam_init (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_grid_beam_init_test_pattern (C, 3);
  if (C == C2) {
    cout << " grid_beam_init: F side convert F->C: Good" << endl;
  } else {
    cout << " grid_beam_init: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_grid_beam_init_test_pattern (C2, 4);
  grid_beam_init_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_beam_init (CPP_beam_init&, bool&);

void set_CPP_beam_init_test_pattern (CPP_beam_init& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.position_file.resize(200);
  for (unsigned int i = 0; i < C.position_file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.position_file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.file_name.resize(200);
  for (unsigned int i = 0; i < C.file_name.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.file_name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 1, NOT]
  for (unsigned int i = 0; i < C.distribution_type.size(); i++) {
    C.distribution_type[i].resize(16);
    for (unsigned int j = 0; j < C.distribution_type[i].size(); j++) 
      {C.distribution_type[i][j] = 'a' + (101 + i + 10*(j+1) + 3 + offset) % 26;}
  }

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.spin.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.spin[i] = rhs;}
  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.ellipse.size(); i++)
    {int rhs = 101 + i + 5 + offset; set_CPP_ellipse_beam_init_test_pattern(C.ellipse[i], ix_patt+i+1);}
  // c_side.test_pat[type, 0, NOT]
  set_CPP_kv_beam_init_test_pattern(C.kv, ix_patt);

  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.grid.size(); i++)
    {int rhs = 101 + i + 7 + offset; set_CPP_grid_beam_init_test_pattern(C.grid[i], ix_patt+i+1);}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.center_jitter.size(); i++)
    {int rhs = 101 + i + 8 + offset; C.center_jitter[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.emit_jitter.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.emit_jitter[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.sig_z_jitter = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 11 + offset; C.sig_pz_jitter = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 12 + offset; C.n_particle = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 13 + offset; C.renorm_center = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 14 + offset; C.renorm_sigma = (rhs % 2 == 0);

  // c_side.test_pat[character, 0, NOT]
  C.random_engine.resize(16);
  for (unsigned int i = 0; i < C.random_engine.size(); i++)
    {int rhs = 101 + i + 15 + offset; C.random_engine[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.random_gauss_converter.resize(16);
  for (unsigned int i = 0; i < C.random_gauss_converter.size(); i++)
    {int rhs = 101 + i + 16 + offset; C.random_gauss_converter[i] = 'a' + rhs % 26;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 17 + offset; C.random_sigma_cutoff = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 18 + offset; C.a_norm_emit = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 19 + offset; C.b_norm_emit = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 20 + offset; C.a_emit = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 21 + offset; C.b_emit = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 22 + offset; C.dpz_dz = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.center.size(); i++)
    {int rhs = 101 + i + 23 + offset; C.center[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 24 + offset; C.dt_bunch = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 25 + offset; C.sig_z = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 26 + offset; C.sig_pz = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 27 + offset; C.bunch_charge = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 28 + offset; C.n_bunch = rhs;

  // c_side.test_pat[character, 0, NOT]
  C.species.resize(16);
  for (unsigned int i = 0; i < C.species.size(); i++)
    {int rhs = 101 + i + 29 + offset; C.species[i] = 'a' + rhs % 26;}
  // c_side.test_pat[logical, 0, NOT]
  rhs = 30 + offset; C.init_spin = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 31 + offset; C.full_6d_coupling_calc = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 32 + offset; C.use_particle_start = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 33 + offset; C.use_t_coords = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 34 + offset; C.use_z_as_t = (rhs % 2 == 0);

  // c_side.test_pat[real, 0, NOT]
  rhs = 35 + offset; C.sig_e_jitter = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 36 + offset; C.sig_e = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 37 + offset; C.use_particle_start_for_center = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_beam_init (Opaque_beam_init_class* F, bool& c_ok) {

  CPP_beam_init C, C2;

  c_ok = true;

  beam_init_to_c (F, C);
  set_CPP_beam_init_test_pattern (C2, 1);

  if (C == C2) {
    cout << " beam_init: C side convert F->C: Good" << endl;
  } else {
    cout << " beam_init: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_beam_init_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_beam_init (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_beam_init_test_pattern (C, 3);
  if (C == C2) {
    cout << " beam_init: F side convert F->C: Good" << endl;
  } else {
    cout << " beam_init: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_beam_init_test_pattern (C2, 4);
  beam_init_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_lat_param (CPP_lat_param&, bool&);

void set_CPP_lat_param_test_pattern (CPP_lat_param& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.n_part = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.total_length = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.unstable_factor = rhs;

  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.t1_with_rf.size(); i++)  for (unsigned int j = 0; j < C.t1_with_rf[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 4 + offset; C.t1_with_rf[i][j] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.t1_no_rf.size(); i++)  for (unsigned int j = 0; j < C.t1_no_rf[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 5 + offset; C.t1_no_rf[i][j] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.spin_tune = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.particle = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.default_tracking_species = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.geometry = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 10 + offset; C.ixx = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 11 + offset; C.stable = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 12 + offset; C.live_branch = (rhs % 2 == 0);

  // c_side.test_pat[real, 0, NOT]
  rhs = 13 + offset; C.g1_integral = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 14 + offset; C.g2_integral = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 15 + offset; C.g3_integral = rhs;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_bookkeeping_state_test_pattern(C.bookkeeping_state, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_beam_init_test_pattern(C.beam_init, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_lat_param (Opaque_lat_param_class* F, bool& c_ok) {

  CPP_lat_param C, C2;

  c_ok = true;

  lat_param_to_c (F, C);
  set_CPP_lat_param_test_pattern (C2, 1);

  if (C == C2) {
    cout << " lat_param: C side convert F->C: Good" << endl;
  } else {
    cout << " lat_param: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_param_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_lat_param (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_lat_param_test_pattern (C, 3);
  if (C == C2) {
    cout << " lat_param: F side convert F->C: Good" << endl;
  } else {
    cout << " lat_param: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_param_test_pattern (C2, 4);
  lat_param_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_mode_info (CPP_mode_info&, bool&);

void set_CPP_mode_info_test_pattern (CPP_mode_info& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 1 + offset; C.stable = (rhs % 2 == 0);

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.tune = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.emit = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.chrom = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.sigma = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.sigmap = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_mode_info (Opaque_mode_info_class* F, bool& c_ok) {

  CPP_mode_info C, C2;

  c_ok = true;

  mode_info_to_c (F, C);
  set_CPP_mode_info_test_pattern (C2, 1);

  if (C == C2) {
    cout << " mode_info: C side convert F->C: Good" << endl;
  } else {
    cout << " mode_info: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_mode_info_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_mode_info (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_mode_info_test_pattern (C, 3);
  if (C == C2) {
    cout << " mode_info: F side convert F->C: Good" << endl;
  } else {
    cout << " mode_info: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_mode_info_test_pattern (C2, 4);
  mode_info_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_pre_tracker (CPP_pre_tracker&, bool&);

void set_CPP_pre_tracker_test_pattern (CPP_pre_tracker& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.who = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.ix_ele_start = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.ix_ele_end = rhs;

  // c_side.test_pat[character, 0, NOT]
  C.input_file.resize(200);
  for (unsigned int i = 0; i < C.input_file.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.input_file[i] = 'a' + rhs % 26;}

}

//--------------------------------------------------------------

extern "C" void test_c_pre_tracker (Opaque_pre_tracker_class* F, bool& c_ok) {

  CPP_pre_tracker C, C2;

  c_ok = true;

  pre_tracker_to_c (F, C);
  set_CPP_pre_tracker_test_pattern (C2, 1);

  if (C == C2) {
    cout << " pre_tracker: C side convert F->C: Good" << endl;
  } else {
    cout << " pre_tracker: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_pre_tracker_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_pre_tracker (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_pre_tracker_test_pattern (C, 3);
  if (C == C2) {
    cout << " pre_tracker: F side convert F->C: Good" << endl;
  } else {
    cout << " pre_tracker: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_pre_tracker_test_pattern (C2, 4);
  pre_tracker_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_anormal_mode (CPP_anormal_mode&, bool&);

void set_CPP_anormal_mode_test_pattern (CPP_anormal_mode& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.emittance = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.emittance_no_vert = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.synch_int.size(); i++)
    {int rhs = 101 + i + 3 + offset; C.synch_int[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.j_damp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.alpha_damp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.chrom = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.tune = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_anormal_mode (Opaque_anormal_mode_class* F, bool& c_ok) {

  CPP_anormal_mode C, C2;

  c_ok = true;

  anormal_mode_to_c (F, C);
  set_CPP_anormal_mode_test_pattern (C2, 1);

  if (C == C2) {
    cout << " anormal_mode: C side convert F->C: Good" << endl;
  } else {
    cout << " anormal_mode: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_anormal_mode_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_anormal_mode (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_anormal_mode_test_pattern (C, 3);
  if (C == C2) {
    cout << " anormal_mode: F side convert F->C: Good" << endl;
  } else {
    cout << " anormal_mode: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_anormal_mode_test_pattern (C2, 4);
  anormal_mode_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_linac_normal_mode (CPP_linac_normal_mode&, bool&);

void set_CPP_linac_normal_mode_test_pattern (CPP_linac_normal_mode& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.i2_e4 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.i3_e7 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.i5a_e6 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.i5b_e6 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.sig_e1 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.a_emittance_end = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.b_emittance_end = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_linac_normal_mode (Opaque_linac_normal_mode_class* F, bool& c_ok) {

  CPP_linac_normal_mode C, C2;

  c_ok = true;

  linac_normal_mode_to_c (F, C);
  set_CPP_linac_normal_mode_test_pattern (C2, 1);

  if (C == C2) {
    cout << " linac_normal_mode: C side convert F->C: Good" << endl;
  } else {
    cout << " linac_normal_mode: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_linac_normal_mode_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_linac_normal_mode (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_linac_normal_mode_test_pattern (C, 3);
  if (C == C2) {
    cout << " linac_normal_mode: F side convert F->C: Good" << endl;
  } else {
    cout << " linac_normal_mode: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_linac_normal_mode_test_pattern (C2, 4);
  linac_normal_mode_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_normal_modes (CPP_normal_modes&, bool&);

void set_CPP_normal_modes_test_pattern (CPP_normal_modes& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.synch_int.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.synch_int[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.sige_e = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.sig_z = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.e_loss = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.rf_voltage = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.pz_aperture = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.pz_average = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.momentum_compaction = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.dpz_damp = rhs;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_anormal_mode_test_pattern(C.a, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_anormal_mode_test_pattern(C.b, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_anormal_mode_test_pattern(C.z, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_linac_normal_mode_test_pattern(C.lin, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_normal_modes (Opaque_normal_modes_class* F, bool& c_ok) {

  CPP_normal_modes C, C2;

  c_ok = true;

  normal_modes_to_c (F, C);
  set_CPP_normal_modes_test_pattern (C2, 1);

  if (C == C2) {
    cout << " normal_modes: C side convert F->C: Good" << endl;
  } else {
    cout << " normal_modes: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_normal_modes_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_normal_modes (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_normal_modes_test_pattern (C, 3);
  if (C == C2) {
    cout << " normal_modes: F side convert F->C: Good" << endl;
  } else {
    cout << " normal_modes: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_normal_modes_test_pattern (C2, 4);
  normal_modes_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_field (CPP_em_field&, bool&);

void set_CPP_em_field_test_pattern (CPP_em_field& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.e.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.e[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.b.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.b[i] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.de.size(); i++)  for (unsigned int j = 0; j < C.de[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 3 + offset; C.de[i][j] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.db.size(); i++)  for (unsigned int j = 0; j < C.db[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 4 + offset; C.db[i][j] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.phi_b = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.a.size(); i++)
    {int rhs = 101 + i + 7 + offset; C.a[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_em_field (Opaque_em_field_class* F, bool& c_ok) {

  CPP_em_field C, C2;

  c_ok = true;

  em_field_to_c (F, C);
  set_CPP_em_field_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_field: C side convert F->C: Good" << endl;
  } else {
    cout << " em_field: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_field (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_field_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_field: F side convert F->C: Good" << endl;
  } else {
    cout << " em_field: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_test_pattern (C2, 4);
  em_field_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_strong_beam (CPP_strong_beam&, bool&);

void set_CPP_strong_beam_test_pattern (CPP_strong_beam& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.ix_slice = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.x_center = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.y_center = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.x_sigma = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.y_sigma = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.dx = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.dy = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_strong_beam (Opaque_strong_beam_class* F, bool& c_ok) {

  CPP_strong_beam C, C2;

  c_ok = true;

  strong_beam_to_c (F, C);
  set_CPP_strong_beam_test_pattern (C2, 1);

  if (C == C2) {
    cout << " strong_beam: C side convert F->C: Good" << endl;
  } else {
    cout << " strong_beam: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_strong_beam_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_strong_beam (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_strong_beam_test_pattern (C, 3);
  if (C == C2) {
    cout << " strong_beam: F side convert F->C: Good" << endl;
  } else {
    cout << " strong_beam: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_strong_beam_test_pattern (C2, 4);
  strong_beam_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_track_point (CPP_track_point&, bool&);

void set_CPP_track_point_test_pattern (CPP_track_point& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.s_body = rhs;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.orb, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_em_field_test_pattern(C.field, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_strong_beam_test_pattern(C.strong_beam, ix_patt);

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.vec0.size(); i++)
    {int rhs = 101 + i + 5 + offset; C.vec0[i] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.mat6.size(); i++)  for (unsigned int j = 0; j < C.mat6[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 6 + offset; C.mat6[i][j] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_track_point (Opaque_track_point_class* F, bool& c_ok) {

  CPP_track_point C, C2;

  c_ok = true;

  track_point_to_c (F, C);
  set_CPP_track_point_test_pattern (C2, 1);

  if (C == C2) {
    cout << " track_point: C side convert F->C: Good" << endl;
  } else {
    cout << " track_point: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_track_point_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_track_point (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_track_point_test_pattern (C, 3);
  if (C == C2) {
    cout << " track_point: F side convert F->C: Good" << endl;
  } else {
    cout << " track_point: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_track_point_test_pattern (C2, 4);
  track_point_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_track (CPP_track&, bool&);

void set_CPP_track_test_pattern (CPP_track& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.pt.resize(0);
  else {
    C.pt.resize(3);
    for (unsigned int i = 0; i < C.pt.size(); i++)  {set_CPP_track_point_test_pattern(C.pt[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.ds_save = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.n_pt = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.n_bad = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 6 + offset; C.n_ok = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_track (Opaque_track_class* F, bool& c_ok) {

  CPP_track C, C2;

  c_ok = true;

  track_to_c (F, C);
  set_CPP_track_test_pattern (C2, 1);

  if (C == C2) {
    cout << " track: C side convert F->C: Good" << endl;
  } else {
    cout << " track: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_track_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_track (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_track_test_pattern (C, 3);
  if (C == C2) {
    cout << " track: F side convert F->C: Good" << endl;
  } else {
    cout << " track: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_track_test_pattern (C2, 4);
  track_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_space_charge_common (CPP_space_charge_common&, bool&);

void set_CPP_space_charge_common_test_pattern (CPP_space_charge_common& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.ds_track_step = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.dt_track_step = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.cathode_strength_cutoff = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.rel_tol_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.abs_tol_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.beam_chamber_height = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.sigma_cutoff = rhs;

  // c_side.test_pat[integer, 1, NOT]
  for (unsigned int i = 0; i < C.space_charge_mesh_size.size(); i++)
    {int rhs = 101 + i + 8 + offset; C.space_charge_mesh_size[i] = rhs;}
  // c_side.test_pat[integer, 1, NOT]
  for (unsigned int i = 0; i < C.csr3d_mesh_size.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.csr3d_mesh_size[i] = rhs;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 10 + offset; C.n_bin = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 11 + offset; C.particle_bin_span = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 12 + offset; C.n_shield_images = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 13 + offset; C.sc_min_in_bin = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 14 + offset; C.lsc_kick_transverse_dependence = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 15 + offset; C.debug = (rhs % 2 == 0);

  // c_side.test_pat[character, 0, NOT]
  C.diagnostic_output_file.resize(200);
  for (unsigned int i = 0; i < C.diagnostic_output_file.size(); i++)
    {int rhs = 101 + i + 16 + offset; C.diagnostic_output_file[i] = 'a' + rhs % 26;}

}

//--------------------------------------------------------------

extern "C" void test_c_space_charge_common (Opaque_space_charge_common_class* F, bool& c_ok) {

  CPP_space_charge_common C, C2;

  c_ok = true;

  space_charge_common_to_c (F, C);
  set_CPP_space_charge_common_test_pattern (C2, 1);

  if (C == C2) {
    cout << " space_charge_common: C side convert F->C: Good" << endl;
  } else {
    cout << " space_charge_common: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_space_charge_common_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_space_charge_common (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_space_charge_common_test_pattern (C, 3);
  if (C == C2) {
    cout << " space_charge_common: F side convert F->C: Good" << endl;
  } else {
    cout << " space_charge_common: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_space_charge_common_test_pattern (C2, 4);
  space_charge_common_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_bmad_common (CPP_bmad_common&, bool&);

void set_CPP_bmad_common_test_pattern (CPP_bmad_common& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.max_aperture_limit = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.d_orb.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.d_orb[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.default_ds_step = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.significant_length = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.rel_tol_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.abs_tol_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.rel_tol_adaptive_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.abs_tol_adaptive_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.init_ds_adaptive_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.min_ds_adaptive_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 11 + offset; C.fatal_ds_adaptive_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 12 + offset; C.autoscale_amp_abs_tol = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 13 + offset; C.autoscale_amp_rel_tol = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 14 + offset; C.autoscale_phase_tol = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 15 + offset; C.electric_dipole_moment = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 16 + offset; C.synch_rad_scale = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 17 + offset; C.sad_eps_scale = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 18 + offset; C.sad_amp_max = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 19 + offset; C.sad_n_div_max = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 20 + offset; C.taylor_order = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 21 + offset; C.runge_kutta_order = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 22 + offset; C.default_integ_order = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 23 + offset; C.max_num_runge_kutta_step = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 24 + offset; C.rf_phase_below_transition_ref = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 25 + offset; C.sr_wakes_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 26 + offset; C.lr_wakes_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 27 + offset; C.auto_bookkeeper = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 28 + offset; C.high_energy_space_charge_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 29 + offset; C.csr_and_space_charge_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 30 + offset; C.spin_tracking_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 31 + offset; C.backwards_time_tracking_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 32 + offset; C.spin_sokolov_ternov_flipping_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 33 + offset; C.radiation_damping_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 34 + offset; C.radiation_zero_average = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 35 + offset; C.radiation_fluctuations_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 36 + offset; C.conserve_taylor_maps = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 37 + offset; C.absolute_time_tracking = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 38 + offset; C.absolute_time_ref_shift = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 39 + offset; C.convert_to_kinetic_momentum = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 40 + offset; C.aperture_limit_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 41 + offset; C.debug = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_bmad_common (Opaque_bmad_common_class* F, bool& c_ok) {

  CPP_bmad_common C, C2;

  c_ok = true;

  bmad_common_to_c (F, C);
  set_CPP_bmad_common_test_pattern (C2, 1);

  if (C == C2) {
    cout << " bmad_common: C side convert F->C: Good" << endl;
  } else {
    cout << " bmad_common: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bmad_common_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_bmad_common (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_bmad_common_test_pattern (C, 3);
  if (C == C2) {
    cout << " bmad_common: F side convert F->C: Good" << endl;
  } else {
    cout << " bmad_common: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bmad_common_test_pattern (C2, 4);
  bmad_common_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_rad_int1 (CPP_rad_int1&, bool&);

void set_CPP_rad_int1_test_pattern (CPP_rad_int1& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.i0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.i1 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.i2 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.i3 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.i4a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.i4b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.i4z = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.i5a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.i5b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.i6b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 11 + offset; C.lin_i2_e4 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 12 + offset; C.lin_i3_e7 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 13 + offset; C.lin_i5a_e6 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 14 + offset; C.lin_i5b_e6 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 15 + offset; C.lin_norm_emit_a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 16 + offset; C.lin_norm_emit_b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 17 + offset; C.lin_sig_e = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 18 + offset; C.n_steps = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_rad_int1 (Opaque_rad_int1_class* F, bool& c_ok) {

  CPP_rad_int1 C, C2;

  c_ok = true;

  rad_int1_to_c (F, C);
  set_CPP_rad_int1_test_pattern (C2, 1);

  if (C == C2) {
    cout << " rad_int1: C side convert F->C: Good" << endl;
  } else {
    cout << " rad_int1: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int1_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_rad_int1 (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_rad_int1_test_pattern (C, 3);
  if (C == C2) {
    cout << " rad_int1: F side convert F->C: Good" << endl;
  } else {
    cout << " rad_int1: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int1_test_pattern (C2, 4);
  rad_int1_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_rad_int_branch (CPP_rad_int_branch&, bool&);

void set_CPP_rad_int_branch_test_pattern (CPP_rad_int_branch& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.ele.resize(0);
  else {
    C.ele.resize(3);
    for (unsigned int i = 0; i < C.ele.size(); i++)  {set_CPP_rad_int1_test_pattern(C.ele[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_rad_int_branch (Opaque_rad_int_branch_class* F, bool& c_ok) {

  CPP_rad_int_branch C, C2;

  c_ok = true;

  rad_int_branch_to_c (F, C);
  set_CPP_rad_int_branch_test_pattern (C2, 1);

  if (C == C2) {
    cout << " rad_int_branch: C side convert F->C: Good" << endl;
  } else {
    cout << " rad_int_branch: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int_branch_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_rad_int_branch (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_rad_int_branch_test_pattern (C, 3);
  if (C == C2) {
    cout << " rad_int_branch: F side convert F->C: Good" << endl;
  } else {
    cout << " rad_int_branch: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int_branch_test_pattern (C2, 4);
  rad_int_branch_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_rad_int_all_ele (CPP_rad_int_all_ele&, bool&);

void set_CPP_rad_int_all_ele_test_pattern (CPP_rad_int_all_ele& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.branch.resize(0);
  else {
    C.branch.resize(3);
    for (unsigned int i = 0; i < C.branch.size(); i++)  {set_CPP_rad_int_branch_test_pattern(C.branch[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_rad_int_all_ele (Opaque_rad_int_all_ele_class* F, bool& c_ok) {

  CPP_rad_int_all_ele C, C2;

  c_ok = true;

  rad_int_all_ele_to_c (F, C);
  set_CPP_rad_int_all_ele_test_pattern (C2, 1);

  if (C == C2) {
    cout << " rad_int_all_ele: C side convert F->C: Good" << endl;
  } else {
    cout << " rad_int_all_ele: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int_all_ele_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_rad_int_all_ele (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_rad_int_all_ele_test_pattern (C, 3);
  if (C == C2) {
    cout << " rad_int_all_ele: F side convert F->C: Good" << endl;
  } else {
    cout << " rad_int_all_ele: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int_all_ele_test_pattern (C2, 4);
  rad_int_all_ele_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_ele (CPP_ele&, bool&);

void set_CPP_ele_test_pattern (CPP_ele& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.type.resize(40);
  for (unsigned int i = 0; i < C.type.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.type[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.alias.resize(40);
  for (unsigned int i = 0; i < C.alias.size(); i++)
    {int rhs = 101 + i + 3 + offset; C.alias[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.component_name.resize(40);
  for (unsigned int i = 0; i < C.component_name.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.component_name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, PTR]
  if (ix_patt < 3) 
    C.descrip == NULL;
  else {
    C.descrip = new string(200, ' ');
    for (unsigned int i = 0; i < C.descrip->size(); i++) {
      (*C.descrip)[i] = 'a' + (101 + i + 5 + offset) % 26; }
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.a, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.b, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.z, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_xy_disp_test_pattern(C.x, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_xy_disp_test_pattern(C.y, ix_patt);

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.ac_kick = NULL;
  else {
    C.ac_kick = new CPP_ac_kicker;
    set_CPP_ac_kicker_test_pattern((*C.ac_kick), ix_patt);
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_bookkeeping_state_test_pattern(C.bookkeeping_state, ix_patt);

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.control = NULL;
  else {
    C.control = new CPP_controller;
    set_CPP_controller_test_pattern((*C.control), ix_patt);
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_floor_position_test_pattern(C.floor, ix_patt);

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.high_energy_space_charge = NULL;
  else {
    C.high_energy_space_charge = new CPP_high_energy_space_charge;
    set_CPP_high_energy_space_charge_test_pattern((*C.high_energy_space_charge), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.mode3 = NULL;
  else {
    C.mode3 = new CPP_mode3;
    set_CPP_mode3_test_pattern((*C.mode3), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.photon = NULL;
  else {
    C.photon = new CPP_photon_element;
    set_CPP_photon_element_test_pattern((*C.photon), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.rad_map = NULL;
  else {
    C.rad_map = new CPP_rad_map_ele;
    set_CPP_rad_map_ele_test_pattern((*C.rad_map), ix_patt);
  }

  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.taylor.size(); i++)
    {int rhs = 101 + i + 26 + offset; set_CPP_taylor_test_pattern(C.taylor[i], ix_patt+i+1);}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.spin_taylor_ref_orb_in.size(); i++)
    {int rhs = 101 + i + 27 + offset; C.spin_taylor_ref_orb_in[i] = rhs;}
  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.spin_taylor.size(); i++)
    {int rhs = 101 + i + 28 + offset; set_CPP_taylor_test_pattern(C.spin_taylor[i], ix_patt+i+1);}
  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.wake = NULL;
  else {
    C.wake = new CPP_wake;
    set_CPP_wake_test_pattern((*C.wake), ix_patt);
  }

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.wall3d.resize(0);
  else {
    C.wall3d.resize(3);
    for (unsigned int i = 0; i < C.wall3d.size(); i++)  {set_CPP_wall3d_test_pattern(C.wall3d[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.cartesian_map.resize(0);
  else {
    C.cartesian_map.resize(3);
    for (unsigned int i = 0; i < C.cartesian_map.size(); i++)  {set_CPP_cartesian_map_test_pattern(C.cartesian_map[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.cylindrical_map.resize(0);
  else {
    C.cylindrical_map.resize(3);
    for (unsigned int i = 0; i < C.cylindrical_map.size(); i++)  {set_CPP_cylindrical_map_test_pattern(C.cylindrical_map[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.gen_grad_map.resize(0);
  else {
    C.gen_grad_map.resize(3);
    for (unsigned int i = 0; i < C.gen_grad_map.size(); i++)  {set_CPP_gen_grad_map_test_pattern(C.gen_grad_map[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.grid_field.resize(0);
  else {
    C.grid_field.resize(3);
    for (unsigned int i = 0; i < C.grid_field.size(); i++)  {set_CPP_grid_field_test_pattern(C.grid_field[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.map_ref_orb_in, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.map_ref_orb_out, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.time_ref_orb_in, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.time_ref_orb_out, ix_patt);

  // c_side.test_pat[real, 1, NOT]
  C.value[0] = 0;
  for (unsigned int i = 1; i < Bmad::NUM_ELE_ATTRIB+1; i++)
    {int rhs = 100 + i + 45 + offset; C.value[i] = rhs;}

  // c_side.test_pat[real, 1, NOT]
  C.old_value[0] = 0;
  for (unsigned int i = 1; i < Bmad::NUM_ELE_ATTRIB+1; i++)
    {int rhs = 100 + i + 46 + offset; C.old_value[i] = rhs;}

  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.spin_q.size(); i++)  for (unsigned int j = 0; j < C.spin_q[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 47 + offset; C.spin_q[i][j] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.vec0.size(); i++)
    {int rhs = 101 + i + 48 + offset; C.vec0[i] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.mat6.size(); i++)  for (unsigned int j = 0; j < C.mat6[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 49 + offset; C.mat6[i][j] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.c_mat.size(); i++)  for (unsigned int j = 0; j < C.c_mat[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 50 + offset; C.c_mat[i][j] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 51 + offset; C.gamma_c = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 52 + offset; C.s_start = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 53 + offset; C.s = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 54 + offset; C.ref_time = rhs;

  // c_side.test_pat[real, 1, PTR]
  if (ix_patt < 3) 
    C.a_pole.resize(0);
  else {
    C.a_pole.resize(3);
    for (unsigned int i = 0; i < C.a_pole.size(); i++)
      {int rhs = 101 + i + 55 + offset; C.a_pole[i] = rhs;}  }

  // c_side.test_pat[real, 1, PTR]
  if (ix_patt < 3) 
    C.b_pole.resize(0);
  else {
    C.b_pole.resize(3);
    for (unsigned int i = 0; i < C.b_pole.size(); i++)
      {int rhs = 101 + i + 57 + offset; C.b_pole[i] = rhs;}  }

  // c_side.test_pat[real, 1, PTR]
  if (ix_patt < 3) 
    C.a_pole_elec.resize(0);
  else {
    C.a_pole_elec.resize(3);
    for (unsigned int i = 0; i < C.a_pole_elec.size(); i++)
      {int rhs = 101 + i + 59 + offset; C.a_pole_elec[i] = rhs;}  }

  // c_side.test_pat[real, 1, PTR]
  if (ix_patt < 3) 
    C.b_pole_elec.resize(0);
  else {
    C.b_pole_elec.resize(3);
    for (unsigned int i = 0; i < C.b_pole_elec.size(); i++)
      {int rhs = 101 + i + 61 + offset; C.b_pole_elec[i] = rhs;}  }

  // c_side.test_pat[real, 1, PTR]
  if (ix_patt < 3) 
    C.custom.resize(0);
  else {
    C.custom.resize(3);
    for (unsigned int i = 0; i < C.custom.size(); i++)
      {int rhs = 101 + i + 63 + offset; C.custom[i] = rhs;}  }

  // c_side.test_pat[real, 3, PTR]
  if (ix_patt < 3) 
    C.r.resize(0);
  else {
    C.r.resize(3);
    for (unsigned int i = 0; i < C.r.size(); i++) {
      C.r[i].resize(2);
      for (unsigned int j = 0; j < C.r[0].size(); j++) {
        C.r[i][j].resize(1);
        for (unsigned int k = 0; k < C.r[0][0].size(); k++) {
          int rhs = 101 + i + 10*(j+1) + 100*(k+1) + 65 + offset; C.r[i][j][k] = rhs;
        }
      }
    }
  }

  // c_side.test_pat[integer, 0, NOT]
  rhs = 69 + offset; C.key = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 70 + offset; C.sub_key = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 71 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 72 + offset; C.ix_branch = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 73 + offset; C.lord_status = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 74 + offset; C.n_slave = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 75 + offset; C.n_slave_field = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 76 + offset; C.ix1_slave = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 77 + offset; C.slave_status = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 78 + offset; C.n_lord = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 79 + offset; C.n_lord_field = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 80 + offset; C.ic1_lord = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 81 + offset; C.ix_pointer = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 82 + offset; C.ixx = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 83 + offset; C.iyy = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 84 + offset; C.izz = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 85 + offset; C.mat6_calc_method = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 86 + offset; C.tracking_method = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 87 + offset; C.spin_tracking_method = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 88 + offset; C.csr_method = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 89 + offset; C.space_charge_method = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 90 + offset; C.ptc_integration_type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 91 + offset; C.field_calc = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 92 + offset; C.aperture_at = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 93 + offset; C.aperture_type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 94 + offset; C.ref_species = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 95 + offset; C.orientation = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 96 + offset; C.symplectify = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 97 + offset; C.mode_flip = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 98 + offset; C.multipoles_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 99 + offset; C.scale_multipoles = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 100 + offset; C.taylor_map_includes_offsets = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 101 + offset; C.field_master = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 102 + offset; C.is_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 103 + offset; C.logic = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 104 + offset; C.bmad_logic = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 105 + offset; C.select = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 106 + offset; C.offset_moves_aperture = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_ele (Opaque_ele_class* F, bool& c_ok) {

  CPP_ele C, C2;

  c_ok = true;

  ele_to_c (F, C);
  set_CPP_ele_test_pattern (C2, 1);

  if (C == C2) {
    cout << " ele: C side convert F->C: Good" << endl;
  } else {
    cout << " ele: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ele_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_ele (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_ele_test_pattern (C, 3);
  if (C == C2) {
    cout << " ele: F side convert F->C: Good" << endl;
  } else {
    cout << " ele: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ele_test_pattern (C2, 4);
  ele_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_complex_taylor_term (CPP_complex_taylor_term&, bool&);

void set_CPP_complex_taylor_term_test_pattern (CPP_complex_taylor_term& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[complex, 0, NOT]
  rhs = 1 + offset; C.coef = Complex(rhs, 100+rhs);

  // c_side.test_pat[integer, 1, NOT]
  for (unsigned int i = 0; i < C.expn.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.expn[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_complex_taylor_term (Opaque_complex_taylor_term_class* F, bool& c_ok) {

  CPP_complex_taylor_term C, C2;

  c_ok = true;

  complex_taylor_term_to_c (F, C);
  set_CPP_complex_taylor_term_test_pattern (C2, 1);

  if (C == C2) {
    cout << " complex_taylor_term: C side convert F->C: Good" << endl;
  } else {
    cout << " complex_taylor_term: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_complex_taylor_term_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_complex_taylor_term (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_complex_taylor_term_test_pattern (C, 3);
  if (C == C2) {
    cout << " complex_taylor_term: F side convert F->C: Good" << endl;
  } else {
    cout << " complex_taylor_term: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_complex_taylor_term_test_pattern (C2, 4);
  complex_taylor_term_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_complex_taylor (CPP_complex_taylor&, bool&);

void set_CPP_complex_taylor_test_pattern (CPP_complex_taylor& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[complex, 0, NOT]
  rhs = 1 + offset; C.ref = Complex(rhs, 100+rhs);

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.term.resize(0);
  else {
    C.term.resize(3);
    for (unsigned int i = 0; i < C.term.size(); i++)  {set_CPP_complex_taylor_term_test_pattern(C.term[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_complex_taylor (Opaque_complex_taylor_class* F, bool& c_ok) {

  CPP_complex_taylor C, C2;

  c_ok = true;

  complex_taylor_to_c (F, C);
  set_CPP_complex_taylor_test_pattern (C2, 1);

  if (C == C2) {
    cout << " complex_taylor: C side convert F->C: Good" << endl;
  } else {
    cout << " complex_taylor: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_complex_taylor_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_complex_taylor (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_complex_taylor_test_pattern (C, 3);
  if (C == C2) {
    cout << " complex_taylor: F side convert F->C: Good" << endl;
  } else {
    cout << " complex_taylor: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_complex_taylor_test_pattern (C2, 4);
  complex_taylor_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_branch (CPP_branch&, bool&);

void set_CPP_branch_test_pattern (CPP_branch& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.ix_branch = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.ix_from_branch = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.ix_from_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.ix_to_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 6 + offset; C.n_ele_track = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.n_ele_max = rhs;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_mode_info_test_pattern(C.a, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_mode_info_test_pattern(C.b, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_mode_info_test_pattern(C.z, ix_patt);

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.ele.resize(0);
  else {
    C.ele.resize(3);
    for (unsigned int i = 0; i < C.ele.size(); i++)  {set_CPP_ele_test_pattern(C.ele[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_lat_param_test_pattern(C.param, ix_patt);

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.wall3d.resize(0);
  else {
    C.wall3d.resize(3);
    for (unsigned int i = 0; i < C.wall3d.size(); i++)  {set_CPP_wall3d_test_pattern(C.wall3d[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_branch (Opaque_branch_class* F, bool& c_ok) {

  CPP_branch C, C2;

  c_ok = true;

  branch_to_c (F, C);
  set_CPP_branch_test_pattern (C2, 1);

  if (C == C2) {
    cout << " branch: C side convert F->C: Good" << endl;
  } else {
    cout << " branch: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_branch_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_branch (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_branch_test_pattern (C, 3);
  if (C == C2) {
    cout << " branch: F side convert F->C: Good" << endl;
  } else {
    cout << " branch: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_branch_test_pattern (C2, 4);
  branch_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_lat (CPP_lat&, bool&);

void set_CPP_lat_test_pattern (CPP_lat& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.use_name.resize(200);
  for (unsigned int i = 0; i < C.use_name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.use_name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.lattice.resize(40);
  for (unsigned int i = 0; i < C.lattice.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.lattice[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.machine.resize(40);
  for (unsigned int i = 0; i < C.machine.size(); i++)
    {int rhs = 101 + i + 3 + offset; C.machine[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.input_file_name.resize(200);
  for (unsigned int i = 0; i < C.input_file_name.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.input_file_name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.title.resize(80);
  for (unsigned int i = 0; i < C.title.size(); i++)
    {int rhs = 101 + i + 5 + offset; C.title[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 1, ALLOC]
  if (ix_patt < 3) 
    C.print_str.resize(0);
  else {
    C.print_str.resize(3);
    for (unsigned int i = 0; i < C.print_str.size(); i++){
      C.print_str[i].resize(100);
      for (unsigned int j = 0; j < C.print_str[0].size(); j++) {
        C.print_str[i][j] = 'a' + (101 + i + 10*(j+1) + 6 + offset) % 26;
    } }
  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.constant.resize(0);
  else {
    C.constant.resize(3);
    for (unsigned int i = 0; i < C.constant.size(); i++)  {set_CPP_expression_atom_test_pattern(C.constant[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.a = NULL;
  else {
    C.a = new CPP_mode_info;
    set_CPP_mode_info_test_pattern((*C.a), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.b = NULL;
  else {
    C.b = new CPP_mode_info;
    set_CPP_mode_info_test_pattern((*C.b), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.z = NULL;
  else {
    C.z = new CPP_mode_info;
    set_CPP_mode_info_test_pattern((*C.z), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.param = NULL;
  else {
    C.param = new CPP_lat_param;
    set_CPP_lat_param_test_pattern((*C.param), ix_patt);
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_bookkeeping_state_test_pattern(C.lord_state, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_ele_test_pattern(C.ele_init, ix_patt);

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.ele.resize(0);
  else {
    C.ele.resize(3);
    for (unsigned int i = 0; i < C.ele.size(); i++)  {set_CPP_ele_test_pattern(C.ele[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.branch.resize(0);
  else {
    C.branch.resize(3);
    for (unsigned int i = 0; i < C.branch.size(); i++)  {set_CPP_branch_test_pattern(C.branch[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.control.resize(0);
  else {
    C.control.resize(3);
    for (unsigned int i = 0; i < C.control.size(); i++)  {set_CPP_control_test_pattern(C.control[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.particle_start, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_beam_init_test_pattern(C.beam_init, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_pre_tracker_test_pattern(C.pre_tracker, ix_patt);

  // c_side.test_pat[real, 1, ALLOC]
  if (ix_patt < 3) 
    C.custom.resize(0);
  else {
    C.custom.resize(3);
    for (unsigned int i = 0; i < C.custom.size(); i++)
      {int rhs = 101 + i + 29 + offset; C.custom[i] = rhs;}  }

  // c_side.test_pat[integer, 0, NOT]
  rhs = 31 + offset; C.version = rhs;

  // c_side.test_pat[integer, 0, PTR]
  if (ix_patt < 3) 
    C.n_ele_track = NULL;
  else {
    C.n_ele_track = new Int;
    rhs = 32 + offset; (*C.n_ele_track) = rhs;
  }

  // c_side.test_pat[integer, 0, PTR]
  if (ix_patt < 3) 
    C.n_ele_max = NULL;
  else {
    C.n_ele_max = new Int;
    rhs = 34 + offset; (*C.n_ele_max) = rhs;
  }

  // c_side.test_pat[integer, 0, NOT]
  rhs = 36 + offset; C.n_control_max = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 37 + offset; C.n_ic_max = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 38 + offset; C.input_taylor_order = rhs;

  // c_side.test_pat[integer, 1, ALLOC]
  if (ix_patt < 3) 
    C.ic.resize(0);
  else {
    C.ic.resize(3);
    for (unsigned int i = 0; i < C.ic.size(); i++)
      {int rhs = 101 + i + 39 + offset; C.ic[i] = rhs;}  }

  // c_side.test_pat[integer, 0, NOT]
  rhs = 41 + offset; C.photon_type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 42 + offset; C.creation_hash = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_lat (Opaque_lat_class* F, bool& c_ok) {

  CPP_lat C, C2;

  c_ok = true;

  lat_to_c (F, C);
  set_CPP_lat_test_pattern (C2, 1);

  if (C == C2) {
    cout << " lat: C side convert F->C: Good" << endl;
  } else {
    cout << " lat: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_lat (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_lat_test_pattern (C, 3);
  if (C == C2) {
    cout << " lat: F side convert F->C: Good" << endl;
  } else {
    cout << " lat: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_test_pattern (C2, 4);
  lat_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_bunch (CPP_bunch&, bool&);

void set_CPP_bunch_test_pattern (CPP_bunch& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.particle.resize(0);
  else {
    C.particle.resize(3);
    for (unsigned int i = 0; i < C.particle.size(); i++)  {set_CPP_coord_test_pattern(C.particle[i], ix_patt+i+1);}
  }

  // c_side.test_pat[integer, 1, ALLOC]
  if (ix_patt < 3) 
    C.ix_z.resize(0);
  else {
    C.ix_z.resize(3);
    for (unsigned int i = 0; i < C.ix_z.size(); i++)
      {int rhs = 101 + i + 3 + offset; C.ix_z[i] = rhs;}  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.charge_tot = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.charge_live = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.z_center = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.t_center = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.t0 = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 10 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 11 + offset; C.ix_bunch = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 12 + offset; C.ix_turn = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 13 + offset; C.n_live = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 14 + offset; C.n_good = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 15 + offset; C.n_bad = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_bunch (Opaque_bunch_class* F, bool& c_ok) {

  CPP_bunch C, C2;

  c_ok = true;

  bunch_to_c (F, C);
  set_CPP_bunch_test_pattern (C2, 1);

  if (C == C2) {
    cout << " bunch: C side convert F->C: Good" << endl;
  } else {
    cout << " bunch: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bunch_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_bunch (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_bunch_test_pattern (C, 3);
  if (C == C2) {
    cout << " bunch: F side convert F->C: Good" << endl;
  } else {
    cout << " bunch: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bunch_test_pattern (C2, 4);
  bunch_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_bunch_params (CPP_bunch_params&, bool&);

void set_CPP_bunch_params_test_pattern (CPP_bunch_params& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.centroid, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.x, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.y, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.z, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.a, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.b, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.c, ix_patt);

  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.sigma.size(); i++)  for (unsigned int j = 0; j < C.sigma[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 8 + offset; C.sigma[i][j] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.rel_max.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.rel_max[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.rel_min.size(); i++)
    {int rhs = 101 + i + 10 + offset; C.rel_min[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 11 + offset; C.s = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 12 + offset; C.t = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 13 + offset; C.charge_live = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 14 + offset; C.charge_tot = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 15 + offset; C.n_particle_tot = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 16 + offset; C.n_particle_live = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 17 + offset; C.n_particle_lost_in_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 18 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 19 + offset; C.location = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 20 + offset; C.twiss_valid = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_bunch_params (Opaque_bunch_params_class* F, bool& c_ok) {

  CPP_bunch_params C, C2;

  c_ok = true;

  bunch_params_to_c (F, C);
  set_CPP_bunch_params_test_pattern (C2, 1);

  if (C == C2) {
    cout << " bunch_params: C side convert F->C: Good" << endl;
  } else {
    cout << " bunch_params: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bunch_params_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_bunch_params (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_bunch_params_test_pattern (C, 3);
  if (C == C2) {
    cout << " bunch_params: F side convert F->C: Good" << endl;
  } else {
    cout << " bunch_params: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bunch_params_test_pattern (C2, 4);
  bunch_params_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_beam (CPP_beam&, bool&);

void set_CPP_beam_test_pattern (CPP_beam& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.bunch.resize(0);
  else {
    C.bunch.resize(3);
    for (unsigned int i = 0; i < C.bunch.size(); i++)  {set_CPP_bunch_test_pattern(C.bunch[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_beam (Opaque_beam_class* F, bool& c_ok) {

  CPP_beam C, C2;

  c_ok = true;

  beam_to_c (F, C);
  set_CPP_beam_test_pattern (C2, 1);

  if (C == C2) {
    cout << " beam: C side convert F->C: Good" << endl;
  } else {
    cout << " beam: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_beam_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_beam (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_beam_test_pattern (C, 3);
  if (C == C2) {
    cout << " beam: F side convert F->C: Good" << endl;
  } else {
    cout << " beam: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_beam_test_pattern (C2, 4);
  beam_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_aperture_point (CPP_aperture_point&, bool&);

void set_CPP_aperture_point_test_pattern (CPP_aperture_point& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.x = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.y = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.plane = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.i_turn = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_aperture_point (Opaque_aperture_point_class* F, bool& c_ok) {

  CPP_aperture_point C, C2;

  c_ok = true;

  aperture_point_to_c (F, C);
  set_CPP_aperture_point_test_pattern (C2, 1);

  if (C == C2) {
    cout << " aperture_point: C side convert F->C: Good" << endl;
  } else {
    cout << " aperture_point: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_aperture_point_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_aperture_point (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_aperture_point_test_pattern (C, 3);
  if (C == C2) {
    cout << " aperture_point: F side convert F->C: Good" << endl;
  } else {
    cout << " aperture_point: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_aperture_point_test_pattern (C2, 4);
  aperture_point_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_aperture_param (CPP_aperture_param&, bool&);

void set_CPP_aperture_param_test_pattern (CPP_aperture_param& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.min_angle = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.max_angle = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.n_angle = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.n_turn = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.x_init = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.y_init = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.rel_accuracy = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.abs_accuracy = rhs;

  // c_side.test_pat[character, 0, NOT]
  C.start_ele.resize(40);
  for (unsigned int i = 0; i < C.start_ele.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.start_ele[i] = 'a' + rhs % 26;}

}

//--------------------------------------------------------------

extern "C" void test_c_aperture_param (Opaque_aperture_param_class* F, bool& c_ok) {

  CPP_aperture_param C, C2;

  c_ok = true;

  aperture_param_to_c (F, C);
  set_CPP_aperture_param_test_pattern (C2, 1);

  if (C == C2) {
    cout << " aperture_param: C side convert F->C: Good" << endl;
  } else {
    cout << " aperture_param: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_aperture_param_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_aperture_param (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_aperture_param_test_pattern (C, 3);
  if (C == C2) {
    cout << " aperture_param: F side convert F->C: Good" << endl;
  } else {
    cout << " aperture_param: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_aperture_param_test_pattern (C2, 4);
  aperture_param_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_aperture_scan (CPP_aperture_scan&, bool&);

void set_CPP_aperture_scan_test_pattern (CPP_aperture_scan& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.point.resize(0);
  else {
    C.point.resize(3);
    for (unsigned int i = 0; i < C.point.size(); i++)  {set_CPP_aperture_point_test_pattern(C.point[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.ref_orb, ix_patt);

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.pz_start = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_aperture_scan (Opaque_aperture_scan_class* F, bool& c_ok) {

  CPP_aperture_scan C, C2;

  c_ok = true;

  aperture_scan_to_c (F, C);
  set_CPP_aperture_scan_test_pattern (C2, 1);

  if (C == C2) {
    cout << " aperture_scan: C side convert F->C: Good" << endl;
  } else {
    cout << " aperture_scan: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_aperture_scan_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_aperture_scan (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_aperture_scan_test_pattern (C, 3);
  if (C == C2) {
    cout << " aperture_scan: F side convert F->C: Good" << endl;
  } else {
    cout << " aperture_scan: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_aperture_scan_test_pattern (C2, 4);
  aperture_scan_to_f (C2, F);

}
