
//+
// C++ classes definitions for Bmad / C++ structure interface.
//
// This file is generated as part of the Bmad/C++ interface code generation.
// The code generation files can be found in cpp_bmad_interface.
//
// DO NOT EDIT THIS FILE DIRECTLY! 
//-

#include <stdio.h>
#include <iostream>
#include "cpp_bmad_classes.h"

using namespace std;

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_surface_orientation (CPP_surface_orientation&, bool&);

void set_CPP_surface_orientation_test_pattern (CPP_surface_orientation& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.x_pitch = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.y_pitch = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.x_pitch_rms = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.y_pitch_rms = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_surface_orientation (Bmad_surface_orientation_class* F, bool& c_ok) {

  CPP_surface_orientation C, C2;

  c_ok = true;

  surface_orientation_to_c (F, C);
  set_CPP_surface_orientation_test_pattern (C2, 1);

  if (C == C2) {
    cout << " surface_orientation: C side convert F->C: Good" << endl;
  } else {
    cout << " surface_orientation: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_orientation_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_surface_orientation (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_surface_orientation_test_pattern (C, 3);
  if (C == C2) {
    cout << " surface_orientation: F side convert F->C: Good" << endl;
  } else {
    cout << " surface_orientation: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_orientation_test_pattern (C2, 4);
  surface_orientation_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_interval1_coef (CPP_interval1_coef&, bool&);

void set_CPP_interval1_coef_test_pattern (CPP_interval1_coef& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.c0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.c1 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.n_exp = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_interval1_coef (Bmad_interval1_coef_class* F, bool& c_ok) {

  CPP_interval1_coef C, C2;

  c_ok = true;

  interval1_coef_to_c (F, C);
  set_CPP_interval1_coef_test_pattern (C2, 1);

  if (C == C2) {
    cout << " interval1_coef: C side convert F->C: Good" << endl;
  } else {
    cout << " interval1_coef: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_interval1_coef_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_interval1_coef (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_interval1_coef_test_pattern (C, 3);
  if (C == C2) {
    cout << " interval1_coef: F side convert F->C: Good" << endl;
  } else {
    cout << " interval1_coef: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_interval1_coef_test_pattern (C2, 4);
  interval1_coef_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_reflect_table (CPP_photon_reflect_table&, bool&);

void set_CPP_photon_reflect_table_test_pattern (CPP_photon_reflect_table& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, ALLOC]
  if (ix_patt < 3) 
    C.angle.resize(0);
  else {
    C.angle.resize(3);
    for (unsigned int i = 0; i < C.angle.size(); i++)
      {int rhs = 101 + i + 1 + offset; C.angle[i] = rhs;}  }

  // c_side.test_pat[real, 1, ALLOC]
  if (ix_patt < 3) 
    C.energy.resize(0);
  else {
    C.energy.resize(3);
    for (unsigned int i = 0; i < C.energy.size(); i++)
      {int rhs = 101 + i + 3 + offset; C.energy[i] = rhs;}  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.int1.resize(0);
  else {
    C.int1.resize(3);
    for (unsigned int i = 0; i < C.int1.size(); i++)  {set_CPP_interval1_coef_test_pattern(C.int1[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 2, ALLOC]
  if (ix_patt < 3) 
    C.p_reflect.resize(0);
  else {
    C.p_reflect.resize(3);
    for (unsigned int i = 0; i < C.p_reflect.size(); i++)
      C.p_reflect[i].resize(2);
    for (unsigned int i = 0; i < C.p_reflect.size(); i++)  for (unsigned int j = 0; j < C.p_reflect[0].size(); j++) 
      {int rhs = 101 + i + 10*(j+1) + 7 + offset; C.p_reflect[i][j] = rhs;}  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.max_energy = rhs;

  // c_side.test_pat[real, 1, ALLOC]
  if (ix_patt < 3) 
    C.p_reflect_scratch.resize(0);
  else {
    C.p_reflect_scratch.resize(3);
    for (unsigned int i = 0; i < C.p_reflect_scratch.size(); i++)
      {int rhs = 101 + i + 11 + offset; C.p_reflect_scratch[i] = rhs;}  }


}

//--------------------------------------------------------------

extern "C" void test_c_photon_reflect_table (Bmad_photon_reflect_table_class* F, bool& c_ok) {

  CPP_photon_reflect_table C, C2;

  c_ok = true;

  photon_reflect_table_to_c (F, C);
  set_CPP_photon_reflect_table_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_reflect_table: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_reflect_table: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_reflect_table_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_reflect_table (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_reflect_table_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_reflect_table: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_reflect_table: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_reflect_table_test_pattern (C2, 4);
  photon_reflect_table_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_reflect_surface (CPP_photon_reflect_surface&, bool&);

void set_CPP_photon_reflect_surface_test_pattern (CPP_photon_reflect_surface& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.descrip.resize(40);
  for (unsigned int i = 0; i < C.descrip.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.descrip[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.reflectivity_file.resize(200);
  for (unsigned int i = 0; i < C.reflectivity_file.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.reflectivity_file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.table.resize(0);
  else {
    C.table.resize(3);
    for (unsigned int i = 0; i < C.table.size(); i++)  {set_CPP_photon_reflect_table_test_pattern(C.table[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.surface_roughness_rms = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.roughness_correlation_len = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 7 + offset; C.initialized = (rhs % 2 == 0);

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.ix_surface = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_photon_reflect_surface (Bmad_photon_reflect_surface_class* F, bool& c_ok) {

  CPP_photon_reflect_surface C, C2;

  c_ok = true;

  photon_reflect_surface_to_c (F, C);
  set_CPP_photon_reflect_surface_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_reflect_surface: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_reflect_surface: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_reflect_surface_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_reflect_surface (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_reflect_surface_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_reflect_surface: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_reflect_surface: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_reflect_surface_test_pattern (C2, 4);
  photon_reflect_surface_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_controller_var (CPP_controller_var&, bool&);

void set_CPP_controller_var_test_pattern (CPP_controller_var& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.value = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.old_value = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_controller_var (Bmad_controller_var_class* F, bool& c_ok) {

  CPP_controller_var C, C2;

  c_ok = true;

  controller_var_to_c (F, C);
  set_CPP_controller_var_test_pattern (C2, 1);

  if (C == C2) {
    cout << " controller_var: C side convert F->C: Good" << endl;
  } else {
    cout << " controller_var: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_controller_var_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_controller_var (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_controller_var_test_pattern (C, 3);
  if (C == C2) {
    cout << " controller_var: F side convert F->C: Good" << endl;
  } else {
    cout << " controller_var: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_controller_var_test_pattern (C2, 4);
  controller_var_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_coord (CPP_coord&, bool&);

void set_CPP_coord_test_pattern (CPP_coord& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.vec.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.vec[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.s = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.t = rhs;

  // c_side.test_pat[complex, 1, NOT]
  for (unsigned int i = 0; i < C.spin.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.spin[i] = Complex(rhs, 100+rhs);}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.field.size(); i++)
    {int rhs = 101 + i + 5 + offset; C.field[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.phase.size(); i++)
    {int rhs = 101 + i + 6 + offset; C.phase[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.charge = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.path_len = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.p0c = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.beta = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 11 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 12 + offset; C.state = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 13 + offset; C.direction = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 14 + offset; C.species = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 15 + offset; C.location = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_coord (Bmad_coord_class* F, bool& c_ok) {

  CPP_coord C, C2;

  c_ok = true;

  coord_to_c (F, C);
  set_CPP_coord_test_pattern (C2, 1);

  if (C == C2) {
    cout << " coord: C side convert F->C: Good" << endl;
  } else {
    cout << " coord: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_coord_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_coord (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_coord_test_pattern (C, 3);
  if (C == C2) {
    cout << " coord: F side convert F->C: Good" << endl;
  } else {
    cout << " coord: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_coord_test_pattern (C2, 4);
  coord_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_coord_array (CPP_coord_array&, bool&);

void set_CPP_coord_array_test_pattern (CPP_coord_array& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.orbit.resize(0);
  else {
    C.orbit.resize(3);
    for (unsigned int i = 0; i < C.orbit.size(); i++)  {set_CPP_coord_test_pattern(C.orbit[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_coord_array (Bmad_coord_array_class* F, bool& c_ok) {

  CPP_coord_array C, C2;

  c_ok = true;

  coord_array_to_c (F, C);
  set_CPP_coord_array_test_pattern (C2, 1);

  if (C == C2) {
    cout << " coord_array: C side convert F->C: Good" << endl;
  } else {
    cout << " coord_array: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_coord_array_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_coord_array (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_coord_array_test_pattern (C, 3);
  if (C == C2) {
    cout << " coord_array: F side convert F->C: Good" << endl;
  } else {
    cout << " coord_array: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_coord_array_test_pattern (C2, 4);
  coord_array_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_bpm_phase_coupling (CPP_bpm_phase_coupling&, bool&);

void set_CPP_bpm_phase_coupling_test_pattern (CPP_bpm_phase_coupling& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.k_22a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.k_12a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.k_11b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.k_12b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.cbar22_a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.cbar12_a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.cbar11_b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.cbar12_b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.phi_a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.phi_b = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_bpm_phase_coupling (Bmad_bpm_phase_coupling_class* F, bool& c_ok) {

  CPP_bpm_phase_coupling C, C2;

  c_ok = true;

  bpm_phase_coupling_to_c (F, C);
  set_CPP_bpm_phase_coupling_test_pattern (C2, 1);

  if (C == C2) {
    cout << " bpm_phase_coupling: C side convert F->C: Good" << endl;
  } else {
    cout << " bpm_phase_coupling: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bpm_phase_coupling_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_bpm_phase_coupling (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_bpm_phase_coupling_test_pattern (C, 3);
  if (C == C2) {
    cout << " bpm_phase_coupling: F side convert F->C: Good" << endl;
  } else {
    cout << " bpm_phase_coupling: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bpm_phase_coupling_test_pattern (C2, 4);
  bpm_phase_coupling_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_expression_atom (CPP_expression_atom&, bool&);

void set_CPP_expression_atom_test_pattern (CPP_expression_atom& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.type = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.value = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_expression_atom (Bmad_expression_atom_class* F, bool& c_ok) {

  CPP_expression_atom C, C2;

  c_ok = true;

  expression_atom_to_c (F, C);
  set_CPP_expression_atom_test_pattern (C2, 1);

  if (C == C2) {
    cout << " expression_atom: C side convert F->C: Good" << endl;
  } else {
    cout << " expression_atom: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_expression_atom_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_expression_atom (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_expression_atom_test_pattern (C, 3);
  if (C == C2) {
    cout << " expression_atom: F side convert F->C: Good" << endl;
  } else {
    cout << " expression_atom: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_expression_atom_test_pattern (C2, 4);
  expression_atom_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wake_sr_mode (CPP_wake_sr_mode&, bool&);

void set_CPP_wake_sr_mode_test_pattern (CPP_wake_sr_mode& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.amp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.damp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.k = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.b_sin = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.b_cos = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.a_sin = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.a_cos = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.polarization = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 10 + offset; C.transverse_dependence = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_wake_sr_mode (Bmad_wake_sr_mode_class* F, bool& c_ok) {

  CPP_wake_sr_mode C, C2;

  c_ok = true;

  wake_sr_mode_to_c (F, C);
  set_CPP_wake_sr_mode_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wake_sr_mode: C side convert F->C: Good" << endl;
  } else {
    cout << " wake_sr_mode: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_sr_mode_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wake_sr_mode (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wake_sr_mode_test_pattern (C, 3);
  if (C == C2) {
    cout << " wake_sr_mode: F side convert F->C: Good" << endl;
  } else {
    cout << " wake_sr_mode: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_sr_mode_test_pattern (C2, 4);
  wake_sr_mode_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wake_sr (CPP_wake_sr&, bool&);

void set_CPP_wake_sr_test_pattern (CPP_wake_sr& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.mode.resize(0);
  else {
    C.mode.resize(3);
    for (unsigned int i = 0; i < C.mode.size(); i++)  {set_CPP_wake_sr_mode_test_pattern(C.mode[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.z_ref = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_wake_sr (Bmad_wake_sr_class* F, bool& c_ok) {

  CPP_wake_sr C, C2;

  c_ok = true;

  wake_sr_to_c (F, C);
  set_CPP_wake_sr_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wake_sr: C side convert F->C: Good" << endl;
  } else {
    cout << " wake_sr: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_sr_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wake_sr (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wake_sr_test_pattern (C, 3);
  if (C == C2) {
    cout << " wake_sr: F side convert F->C: Good" << endl;
  } else {
    cout << " wake_sr: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_sr_test_pattern (C2, 4);
  wake_sr_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wake_lr (CPP_wake_lr&, bool&);

void set_CPP_wake_lr_test_pattern (CPP_wake_lr& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.freq = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.freq_in = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.r_over_q = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.q = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.angle = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.b_sin = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.b_cos = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.a_sin = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.a_cos = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.t_ref = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 11 + offset; C.m = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 12 + offset; C.polarized = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_wake_lr (Bmad_wake_lr_class* F, bool& c_ok) {

  CPP_wake_lr C, C2;

  c_ok = true;

  wake_lr_to_c (F, C);
  set_CPP_wake_lr_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wake_lr: C side convert F->C: Good" << endl;
  } else {
    cout << " wake_lr: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_lr_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wake_lr (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wake_lr_test_pattern (C, 3);
  if (C == C2) {
    cout << " wake_lr: F side convert F->C: Good" << endl;
  } else {
    cout << " wake_lr: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_lr_test_pattern (C2, 4);
  wake_lr_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_lat_ele_loc (CPP_lat_ele_loc&, bool&);

void set_CPP_lat_ele_loc_test_pattern (CPP_lat_ele_loc& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.ix_branch = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_lat_ele_loc (Bmad_lat_ele_loc_class* F, bool& c_ok) {

  CPP_lat_ele_loc C, C2;

  c_ok = true;

  lat_ele_loc_to_c (F, C);
  set_CPP_lat_ele_loc_test_pattern (C2, 1);

  if (C == C2) {
    cout << " lat_ele_loc: C side convert F->C: Good" << endl;
  } else {
    cout << " lat_ele_loc: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_ele_loc_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_lat_ele_loc (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_lat_ele_loc_test_pattern (C, 3);
  if (C == C2) {
    cout << " lat_ele_loc: F side convert F->C: Good" << endl;
  } else {
    cout << " lat_ele_loc: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_ele_loc_test_pattern (C2, 4);
  lat_ele_loc_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wake (CPP_wake&, bool&);

void set_CPP_wake_test_pattern (CPP_wake& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.sr_file.resize(200);
  for (unsigned int i = 0; i < C.sr_file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.sr_file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.lr_file.resize(200);
  for (unsigned int i = 0; i < C.lr_file.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.lr_file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[type, 0, NOT]
  set_CPP_wake_sr_test_pattern(C.sr_long, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_wake_sr_test_pattern(C.sr_trans, ix_patt);

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.lr.resize(0);
  else {
    C.lr.resize(3);
    for (unsigned int i = 0; i < C.lr.size(); i++)  {set_CPP_wake_lr_test_pattern(C.lr[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.z_sr_max = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_wake (Bmad_wake_class* F, bool& c_ok) {

  CPP_wake C, C2;

  c_ok = true;

  wake_to_c (F, C);
  set_CPP_wake_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wake: C side convert F->C: Good" << endl;
  } else {
    cout << " wake: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wake (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wake_test_pattern (C, 3);
  if (C == C2) {
    cout << " wake: F side convert F->C: Good" << endl;
  } else {
    cout << " wake: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wake_test_pattern (C2, 4);
  wake_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_taylor_term (CPP_taylor_term&, bool&);

void set_CPP_taylor_term_test_pattern (CPP_taylor_term& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.coef = rhs;

  // c_side.test_pat[integer, 1, NOT]
  for (unsigned int i = 0; i < C.expn.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.expn[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_taylor_term (Bmad_taylor_term_class* F, bool& c_ok) {

  CPP_taylor_term C, C2;

  c_ok = true;

  taylor_term_to_c (F, C);
  set_CPP_taylor_term_test_pattern (C2, 1);

  if (C == C2) {
    cout << " taylor_term: C side convert F->C: Good" << endl;
  } else {
    cout << " taylor_term: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_taylor_term_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_taylor_term (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_taylor_term_test_pattern (C, 3);
  if (C == C2) {
    cout << " taylor_term: F side convert F->C: Good" << endl;
  } else {
    cout << " taylor_term: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_taylor_term_test_pattern (C2, 4);
  taylor_term_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_taylor (CPP_taylor&, bool&);

void set_CPP_taylor_test_pattern (CPP_taylor& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.ref = rhs;

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.term.resize(0);
  else {
    C.term.resize(3);
    for (unsigned int i = 0; i < C.term.size(); i++)  {set_CPP_taylor_term_test_pattern(C.term[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_taylor (Bmad_taylor_class* F, bool& c_ok) {

  CPP_taylor C, C2;

  c_ok = true;

  taylor_to_c (F, C);
  set_CPP_taylor_test_pattern (C2, 1);

  if (C == C2) {
    cout << " taylor: C side convert F->C: Good" << endl;
  } else {
    cout << " taylor: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_taylor_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_taylor (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_taylor_test_pattern (C, 3);
  if (C == C2) {
    cout << " taylor: F side convert F->C: Good" << endl;
  } else {
    cout << " taylor: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_taylor_test_pattern (C2, 4);
  taylor_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wig_term (CPP_wig_term&, bool&);

void set_CPP_wig_term_test_pattern (CPP_wig_term& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.coef = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.kx = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.ky = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.kz = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.x0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.y0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.phi_z = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.type = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_wig_term (Bmad_wig_term_class* F, bool& c_ok) {

  CPP_wig_term C, C2;

  c_ok = true;

  wig_term_to_c (F, C);
  set_CPP_wig_term_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wig_term: C side convert F->C: Good" << endl;
  } else {
    cout << " wig_term: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wig_term_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wig_term (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wig_term_test_pattern (C, 3);
  if (C == C2) {
    cout << " wig_term: F side convert F->C: Good" << endl;
  } else {
    cout << " wig_term: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wig_term_test_pattern (C2, 4);
  wig_term_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wig (CPP_wig&, bool&);

void set_CPP_wig_test_pattern (CPP_wig& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.n_link = rhs;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.term.resize(0);
  else {
    C.term.resize(3);
    for (unsigned int i = 0; i < C.term.size(); i++)  {set_CPP_wig_term_test_pattern(C.term[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_wig (Bmad_wig_class* F, bool& c_ok) {

  CPP_wig C, C2;

  c_ok = true;

  wig_to_c (F, C);
  set_CPP_wig_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wig: C side convert F->C: Good" << endl;
  } else {
    cout << " wig: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wig_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wig (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wig_test_pattern (C, 3);
  if (C == C2) {
    cout << " wig: F side convert F->C: Good" << endl;
  } else {
    cout << " wig: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wig_test_pattern (C2, 4);
  wig_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_field_cartesian_map_term (CPP_em_field_cartesian_map_term&, bool&);

void set_CPP_em_field_cartesian_map_term_test_pattern (CPP_em_field_cartesian_map_term& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.coef = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.kx = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.ky = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.kz = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.x0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.y0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.phi_z = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.type = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_em_field_cartesian_map_term (Bmad_em_field_cartesian_map_term_class* F, bool& c_ok) {

  CPP_em_field_cartesian_map_term C, C2;

  c_ok = true;

  em_field_cartesian_map_term_to_c (F, C);
  set_CPP_em_field_cartesian_map_term_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_field_cartesian_map_term: C side convert F->C: Good" << endl;
  } else {
    cout << " em_field_cartesian_map_term: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_cartesian_map_term_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_field_cartesian_map_term (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_field_cartesian_map_term_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_field_cartesian_map_term: F side convert F->C: Good" << endl;
  } else {
    cout << " em_field_cartesian_map_term: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_cartesian_map_term_test_pattern (C2, 4);
  em_field_cartesian_map_term_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_field_cartesian_map (CPP_em_field_cartesian_map&, bool&);

void set_CPP_em_field_cartesian_map_test_pattern (CPP_em_field_cartesian_map& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_link = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.ele_anchor_pt = rhs;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.term.resize(0);
  else {
    C.term.resize(3);
    for (unsigned int i = 0; i < C.term.size(); i++)  {set_CPP_em_field_cartesian_map_term_test_pattern(C.term[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_em_field_cartesian_map (Bmad_em_field_cartesian_map_class* F, bool& c_ok) {

  CPP_em_field_cartesian_map C, C2;

  c_ok = true;

  em_field_cartesian_map_to_c (F, C);
  set_CPP_em_field_cartesian_map_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_field_cartesian_map: C side convert F->C: Good" << endl;
  } else {
    cout << " em_field_cartesian_map: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_cartesian_map_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_field_cartesian_map (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_field_cartesian_map_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_field_cartesian_map: F side convert F->C: Good" << endl;
  } else {
    cout << " em_field_cartesian_map: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_cartesian_map_test_pattern (C2, 4);
  em_field_cartesian_map_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_field_cylindrical_map_term (CPP_em_field_cylindrical_map_term&, bool&);

void set_CPP_em_field_cylindrical_map_term_test_pattern (CPP_em_field_cylindrical_map_term& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[complex, 0, NOT]
  rhs = 1 + offset; C.e_coef = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 2 + offset; C.b_coef = Complex(rhs, 100+rhs);


}

//--------------------------------------------------------------

extern "C" void test_c_em_field_cylindrical_map_term (Bmad_em_field_cylindrical_map_term_class* F, bool& c_ok) {

  CPP_em_field_cylindrical_map_term C, C2;

  c_ok = true;

  em_field_cylindrical_map_term_to_c (F, C);
  set_CPP_em_field_cylindrical_map_term_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_field_cylindrical_map_term: C side convert F->C: Good" << endl;
  } else {
    cout << " em_field_cylindrical_map_term: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_cylindrical_map_term_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_field_cylindrical_map_term (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_field_cylindrical_map_term_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_field_cylindrical_map_term: F side convert F->C: Good" << endl;
  } else {
    cout << " em_field_cylindrical_map_term: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_cylindrical_map_term_test_pattern (C2, 4);
  em_field_cylindrical_map_term_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_field_cylindrical_map (CPP_em_field_cylindrical_map&, bool&);

void set_CPP_em_field_cylindrical_map_test_pattern (CPP_em_field_cylindrical_map& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_link = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.ele_anchor_pt = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.dz = rhs;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.term.resize(0);
  else {
    C.term.resize(3);
    for (unsigned int i = 0; i < C.term.size(); i++)  {set_CPP_em_field_cylindrical_map_term_test_pattern(C.term[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_em_field_cylindrical_map (Bmad_em_field_cylindrical_map_class* F, bool& c_ok) {

  CPP_em_field_cylindrical_map C, C2;

  c_ok = true;

  em_field_cylindrical_map_to_c (F, C);
  set_CPP_em_field_cylindrical_map_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_field_cylindrical_map: C side convert F->C: Good" << endl;
  } else {
    cout << " em_field_cylindrical_map: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_cylindrical_map_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_field_cylindrical_map (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_field_cylindrical_map_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_field_cylindrical_map: F side convert F->C: Good" << endl;
  } else {
    cout << " em_field_cylindrical_map: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_cylindrical_map_test_pattern (C2, 4);
  em_field_cylindrical_map_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_field_taylor (CPP_em_field_taylor&, bool&);

void set_CPP_em_field_taylor_test_pattern (CPP_em_field_taylor& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_link = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.ele_anchor_pt = rhs;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.pt.resize(0);
  else {
    C.pt.resize(3);
    for (unsigned int i = 0; i < C.pt.size(); i++)  {set_CPP_taylor_test_pattern(C.pt[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.dr = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.r0 = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 8 + offset; C.curved_coords = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_em_field_taylor (Bmad_em_field_taylor_class* F, bool& c_ok) {

  CPP_em_field_taylor C, C2;

  c_ok = true;

  em_field_taylor_to_c (F, C);
  set_CPP_em_field_taylor_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_field_taylor: C side convert F->C: Good" << endl;
  } else {
    cout << " em_field_taylor: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_taylor_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_field_taylor (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_field_taylor_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_field_taylor: F side convert F->C: Good" << endl;
  } else {
    cout << " em_field_taylor: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_taylor_test_pattern (C2, 4);
  em_field_taylor_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_field_grid_pt (CPP_em_field_grid_pt&, bool&);

void set_CPP_em_field_grid_pt_test_pattern (CPP_em_field_grid_pt& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[complex, 1, NOT]
  for (unsigned int i = 0; i < C.e.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.e[i] = Complex(rhs, 100+rhs);}
  // c_side.test_pat[complex, 1, NOT]
  for (unsigned int i = 0; i < C.b.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.b[i] = Complex(rhs, 100+rhs);}

}

//--------------------------------------------------------------

extern "C" void test_c_em_field_grid_pt (Bmad_em_field_grid_pt_class* F, bool& c_ok) {

  CPP_em_field_grid_pt C, C2;

  c_ok = true;

  em_field_grid_pt_to_c (F, C);
  set_CPP_em_field_grid_pt_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_field_grid_pt: C side convert F->C: Good" << endl;
  } else {
    cout << " em_field_grid_pt: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_grid_pt_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_field_grid_pt (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_field_grid_pt_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_field_grid_pt: F side convert F->C: Good" << endl;
  } else {
    cout << " em_field_grid_pt: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_grid_pt_test_pattern (C2, 4);
  em_field_grid_pt_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_field_grid (CPP_em_field_grid&, bool&);

void set_CPP_em_field_grid_test_pattern (CPP_em_field_grid& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_link = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.ele_anchor_pt = rhs;

  // c_side.test_pat[type, 3, ALLOC]
  if (ix_patt < 3) 
    C.pt.resize(0);
  else {
    C.pt.resize(3);
    for (unsigned int i = 0; i < C.pt.size(); i++) {
      C.pt[i].resize(2);
      for (unsigned int j = 0; j < C.pt[0].size(); j++) {
        C.pt[i][j].resize(1);
        for (unsigned int k = 0; k < C.pt[0][0].size(); k++) {
          set_CPP_em_field_grid_pt_test_pattern(C.pt[i][j][k], ix_patt+i+2*j+3*k+6);
    } } }
  }

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.dr.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.dr[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r0.size(); i++)
    {int rhs = 101 + i + 10 + offset; C.r0[i] = rhs;}
  // c_side.test_pat[logical, 0, NOT]
  rhs = 11 + offset; C.curved_coords = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_em_field_grid (Bmad_em_field_grid_class* F, bool& c_ok) {

  CPP_em_field_grid C, C2;

  c_ok = true;

  em_field_grid_to_c (F, C);
  set_CPP_em_field_grid_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_field_grid: C side convert F->C: Good" << endl;
  } else {
    cout << " em_field_grid: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_grid_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_field_grid (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_field_grid_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_field_grid: F side convert F->C: Good" << endl;
  } else {
    cout << " em_field_grid: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_grid_test_pattern (C2, 4);
  em_field_grid_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_field_mode (CPP_em_field_mode&, bool&);

void set_CPP_em_field_mode_test_pattern (CPP_em_field_mode& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.m = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.harmonic = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.f_damp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.phi0_ref = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.stored_energy = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.phi0_azimuth = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.field_scale = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.master_scale = rhs;

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.grid = NULL;
  else {
    C.grid = new CPP_em_field_grid;
    set_CPP_em_field_grid_test_pattern((*C.grid), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.cylindrical_map = NULL;
  else {
    C.cylindrical_map = new CPP_em_field_cylindrical_map;
    set_CPP_em_field_cylindrical_map_test_pattern((*C.cylindrical_map), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.cartesian_map = NULL;
  else {
    C.cartesian_map = new CPP_em_field_cartesian_map;
    set_CPP_em_field_cartesian_map_test_pattern((*C.cartesian_map), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.taylor = NULL;
  else {
    C.taylor = new CPP_em_field_taylor;
    set_CPP_em_field_taylor_test_pattern((*C.taylor), ix_patt);
  }


}

//--------------------------------------------------------------

extern "C" void test_c_em_field_mode (Bmad_em_field_mode_class* F, bool& c_ok) {

  CPP_em_field_mode C, C2;

  c_ok = true;

  em_field_mode_to_c (F, C);
  set_CPP_em_field_mode_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_field_mode: C side convert F->C: Good" << endl;
  } else {
    cout << " em_field_mode: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_mode_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_field_mode (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_field_mode_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_field_mode: F side convert F->C: Good" << endl;
  } else {
    cout << " em_field_mode: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_mode_test_pattern (C2, 4);
  em_field_mode_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_fields (CPP_em_fields&, bool&);

void set_CPP_em_fields_test_pattern (CPP_em_fields& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.mode.resize(0);
  else {
    C.mode.resize(3);
    for (unsigned int i = 0; i < C.mode.size(); i++)  {set_CPP_em_field_mode_test_pattern(C.mode[i], ix_patt+i+1);}
  }

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.mode_to_autoscale = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_em_fields (Bmad_em_fields_class* F, bool& c_ok) {

  CPP_em_fields C, C2;

  c_ok = true;

  em_fields_to_c (F, C);
  set_CPP_em_fields_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_fields: C side convert F->C: Good" << endl;
  } else {
    cout << " em_fields: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_fields_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_fields (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_fields_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_fields: F side convert F->C: Good" << endl;
  } else {
    cout << " em_fields: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_fields_test_pattern (C2, 4);
  em_fields_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_floor_position (CPP_floor_position&, bool&);

void set_CPP_floor_position_test_pattern (CPP_floor_position& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.r[i] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.w.size(); i++)  for (unsigned int j = 0; j < C.w[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 2 + offset; C.w[i][j] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.theta = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.psi = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_floor_position (Bmad_floor_position_class* F, bool& c_ok) {

  CPP_floor_position C, C2;

  c_ok = true;

  floor_position_to_c (F, C);
  set_CPP_floor_position_test_pattern (C2, 1);

  if (C == C2) {
    cout << " floor_position: C side convert F->C: Good" << endl;
  } else {
    cout << " floor_position: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_floor_position_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_floor_position (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_floor_position_test_pattern (C, 3);
  if (C == C2) {
    cout << " floor_position: F side convert F->C: Good" << endl;
  } else {
    cout << " floor_position: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_floor_position_test_pattern (C2, 4);
  floor_position_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_space_charge (CPP_space_charge&, bool&);

void set_CPP_space_charge_test_pattern (CPP_space_charge& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.closed_orb, ix_patt);

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.kick_const = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.sig_x = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.sig_y = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.sin_phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.cos_phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.sig_z = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_space_charge (Bmad_space_charge_class* F, bool& c_ok) {

  CPP_space_charge C, C2;

  c_ok = true;

  space_charge_to_c (F, C);
  set_CPP_space_charge_test_pattern (C2, 1);

  if (C == C2) {
    cout << " space_charge: C side convert F->C: Good" << endl;
  } else {
    cout << " space_charge: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_space_charge_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_space_charge (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_space_charge_test_pattern (C, 3);
  if (C == C2) {
    cout << " space_charge: F side convert F->C: Good" << endl;
  } else {
    cout << " space_charge: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_space_charge_test_pattern (C2, 4);
  space_charge_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_xy_disp (CPP_xy_disp&, bool&);

void set_CPP_xy_disp_test_pattern (CPP_xy_disp& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.eta = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.etap = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_xy_disp (Bmad_xy_disp_class* F, bool& c_ok) {

  CPP_xy_disp C, C2;

  c_ok = true;

  xy_disp_to_c (F, C);
  set_CPP_xy_disp_test_pattern (C2, 1);

  if (C == C2) {
    cout << " xy_disp: C side convert F->C: Good" << endl;
  } else {
    cout << " xy_disp: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_xy_disp_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_xy_disp (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_xy_disp_test_pattern (C, 3);
  if (C == C2) {
    cout << " xy_disp: F side convert F->C: Good" << endl;
  } else {
    cout << " xy_disp: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_xy_disp_test_pattern (C2, 4);
  xy_disp_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_twiss (CPP_twiss&, bool&);

void set_CPP_twiss_test_pattern (CPP_twiss& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.beta = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.alpha = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.gamma = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.phi = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.eta = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.etap = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.sigma = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.sigma_p = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.emit = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.norm_emit = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_twiss (Bmad_twiss_class* F, bool& c_ok) {

  CPP_twiss C, C2;

  c_ok = true;

  twiss_to_c (F, C);
  set_CPP_twiss_test_pattern (C2, 1);

  if (C == C2) {
    cout << " twiss: C side convert F->C: Good" << endl;
  } else {
    cout << " twiss: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_twiss_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_twiss (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_twiss_test_pattern (C, 3);
  if (C == C2) {
    cout << " twiss: F side convert F->C: Good" << endl;
  } else {
    cout << " twiss: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_twiss_test_pattern (C2, 4);
  twiss_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_mode3 (CPP_mode3&, bool&);

void set_CPP_mode3_test_pattern (CPP_mode3& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.v.size(); i++)  for (unsigned int j = 0; j < C.v[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 1 + offset; C.v[i][j] = rhs;}
  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.a, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.b, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.c, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.x, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.y, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_mode3 (Bmad_mode3_class* F, bool& c_ok) {

  CPP_mode3 C, C2;

  c_ok = true;

  mode3_to_c (F, C);
  set_CPP_mode3_test_pattern (C2, 1);

  if (C == C2) {
    cout << " mode3: C side convert F->C: Good" << endl;
  } else {
    cout << " mode3: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_mode3_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_mode3 (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_mode3_test_pattern (C, 3);
  if (C == C2) {
    cout << " mode3: F side convert F->C: Good" << endl;
  } else {
    cout << " mode3: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_mode3_test_pattern (C2, 4);
  mode3_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_bookkeeping_state (CPP_bookkeeping_state&, bool&);

void set_CPP_bookkeeping_state_test_pattern (CPP_bookkeeping_state& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.attributes = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.control = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.floor_position = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.s_position = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.ref_energy = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 6 + offset; C.mat6 = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.rad_int = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.ptc = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_bookkeeping_state (Bmad_bookkeeping_state_class* F, bool& c_ok) {

  CPP_bookkeeping_state C, C2;

  c_ok = true;

  bookkeeping_state_to_c (F, C);
  set_CPP_bookkeeping_state_test_pattern (C2, 1);

  if (C == C2) {
    cout << " bookkeeping_state: C side convert F->C: Good" << endl;
  } else {
    cout << " bookkeeping_state: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bookkeeping_state_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_bookkeeping_state (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_bookkeeping_state_test_pattern (C, 3);
  if (C == C2) {
    cout << " bookkeeping_state: F side convert F->C: Good" << endl;
  } else {
    cout << " bookkeeping_state: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bookkeeping_state_test_pattern (C2, 4);
  bookkeeping_state_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_rad_int_ele_cache (CPP_rad_int_ele_cache&, bool&);

void set_CPP_rad_int_ele_cache_test_pattern (CPP_rad_int_ele_cache& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.orb0.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.orb0[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.g2_0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.g3_0 = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.dg2_dorb.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.dg2_dorb[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.dg3_dorb.size(); i++)
    {int rhs = 101 + i + 5 + offset; C.dg3_dorb[i] = rhs;}
  // c_side.test_pat[logical, 0, NOT]
  rhs = 6 + offset; C.stale = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_rad_int_ele_cache (Bmad_rad_int_ele_cache_class* F, bool& c_ok) {

  CPP_rad_int_ele_cache C, C2;

  c_ok = true;

  rad_int_ele_cache_to_c (F, C);
  set_CPP_rad_int_ele_cache_test_pattern (C2, 1);

  if (C == C2) {
    cout << " rad_int_ele_cache: C side convert F->C: Good" << endl;
  } else {
    cout << " rad_int_ele_cache: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int_ele_cache_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_rad_int_ele_cache (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_rad_int_ele_cache_test_pattern (C, 3);
  if (C == C2) {
    cout << " rad_int_ele_cache: F side convert F->C: Good" << endl;
  } else {
    cout << " rad_int_ele_cache: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int_ele_cache_test_pattern (C2, 4);
  rad_int_ele_cache_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_surface_grid_pt (CPP_surface_grid_pt&, bool&);

void set_CPP_surface_grid_pt_test_pattern (CPP_surface_grid_pt& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_surface_orientation_test_pattern(C.orientation, ix_patt);

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.n_photon = rhs;

  // c_side.test_pat[complex, 0, NOT]
  rhs = 3 + offset; C.e_x = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 4 + offset; C.e_y = Complex(rhs, 100+rhs);

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.intensity_x = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.intensity_y = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.intensity = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.orbit.size(); i++)
    {int rhs = 101 + i + 8 + offset; C.orbit[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.orbit_rms.size(); i++)
    {int rhs = 101 + i + 9 + offset; C.orbit_rms[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.init_orbit.size(); i++)
    {int rhs = 101 + i + 10 + offset; C.init_orbit[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.init_orbit_rms.size(); i++)
    {int rhs = 101 + i + 11 + offset; C.init_orbit_rms[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_surface_grid_pt (Bmad_surface_grid_pt_class* F, bool& c_ok) {

  CPP_surface_grid_pt C, C2;

  c_ok = true;

  surface_grid_pt_to_c (F, C);
  set_CPP_surface_grid_pt_test_pattern (C2, 1);

  if (C == C2) {
    cout << " surface_grid_pt: C side convert F->C: Good" << endl;
  } else {
    cout << " surface_grid_pt: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_grid_pt_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_surface_grid_pt (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_surface_grid_pt_test_pattern (C, 3);
  if (C == C2) {
    cout << " surface_grid_pt: F side convert F->C: Good" << endl;
  } else {
    cout << " surface_grid_pt: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_grid_pt_test_pattern (C2, 4);
  surface_grid_pt_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_surface_grid (CPP_surface_grid&, bool&);

void set_CPP_surface_grid_test_pattern (CPP_surface_grid& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.file.resize(200);
  for (unsigned int i = 0; i < C.file.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.file[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.type = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.dr.size(); i++)
    {int rhs = 101 + i + 3 + offset; C.dr[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r0.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.r0[i] = rhs;}
  // c_side.test_pat[type, 2, ALLOC]
  if (ix_patt < 3) 
    C.pt.resize(0);
  else {
    C.pt.resize(3);
    for (unsigned int i = 0; i < C.pt.size(); i++) {
      C.pt[i].resize(2);

      for (unsigned int j = 0; j < C.pt[0].size(); j++) {
        set_CPP_surface_grid_pt_test_pattern(C.pt[i][j], ix_patt+i+2*j+3);
      }
    }
  }


}

//--------------------------------------------------------------

extern "C" void test_c_surface_grid (Bmad_surface_grid_class* F, bool& c_ok) {

  CPP_surface_grid C, C2;

  c_ok = true;

  surface_grid_to_c (F, C);
  set_CPP_surface_grid_test_pattern (C2, 1);

  if (C == C2) {
    cout << " surface_grid: C side convert F->C: Good" << endl;
  } else {
    cout << " surface_grid: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_grid_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_surface_grid (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_surface_grid_test_pattern (C, 3);
  if (C == C2) {
    cout << " surface_grid: F side convert F->C: Good" << endl;
  } else {
    cout << " surface_grid: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_surface_grid_test_pattern (C2, 4);
  surface_grid_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_segmented_surface (CPP_segmented_surface&, bool&);

void set_CPP_segmented_surface_test_pattern (CPP_segmented_surface& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.ix = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.iy = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.x0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.y0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.z0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.slope_x = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.slope_y = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_segmented_surface (Bmad_segmented_surface_class* F, bool& c_ok) {

  CPP_segmented_surface C, C2;

  c_ok = true;

  segmented_surface_to_c (F, C);
  set_CPP_segmented_surface_test_pattern (C2, 1);

  if (C == C2) {
    cout << " segmented_surface: C side convert F->C: Good" << endl;
  } else {
    cout << " segmented_surface: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_segmented_surface_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_segmented_surface (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_segmented_surface_test_pattern (C, 3);
  if (C == C2) {
    cout << " segmented_surface: F side convert F->C: Good" << endl;
  } else {
    cout << " segmented_surface: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_segmented_surface_test_pattern (C2, 4);
  segmented_surface_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_target_point (CPP_target_point&, bool&);

void set_CPP_target_point_test_pattern (CPP_target_point& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.r[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_target_point (Bmad_target_point_class* F, bool& c_ok) {

  CPP_target_point C, C2;

  c_ok = true;

  target_point_to_c (F, C);
  set_CPP_target_point_test_pattern (C2, 1);

  if (C == C2) {
    cout << " target_point: C side convert F->C: Good" << endl;
  } else {
    cout << " target_point: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_target_point_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_target_point (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_target_point_test_pattern (C, 3);
  if (C == C2) {
    cout << " target_point: F side convert F->C: Good" << endl;
  } else {
    cout << " target_point: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_target_point_test_pattern (C2, 4);
  target_point_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_surface (CPP_photon_surface&, bool&);

void set_CPP_photon_surface_test_pattern (CPP_photon_surface& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_surface_grid_test_pattern(C.grid, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_segmented_surface_test_pattern(C.segment, ix_patt);

  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.curvature_xy.size(); i++)  for (unsigned int j = 0; j < C.curvature_xy[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 3 + offset; C.curvature_xy[i][j] = rhs;}
  // c_side.test_pat[logical, 0, NOT]
  rhs = 4 + offset; C.has_curvature = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_photon_surface (Bmad_photon_surface_class* F, bool& c_ok) {

  CPP_photon_surface C, C2;

  c_ok = true;

  photon_surface_to_c (F, C);
  set_CPP_photon_surface_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_surface: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_surface: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_surface_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_surface (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_surface_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_surface: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_surface: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_surface_test_pattern (C2, 4);
  photon_surface_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_target (CPP_photon_target&, bool&);

void set_CPP_photon_target_test_pattern (CPP_photon_target& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 1 + offset; C.deterministic_grid = (rhs % 2 == 0);

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.ix_grid = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.iy_grid = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.n_corner = rhs;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_lat_ele_loc_test_pattern(C.ele_loc, ix_patt);

  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.corner.size(); i++)
    {int rhs = 101 + i + 7 + offset; set_CPP_target_point_test_pattern(C.corner[i], ix_patt+i+1);}
  // c_side.test_pat[type, 0, NOT]
  set_CPP_target_point_test_pattern(C.center, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_photon_target (Bmad_photon_target_class* F, bool& c_ok) {

  CPP_photon_target C, C2;

  c_ok = true;

  photon_target_to_c (F, C);
  set_CPP_photon_target_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_target: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_target: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_target_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_target (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_target_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_target: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_target: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_target_test_pattern (C2, 4);
  photon_target_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_material (CPP_photon_material&, bool&);

void set_CPP_photon_material_test_pattern (CPP_photon_material& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[complex, 0, NOT]
  rhs = 1 + offset; C.f0_m1 = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 2 + offset; C.f0_m2 = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 3 + offset; C.f_0 = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 4 + offset; C.f_h = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 5 + offset; C.f_hbar = Complex(rhs, 100+rhs);

  // c_side.test_pat[complex, 0, NOT]
  rhs = 6 + offset; C.f_hkl = Complex(rhs, 100+rhs);

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.h_norm.size(); i++)
    {int rhs = 101 + i + 7 + offset; C.h_norm[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.l_ref.size(); i++)
    {int rhs = 101 + i + 8 + offset; C.l_ref[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_photon_material (Bmad_photon_material_class* F, bool& c_ok) {

  CPP_photon_material C, C2;

  c_ok = true;

  photon_material_to_c (F, C);
  set_CPP_photon_material_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_material: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_material: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_material_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_material (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_material_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_material: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_material: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_material_test_pattern (C2, 4);
  photon_material_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_photon_element (CPP_photon_element&, bool&);

void set_CPP_photon_element_test_pattern (CPP_photon_element& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_photon_surface_test_pattern(C.surface, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_photon_target_test_pattern(C.target, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_photon_material_test_pattern(C.material, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_photon_element (Bmad_photon_element_class* F, bool& c_ok) {

  CPP_photon_element C, C2;

  c_ok = true;

  photon_element_to_c (F, C);
  set_CPP_photon_element_test_pattern (C2, 1);

  if (C == C2) {
    cout << " photon_element: C side convert F->C: Good" << endl;
  } else {
    cout << " photon_element: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_element_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_photon_element (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_photon_element_test_pattern (C, 3);
  if (C == C2) {
    cout << " photon_element: F side convert F->C: Good" << endl;
  } else {
    cout << " photon_element: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_photon_element_test_pattern (C2, 4);
  photon_element_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wall3d_vertex (CPP_wall3d_vertex&, bool&);

void set_CPP_wall3d_vertex_test_pattern (CPP_wall3d_vertex& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.x = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.y = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.radius_x = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.radius_y = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.tilt = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.angle = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.x0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.y0 = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.type = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_wall3d_vertex (Bmad_wall3d_vertex_class* F, bool& c_ok) {

  CPP_wall3d_vertex C, C2;

  c_ok = true;

  wall3d_vertex_to_c (F, C);
  set_CPP_wall3d_vertex_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wall3d_vertex: C side convert F->C: Good" << endl;
  } else {
    cout << " wall3d_vertex: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_vertex_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wall3d_vertex (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wall3d_vertex_test_pattern (C, 3);
  if (C == C2) {
    cout << " wall3d_vertex: F side convert F->C: Good" << endl;
  } else {
    cout << " wall3d_vertex: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_vertex_test_pattern (C2, 4);
  wall3d_vertex_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wall3d_section (CPP_wall3d_section&, bool&);

void set_CPP_wall3d_section_test_pattern (CPP_wall3d_section& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.material.resize(20);
  for (unsigned int i = 0; i < C.material.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.material[i] = 'a' + rhs % 26;}
  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.v.resize(0);
  else {
    C.v.resize(3);
    for (unsigned int i = 0; i < C.v.size(); i++)  {set_CPP_wall3d_vertex_test_pattern(C.v[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.surface = NULL;
  else {
    C.surface = new CPP_photon_reflect_surface;
    set_CPP_photon_reflect_surface_test_pattern((*C.surface), ix_patt);
  }

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.n_vertex_input = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 10 + offset; C.ix_branch = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 11 + offset; C.patch_in_region = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 12 + offset; C.absolute_vertices_input = (rhs % 2 == 0);

  // c_side.test_pat[real, 0, NOT]
  rhs = 13 + offset; C.thickness = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 14 + offset; C.s = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.r0.size(); i++)
    {int rhs = 101 + i + 15 + offset; C.r0[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 16 + offset; C.dx0_ds = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 17 + offset; C.dy0_ds = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.x0_coef.size(); i++)
    {int rhs = 101 + i + 18 + offset; C.x0_coef[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.y0_coef.size(); i++)
    {int rhs = 101 + i + 19 + offset; C.y0_coef[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 20 + offset; C.dr_ds = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.p1_coef.size(); i++)
    {int rhs = 101 + i + 21 + offset; C.p1_coef[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.p2_coef.size(); i++)
    {int rhs = 101 + i + 22 + offset; C.p2_coef[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_wall3d_section (Bmad_wall3d_section_class* F, bool& c_ok) {

  CPP_wall3d_section C, C2;

  c_ok = true;

  wall3d_section_to_c (F, C);
  set_CPP_wall3d_section_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wall3d_section: C side convert F->C: Good" << endl;
  } else {
    cout << " wall3d_section: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_section_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wall3d_section (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wall3d_section_test_pattern (C, 3);
  if (C == C2) {
    cout << " wall3d_section: F side convert F->C: Good" << endl;
  } else {
    cout << " wall3d_section: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_section_test_pattern (C2, 4);
  wall3d_section_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_wall3d (CPP_wall3d&, bool&);

void set_CPP_wall3d_test_pattern (CPP_wall3d& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.ix_wall3d = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.n_link = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.thickness = rhs;

  // c_side.test_pat[character, 0, NOT]
  C.clear_material.resize(20);
  for (unsigned int i = 0; i < C.clear_material.size(); i++)
    {int rhs = 101 + i + 6 + offset; C.clear_material[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.opaque_material.resize(20);
  for (unsigned int i = 0; i < C.opaque_material.size(); i++)
    {int rhs = 101 + i + 7 + offset; C.opaque_material[i] = 'a' + rhs % 26;}
  // c_side.test_pat[logical, 0, NOT]
  rhs = 8 + offset; C.superimpose = (rhs % 2 == 0);

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.ele_anchor_pt = rhs;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.section.resize(0);
  else {
    C.section.resize(3);
    for (unsigned int i = 0; i < C.section.size(); i++)  {set_CPP_wall3d_section_test_pattern(C.section[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_wall3d (Bmad_wall3d_class* F, bool& c_ok) {

  CPP_wall3d C, C2;

  c_ok = true;

  wall3d_to_c (F, C);
  set_CPP_wall3d_test_pattern (C2, 1);

  if (C == C2) {
    cout << " wall3d: C side convert F->C: Good" << endl;
  } else {
    cout << " wall3d: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_wall3d (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_wall3d_test_pattern (C, 3);
  if (C == C2) {
    cout << " wall3d: F side convert F->C: Good" << endl;
  } else {
    cout << " wall3d: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_wall3d_test_pattern (C2, 4);
  wall3d_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_control (CPP_control&, bool&);

void set_CPP_control_test_pattern (CPP_control& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.stack.resize(0);
  else {
    C.stack.resize(3);
    for (unsigned int i = 0; i < C.stack.size(); i++)  {set_CPP_expression_atom_test_pattern(C.stack[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_lat_ele_loc_test_pattern(C.slave, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_lat_ele_loc_test_pattern(C.lord, ix_patt);

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.ix_attrib = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_control (Bmad_control_class* F, bool& c_ok) {

  CPP_control C, C2;

  c_ok = true;

  control_to_c (F, C);
  set_CPP_control_test_pattern (C2, 1);

  if (C == C2) {
    cout << " control: C side convert F->C: Good" << endl;
  } else {
    cout << " control: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_control_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_control (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_control_test_pattern (C, 3);
  if (C == C2) {
    cout << " control: F side convert F->C: Good" << endl;
  } else {
    cout << " control: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_control_test_pattern (C2, 4);
  control_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_lat_param (CPP_lat_param&, bool&);

void set_CPP_lat_param_test_pattern (CPP_lat_param& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.n_part = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.total_length = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.unstable_factor = rhs;

  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.t1_with_rf.size(); i++)  for (unsigned int j = 0; j < C.t1_with_rf[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 4 + offset; C.t1_with_rf[i][j] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.t1_no_rf.size(); i++)  for (unsigned int j = 0; j < C.t1_no_rf[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 5 + offset; C.t1_no_rf[i][j] = rhs;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 6 + offset; C.particle = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.default_tracking_species = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.geometry = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.ixx = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 10 + offset; C.stable = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 11 + offset; C.backwards_time_tracking = (rhs % 2 == 0);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_bookkeeping_state_test_pattern(C.bookkeeping_state, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_lat_param (Bmad_lat_param_class* F, bool& c_ok) {

  CPP_lat_param C, C2;

  c_ok = true;

  lat_param_to_c (F, C);
  set_CPP_lat_param_test_pattern (C2, 1);

  if (C == C2) {
    cout << " lat_param: C side convert F->C: Good" << endl;
  } else {
    cout << " lat_param: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_param_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_lat_param (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_lat_param_test_pattern (C, 3);
  if (C == C2) {
    cout << " lat_param: F side convert F->C: Good" << endl;
  } else {
    cout << " lat_param: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_param_test_pattern (C2, 4);
  lat_param_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_mode_info (CPP_mode_info&, bool&);

void set_CPP_mode_info_test_pattern (CPP_mode_info& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.tune = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.emit = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.chrom = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.sigma = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.sigmap = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_mode_info (Bmad_mode_info_class* F, bool& c_ok) {

  CPP_mode_info C, C2;

  c_ok = true;

  mode_info_to_c (F, C);
  set_CPP_mode_info_test_pattern (C2, 1);

  if (C == C2) {
    cout << " mode_info: C side convert F->C: Good" << endl;
  } else {
    cout << " mode_info: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_mode_info_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_mode_info (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_mode_info_test_pattern (C, 3);
  if (C == C2) {
    cout << " mode_info: F side convert F->C: Good" << endl;
  } else {
    cout << " mode_info: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_mode_info_test_pattern (C2, 4);
  mode_info_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_pre_tracker (CPP_pre_tracker&, bool&);

void set_CPP_pre_tracker_test_pattern (CPP_pre_tracker& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 1 + offset; C.who = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.ix_ele_start = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.ix_ele_end = rhs;

  // c_side.test_pat[character, 0, NOT]
  C.input_file.resize(200);
  for (unsigned int i = 0; i < C.input_file.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.input_file[i] = 'a' + rhs % 26;}

}

//--------------------------------------------------------------

extern "C" void test_c_pre_tracker (Bmad_pre_tracker_class* F, bool& c_ok) {

  CPP_pre_tracker C, C2;

  c_ok = true;

  pre_tracker_to_c (F, C);
  set_CPP_pre_tracker_test_pattern (C2, 1);

  if (C == C2) {
    cout << " pre_tracker: C side convert F->C: Good" << endl;
  } else {
    cout << " pre_tracker: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_pre_tracker_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_pre_tracker (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_pre_tracker_test_pattern (C, 3);
  if (C == C2) {
    cout << " pre_tracker: F side convert F->C: Good" << endl;
  } else {
    cout << " pre_tracker: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_pre_tracker_test_pattern (C2, 4);
  pre_tracker_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_anormal_mode (CPP_anormal_mode&, bool&);

void set_CPP_anormal_mode_test_pattern (CPP_anormal_mode& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.emittance = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.synch_int.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.synch_int[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.j_damp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.alpha_damp = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.chrom = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.tune = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_anormal_mode (Bmad_anormal_mode_class* F, bool& c_ok) {

  CPP_anormal_mode C, C2;

  c_ok = true;

  anormal_mode_to_c (F, C);
  set_CPP_anormal_mode_test_pattern (C2, 1);

  if (C == C2) {
    cout << " anormal_mode: C side convert F->C: Good" << endl;
  } else {
    cout << " anormal_mode: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_anormal_mode_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_anormal_mode (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_anormal_mode_test_pattern (C, 3);
  if (C == C2) {
    cout << " anormal_mode: F side convert F->C: Good" << endl;
  } else {
    cout << " anormal_mode: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_anormal_mode_test_pattern (C2, 4);
  anormal_mode_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_linac_normal_mode (CPP_linac_normal_mode&, bool&);

void set_CPP_linac_normal_mode_test_pattern (CPP_linac_normal_mode& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.i2_e4 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.i3_e7 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.i5a_e6 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.i5b_e6 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.sig_e1 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.a_emittance_end = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.b_emittance_end = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_linac_normal_mode (Bmad_linac_normal_mode_class* F, bool& c_ok) {

  CPP_linac_normal_mode C, C2;

  c_ok = true;

  linac_normal_mode_to_c (F, C);
  set_CPP_linac_normal_mode_test_pattern (C2, 1);

  if (C == C2) {
    cout << " linac_normal_mode: C side convert F->C: Good" << endl;
  } else {
    cout << " linac_normal_mode: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_linac_normal_mode_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_linac_normal_mode (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_linac_normal_mode_test_pattern (C, 3);
  if (C == C2) {
    cout << " linac_normal_mode: F side convert F->C: Good" << endl;
  } else {
    cout << " linac_normal_mode: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_linac_normal_mode_test_pattern (C2, 4);
  linac_normal_mode_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_normal_modes (CPP_normal_modes&, bool&);

void set_CPP_normal_modes_test_pattern (CPP_normal_modes& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.synch_int.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.synch_int[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.sige_e = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.sig_z = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.e_loss = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.rf_voltage = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.pz_aperture = rhs;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_anormal_mode_test_pattern(C.a, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_anormal_mode_test_pattern(C.b, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_anormal_mode_test_pattern(C.z, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_linac_normal_mode_test_pattern(C.lin, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_normal_modes (Bmad_normal_modes_class* F, bool& c_ok) {

  CPP_normal_modes C, C2;

  c_ok = true;

  normal_modes_to_c (F, C);
  set_CPP_normal_modes_test_pattern (C2, 1);

  if (C == C2) {
    cout << " normal_modes: C side convert F->C: Good" << endl;
  } else {
    cout << " normal_modes: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_normal_modes_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_normal_modes (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_normal_modes_test_pattern (C, 3);
  if (C == C2) {
    cout << " normal_modes: F side convert F->C: Good" << endl;
  } else {
    cout << " normal_modes: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_normal_modes_test_pattern (C2, 4);
  normal_modes_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_em_field (CPP_em_field&, bool&);

void set_CPP_em_field_test_pattern (CPP_em_field& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.e.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.e[i] = rhs;}
  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.b.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.b[i] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.de.size(); i++)  for (unsigned int j = 0; j < C.de[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 3 + offset; C.de[i][j] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.db.size(); i++)  for (unsigned int j = 0; j < C.db[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 4 + offset; C.db[i][j] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_em_field (Bmad_em_field_class* F, bool& c_ok) {

  CPP_em_field C, C2;

  c_ok = true;

  em_field_to_c (F, C);
  set_CPP_em_field_test_pattern (C2, 1);

  if (C == C2) {
    cout << " em_field: C side convert F->C: Good" << endl;
  } else {
    cout << " em_field: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_em_field (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_em_field_test_pattern (C, 3);
  if (C == C2) {
    cout << " em_field: F side convert F->C: Good" << endl;
  } else {
    cout << " em_field: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_em_field_test_pattern (C2, 4);
  em_field_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_track_map (CPP_track_map&, bool&);

void set_CPP_track_map_test_pattern (CPP_track_map& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.vec0.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.vec0[i] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.mat6.size(); i++)  for (unsigned int j = 0; j < C.mat6[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 2 + offset; C.mat6[i][j] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_track_map (Bmad_track_map_class* F, bool& c_ok) {

  CPP_track_map C, C2;

  c_ok = true;

  track_map_to_c (F, C);
  set_CPP_track_map_test_pattern (C2, 1);

  if (C == C2) {
    cout << " track_map: C side convert F->C: Good" << endl;
  } else {
    cout << " track_map: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_track_map_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_track_map (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_track_map_test_pattern (C, 3);
  if (C == C2) {
    cout << " track_map: F side convert F->C: Good" << endl;
  } else {
    cout << " track_map: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_track_map_test_pattern (C2, 4);
  track_map_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_track (CPP_track&, bool&);

void set_CPP_track_test_pattern (CPP_track& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.orb.resize(0);
  else {
    C.orb.resize(3);
    for (unsigned int i = 0; i < C.orb.size(); i++)  {set_CPP_coord_test_pattern(C.orb[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.field.resize(0);
  else {
    C.field.resize(3);
    for (unsigned int i = 0; i < C.field.size(); i++)  {set_CPP_em_field_test_pattern(C.field[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.map.resize(0);
  else {
    C.map.resize(3);
    for (unsigned int i = 0; i < C.map.size(); i++)  {set_CPP_track_map_test_pattern(C.map[i], ix_patt+i+1);}
  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.ds_save = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.n_pt = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.n_bad = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 10 + offset; C.n_ok = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_track (Bmad_track_class* F, bool& c_ok) {

  CPP_track C, C2;

  c_ok = true;

  track_to_c (F, C);
  set_CPP_track_test_pattern (C2, 1);

  if (C == C2) {
    cout << " track: C side convert F->C: Good" << endl;
  } else {
    cout << " track: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_track_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_track (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_track_test_pattern (C, 3);
  if (C == C2) {
    cout << " track: F side convert F->C: Good" << endl;
  } else {
    cout << " track: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_track_test_pattern (C2, 4);
  track_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_synch_rad_common (CPP_synch_rad_common&, bool&);

void set_CPP_synch_rad_common_test_pattern (CPP_synch_rad_common& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.scale = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.i2 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.i3 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.i5a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.i5b = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 6 + offset; C.i_calc_on = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_synch_rad_common (Bmad_synch_rad_common_class* F, bool& c_ok) {

  CPP_synch_rad_common C, C2;

  c_ok = true;

  synch_rad_common_to_c (F, C);
  set_CPP_synch_rad_common_test_pattern (C2, 1);

  if (C == C2) {
    cout << " synch_rad_common: C side convert F->C: Good" << endl;
  } else {
    cout << " synch_rad_common: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_synch_rad_common_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_synch_rad_common (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_synch_rad_common_test_pattern (C, 3);
  if (C == C2) {
    cout << " synch_rad_common: F side convert F->C: Good" << endl;
  } else {
    cout << " synch_rad_common: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_synch_rad_common_test_pattern (C2, 4);
  synch_rad_common_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_csr_parameter (CPP_csr_parameter&, bool&);

void set_CPP_csr_parameter_test_pattern (CPP_csr_parameter& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.ds_track_step = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.beam_chamber_height = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.sigma_cutoff = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.n_bin = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 5 + offset; C.particle_bin_span = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 6 + offset; C.n_shield_images = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 7 + offset; C.ix1_ele_csr = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 8 + offset; C.ix2_ele_csr = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 9 + offset; C.lcsr_component_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 10 + offset; C.lsc_component_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 11 + offset; C.tsc_component_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 12 + offset; C.small_angle_approx = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 13 + offset; C.print_taylor_warning = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 14 + offset; C.use_csr_old = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_csr_parameter (Bmad_csr_parameter_class* F, bool& c_ok) {

  CPP_csr_parameter C, C2;

  c_ok = true;

  csr_parameter_to_c (F, C);
  set_CPP_csr_parameter_test_pattern (C2, 1);

  if (C == C2) {
    cout << " csr_parameter: C side convert F->C: Good" << endl;
  } else {
    cout << " csr_parameter: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_csr_parameter_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_csr_parameter (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_csr_parameter_test_pattern (C, 3);
  if (C == C2) {
    cout << " csr_parameter: F side convert F->C: Good" << endl;
  } else {
    cout << " csr_parameter: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_csr_parameter_test_pattern (C2, 4);
  csr_parameter_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_bmad_common (CPP_bmad_common&, bool&);

void set_CPP_bmad_common_test_pattern (CPP_bmad_common& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.max_aperture_limit = rhs;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.d_orb.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.d_orb[i] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.default_ds_step = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.significant_length = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.rel_tol_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.abs_tol_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.rel_tol_adaptive_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.abs_tol_adaptive_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.init_ds_adaptive_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.min_ds_adaptive_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 11 + offset; C.fatal_ds_adaptive_tracking = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 12 + offset; C.electric_dipole_moment = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 13 + offset; C.ptc_cut_factor = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 14 + offset; C.sad_eps_scale = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 15 + offset; C.sad_amp_max = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 16 + offset; C.sad_n_div_max = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 17 + offset; C.taylor_order = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 18 + offset; C.default_integ_order = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 19 + offset; C.ptc_max_fringe_order = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 20 + offset; C.use_hard_edge_drifts = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 21 + offset; C.sr_wakes_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 22 + offset; C.lr_wakes_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 23 + offset; C.mat6_track_symmetric = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 24 + offset; C.auto_bookkeeper = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 25 + offset; C.space_charge_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 26 + offset; C.coherent_synch_rad_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 27 + offset; C.spin_tracking_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 28 + offset; C.radiation_damping_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 29 + offset; C.radiation_fluctuations_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 30 + offset; C.conserve_taylor_maps = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 31 + offset; C.absolute_time_tracking_default = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 32 + offset; C.convert_to_kinetic_momentum = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 33 + offset; C.aperture_limit_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 34 + offset; C.debug = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_bmad_common (Bmad_bmad_common_class* F, bool& c_ok) {

  CPP_bmad_common C, C2;

  c_ok = true;

  bmad_common_to_c (F, C);
  set_CPP_bmad_common_test_pattern (C2, 1);

  if (C == C2) {
    cout << " bmad_common: C side convert F->C: Good" << endl;
  } else {
    cout << " bmad_common: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bmad_common_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_bmad_common (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_bmad_common_test_pattern (C, 3);
  if (C == C2) {
    cout << " bmad_common: F side convert F->C: Good" << endl;
  } else {
    cout << " bmad_common: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bmad_common_test_pattern (C2, 4);
  bmad_common_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_rad_int1 (CPP_rad_int1&, bool&);

void set_CPP_rad_int1_test_pattern (CPP_rad_int1& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.i0 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.i1 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.i2 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 4 + offset; C.i3 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.i4a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.i4b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.i4z = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.i5a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 9 + offset; C.i5b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.i6b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 11 + offset; C.lin_i2_e4 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 12 + offset; C.lin_i3_e7 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 13 + offset; C.lin_i5a_e6 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 14 + offset; C.lin_i5b_e6 = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 15 + offset; C.lin_norm_emit_a = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 16 + offset; C.lin_norm_emit_b = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 17 + offset; C.n_steps = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_rad_int1 (Bmad_rad_int1_class* F, bool& c_ok) {

  CPP_rad_int1 C, C2;

  c_ok = true;

  rad_int1_to_c (F, C);
  set_CPP_rad_int1_test_pattern (C2, 1);

  if (C == C2) {
    cout << " rad_int1: C side convert F->C: Good" << endl;
  } else {
    cout << " rad_int1: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int1_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_rad_int1 (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_rad_int1_test_pattern (C, 3);
  if (C == C2) {
    cout << " rad_int1: F side convert F->C: Good" << endl;
  } else {
    cout << " rad_int1: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int1_test_pattern (C2, 4);
  rad_int1_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_rad_int_all_ele (CPP_rad_int_all_ele&, bool&);

void set_CPP_rad_int_all_ele_test_pattern (CPP_rad_int_all_ele& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.ele.resize(0);
  else {
    C.ele.resize(3);
    for (unsigned int i = 0; i < C.ele.size(); i++)  {set_CPP_rad_int1_test_pattern(C.ele[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_rad_int_all_ele (Bmad_rad_int_all_ele_class* F, bool& c_ok) {

  CPP_rad_int_all_ele C, C2;

  c_ok = true;

  rad_int_all_ele_to_c (F, C);
  set_CPP_rad_int_all_ele_test_pattern (C2, 1);

  if (C == C2) {
    cout << " rad_int_all_ele: C side convert F->C: Good" << endl;
  } else {
    cout << " rad_int_all_ele: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int_all_ele_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_rad_int_all_ele (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_rad_int_all_ele_test_pattern (C, 3);
  if (C == C2) {
    cout << " rad_int_all_ele: F side convert F->C: Good" << endl;
  } else {
    cout << " rad_int_all_ele: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_rad_int_all_ele_test_pattern (C2, 4);
  rad_int_all_ele_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_ptc_genfield (CPP_ptc_genfield&, bool&);

void set_CPP_ptc_genfield_test_pattern (CPP_ptc_genfield& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.vec0.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.vec0[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_ptc_genfield (Bmad_ptc_genfield_class* F, bool& c_ok) {

  CPP_ptc_genfield C, C2;

  c_ok = true;

  ptc_genfield_to_c (F, C);
  set_CPP_ptc_genfield_test_pattern (C2, 1);

  if (C == C2) {
    cout << " ptc_genfield: C side convert F->C: Good" << endl;
  } else {
    cout << " ptc_genfield: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ptc_genfield_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_ptc_genfield (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_ptc_genfield_test_pattern (C, 3);
  if (C == C2) {
    cout << " ptc_genfield: F side convert F->C: Good" << endl;
  } else {
    cout << " ptc_genfield: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ptc_genfield_test_pattern (C2, 4);
  ptc_genfield_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_ele (CPP_ele&, bool&);

void set_CPP_ele_test_pattern (CPP_ele& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.type.resize(40);
  for (unsigned int i = 0; i < C.type.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.type[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.alias.resize(40);
  for (unsigned int i = 0; i < C.alias.size(); i++)
    {int rhs = 101 + i + 3 + offset; C.alias[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.component_name.resize(40);
  for (unsigned int i = 0; i < C.component_name.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.component_name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, PTR]
  if (ix_patt < 3) 
    C.descrip == NULL;
  else {
    C.descrip = new string(200, ' ');
    for (unsigned int i = 0; i < C.descrip->size(); i++) {
      (*C.descrip)[i] = 'a' + (101 + i + 5 + offset) % 26; }
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.a, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.b, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.z, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_xy_disp_test_pattern(C.x, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_xy_disp_test_pattern(C.y, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_bookkeeping_state_test_pattern(C.bookkeeping_state, ix_patt);

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.control_var.resize(0);
  else {
    C.control_var.resize(3);
    for (unsigned int i = 0; i < C.control_var.size(); i++)  {set_CPP_controller_var_test_pattern(C.control_var[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.em_field = NULL;
  else {
    C.em_field = new CPP_em_fields;
    set_CPP_em_fields_test_pattern((*C.em_field), ix_patt);
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_floor_position_test_pattern(C.floor, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_ptc_genfield_test_pattern(C.ptc_genfield, ix_patt);

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.mode3 = NULL;
  else {
    C.mode3 = new CPP_mode3;
    set_CPP_mode3_test_pattern((*C.mode3), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.photon = NULL;
  else {
    C.photon = new CPP_photon_element;
    set_CPP_photon_element_test_pattern((*C.photon), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.rad_int_cache = NULL;
  else {
    C.rad_int_cache = new CPP_rad_int_ele_cache;
    set_CPP_rad_int_ele_cache_test_pattern((*C.rad_int_cache), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.space_charge = NULL;
  else {
    C.space_charge = new CPP_space_charge;
    set_CPP_space_charge_test_pattern((*C.space_charge), ix_patt);
  }

  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.taylor.size(); i++)
    {int rhs = 101 + i + 27 + offset; set_CPP_taylor_test_pattern(C.taylor[i], ix_patt+i+1);}
  // c_side.test_pat[type, 2, NOT]
  for (unsigned int i = 0; i < C.spin_taylor.size(); i++)  for (unsigned int j = 0; j < C.spin_taylor[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 28 + offset; set_CPP_taylor_test_pattern(C.spin_taylor[i][j], ix_patt+i+1+10*(j+1));}
  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.wake = NULL;
  else {
    C.wake = new CPP_wake;
    set_CPP_wake_test_pattern((*C.wake), ix_patt);
  }

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.wall3d.resize(0);
  else {
    C.wall3d.resize(3);
    for (unsigned int i = 0; i < C.wall3d.size(); i++)  {set_CPP_wall3d_test_pattern(C.wall3d[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.wig = NULL;
  else {
    C.wig = new CPP_wig;
    set_CPP_wig_test_pattern((*C.wig), ix_patt);
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.map_ref_orb_in, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.map_ref_orb_out, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.time_ref_orb_in, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.time_ref_orb_out, ix_patt);

  // c_side.test_pat[real, 1, NOT]
  C.value[0] = 0;
  for (unsigned int i = 1; i < Bmad::NUM_ELE_ATTRIB+1; i++)
    {int rhs = 100 + i + 39 + offset; C.value[i] = rhs;}

  // c_side.test_pat[real, 1, NOT]
  C.old_value[0] = 0;
  for (unsigned int i = 1; i < Bmad::NUM_ELE_ATTRIB+1; i++)
    {int rhs = 100 + i + 40 + offset; C.old_value[i] = rhs;}

  // c_side.test_pat[real, 1, NOT]
  for (unsigned int i = 0; i < C.vec0.size(); i++)
    {int rhs = 101 + i + 41 + offset; C.vec0[i] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.mat6.size(); i++)  for (unsigned int j = 0; j < C.mat6[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 42 + offset; C.mat6[i][j] = rhs;}
  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.c_mat.size(); i++)  for (unsigned int j = 0; j < C.c_mat[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 43 + offset; C.c_mat[i][j] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 44 + offset; C.gamma_c = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 45 + offset; C.s = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 46 + offset; C.ref_time = rhs;

  // c_side.test_pat[real, 3, PTR]
  if (ix_patt < 3) 
    C.r.resize(0);
  else {
    C.r.resize(3);
    for (unsigned int i = 0; i < C.r.size(); i++) {
      C.r[i].resize(2);
      for (unsigned int j = 0; j < C.r[0].size(); j++) {
        C.r[i][j].resize(1);
        for (unsigned int k = 0; k < C.r[0][0].size(); k++) {
          int rhs = 101 + i + 10*(j+1) + 100*(k+1) + 47 + offset; C.r[i][j][k] = rhs;
        }
      }
    }
  }

  // c_side.test_pat[real, 1, PTR]
  if (ix_patt < 3) 
    C.a_pole.resize(0);
  else {
    C.a_pole.resize(3);
    for (unsigned int i = 0; i < C.a_pole.size(); i++)
      {int rhs = 101 + i + 51 + offset; C.a_pole[i] = rhs;}  }

  // c_side.test_pat[real, 1, PTR]
  if (ix_patt < 3) 
    C.b_pole.resize(0);
  else {
    C.b_pole.resize(3);
    for (unsigned int i = 0; i < C.b_pole.size(); i++)
      {int rhs = 101 + i + 53 + offset; C.b_pole[i] = rhs;}  }

  // c_side.test_pat[real, 1, PTR]
  if (ix_patt < 3) 
    C.a_pole_elec.resize(0);
  else {
    C.a_pole_elec.resize(3);
    for (unsigned int i = 0; i < C.a_pole_elec.size(); i++)
      {int rhs = 101 + i + 55 + offset; C.a_pole_elec[i] = rhs;}  }

  // c_side.test_pat[real, 1, PTR]
  if (ix_patt < 3) 
    C.b_pole_elec.resize(0);
  else {
    C.b_pole_elec.resize(3);
    for (unsigned int i = 0; i < C.b_pole_elec.size(); i++)
      {int rhs = 101 + i + 57 + offset; C.b_pole_elec[i] = rhs;}  }

  // c_side.test_pat[integer, 0, NOT]
  rhs = 59 + offset; C.key = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 60 + offset; C.sub_key = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 61 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 62 + offset; C.ix_branch = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 63 + offset; C.slave_status = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 64 + offset; C.n_slave = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 65 + offset; C.n_slave_field = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 66 + offset; C.ix1_slave = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 67 + offset; C.lord_status = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 68 + offset; C.n_lord = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 69 + offset; C.n_lord_field = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 70 + offset; C.ic1_lord = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 71 + offset; C.ix_pointer = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 72 + offset; C.ixx = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 73 + offset; C.iyy = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 74 + offset; C.mat6_calc_method = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 75 + offset; C.tracking_method = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 76 + offset; C.spin_tracking_method = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 77 + offset; C.ptc_integration_type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 78 + offset; C.field_calc = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 79 + offset; C.aperture_at = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 80 + offset; C.aperture_type = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 81 + offset; C.orientation = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 82 + offset; C.symplectify = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 83 + offset; C.mode_flip = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 84 + offset; C.multipoles_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 85 + offset; C.scale_multipoles = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 86 + offset; C.taylor_map_includes_offsets = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 87 + offset; C.field_master = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 88 + offset; C.is_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 89 + offset; C.logic = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 90 + offset; C.bmad_logic = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 91 + offset; C.select = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 92 + offset; C.csr_calc_on = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 93 + offset; C.offset_moves_aperture = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_ele (Bmad_ele_class* F, bool& c_ok) {

  CPP_ele C, C2;

  c_ok = true;

  ele_to_c (F, C);
  set_CPP_ele_test_pattern (C2, 1);

  if (C == C2) {
    cout << " ele: C side convert F->C: Good" << endl;
  } else {
    cout << " ele: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ele_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_ele (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_ele_test_pattern (C, 3);
  if (C == C2) {
    cout << " ele: F side convert F->C: Good" << endl;
  } else {
    cout << " ele: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_ele_test_pattern (C2, 4);
  ele_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_complex_taylor_term (CPP_complex_taylor_term&, bool&);

void set_CPP_complex_taylor_term_test_pattern (CPP_complex_taylor_term& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[complex, 0, NOT]
  rhs = 1 + offset; C.coef = Complex(rhs, 100+rhs);

  // c_side.test_pat[integer, 1, NOT]
  for (unsigned int i = 0; i < C.expn.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.expn[i] = rhs;}

}

//--------------------------------------------------------------

extern "C" void test_c_complex_taylor_term (Bmad_complex_taylor_term_class* F, bool& c_ok) {

  CPP_complex_taylor_term C, C2;

  c_ok = true;

  complex_taylor_term_to_c (F, C);
  set_CPP_complex_taylor_term_test_pattern (C2, 1);

  if (C == C2) {
    cout << " complex_taylor_term: C side convert F->C: Good" << endl;
  } else {
    cout << " complex_taylor_term: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_complex_taylor_term_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_complex_taylor_term (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_complex_taylor_term_test_pattern (C, 3);
  if (C == C2) {
    cout << " complex_taylor_term: F side convert F->C: Good" << endl;
  } else {
    cout << " complex_taylor_term: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_complex_taylor_term_test_pattern (C2, 4);
  complex_taylor_term_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_complex_taylor (CPP_complex_taylor&, bool&);

void set_CPP_complex_taylor_test_pattern (CPP_complex_taylor& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[complex, 0, NOT]
  rhs = 1 + offset; C.ref = Complex(rhs, 100+rhs);

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.term.resize(0);
  else {
    C.term.resize(3);
    for (unsigned int i = 0; i < C.term.size(); i++)  {set_CPP_complex_taylor_term_test_pattern(C.term[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_complex_taylor (Bmad_complex_taylor_class* F, bool& c_ok) {

  CPP_complex_taylor C, C2;

  c_ok = true;

  complex_taylor_to_c (F, C);
  set_CPP_complex_taylor_test_pattern (C2, 1);

  if (C == C2) {
    cout << " complex_taylor: C side convert F->C: Good" << endl;
  } else {
    cout << " complex_taylor: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_complex_taylor_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_complex_taylor (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_complex_taylor_test_pattern (C, 3);
  if (C == C2) {
    cout << " complex_taylor: F side convert F->C: Good" << endl;
  } else {
    cout << " complex_taylor: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_complex_taylor_test_pattern (C2, 4);
  complex_taylor_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_normal_form (CPP_normal_form&, bool&);

void set_CPP_normal_form_test_pattern (CPP_normal_form& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.m.size(); i++)
    {int rhs = 101 + i + 1 + offset; set_CPP_taylor_test_pattern(C.m[i], ix_patt+i+1);}
  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.a.size(); i++)
    {int rhs = 101 + i + 2 + offset; set_CPP_taylor_test_pattern(C.a[i], ix_patt+i+1);}
  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.a_inv.size(); i++)
    {int rhs = 101 + i + 3 + offset; set_CPP_taylor_test_pattern(C.a_inv[i], ix_patt+i+1);}
  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.dhdj.size(); i++)
    {int rhs = 101 + i + 4 + offset; set_CPP_taylor_test_pattern(C.dhdj[i], ix_patt+i+1);}
  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.f.size(); i++)
    {int rhs = 101 + i + 5 + offset; set_CPP_complex_taylor_test_pattern(C.f[i], ix_patt+i+1);}
  // c_side.test_pat[type, 1, NOT]
  for (unsigned int i = 0; i < C.l.size(); i++)
    {int rhs = 101 + i + 6 + offset; set_CPP_complex_taylor_test_pattern(C.l[i], ix_patt+i+1);}
  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.ele_origin = NULL;
  else {
    C.ele_origin = new CPP_ele;
    set_CPP_ele_test_pattern((*C.ele_origin), ix_patt);
  }


}

//--------------------------------------------------------------

extern "C" void test_c_normal_form (Bmad_normal_form_class* F, bool& c_ok) {

  CPP_normal_form C, C2;

  c_ok = true;

  normal_form_to_c (F, C);
  set_CPP_normal_form_test_pattern (C2, 1);

  if (C == C2) {
    cout << " normal_form: C side convert F->C: Good" << endl;
  } else {
    cout << " normal_form: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_normal_form_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_normal_form (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_normal_form_test_pattern (C, 3);
  if (C == C2) {
    cout << " normal_form: F side convert F->C: Good" << endl;
  } else {
    cout << " normal_form: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_normal_form_test_pattern (C2, 4);
  normal_form_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_branch (CPP_branch&, bool&);

void set_CPP_branch_test_pattern (CPP_branch& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.name.resize(40);
  for (unsigned int i = 0; i < C.name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[integer, 0, NOT]
  rhs = 2 + offset; C.ix_branch = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 3 + offset; C.ix_from_branch = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 4 + offset; C.ix_from_ele = rhs;

  // c_side.test_pat[integer, 0, PTR]
  if (ix_patt < 3) 
    C.n_ele_track = NULL;
  else {
    C.n_ele_track = new Int;
    rhs = 5 + offset; (*C.n_ele_track) = rhs;
  }

  // c_side.test_pat[integer, 0, PTR]
  if (ix_patt < 3) 
    C.n_ele_max = NULL;
  else {
    C.n_ele_max = new Int;
    rhs = 7 + offset; (*C.n_ele_max) = rhs;
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.a = NULL;
  else {
    C.a = new CPP_mode_info;
    set_CPP_mode_info_test_pattern((*C.a), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.b = NULL;
  else {
    C.b = new CPP_mode_info;
    set_CPP_mode_info_test_pattern((*C.b), ix_patt);
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.z = NULL;
  else {
    C.z = new CPP_mode_info;
    set_CPP_mode_info_test_pattern((*C.z), ix_patt);
  }

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.ele.resize(0);
  else {
    C.ele.resize(3);
    for (unsigned int i = 0; i < C.ele.size(); i++)  {set_CPP_ele_test_pattern(C.ele[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, PTR]
  if (ix_patt < 3) 
    C.param = NULL;
  else {
    C.param = new CPP_lat_param;
    set_CPP_lat_param_test_pattern((*C.param), ix_patt);
  }

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.wall3d.resize(0);
  else {
    C.wall3d.resize(3);
    for (unsigned int i = 0; i < C.wall3d.size(); i++)  {set_CPP_wall3d_test_pattern(C.wall3d[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_normal_form_test_pattern(C.normal_form_with_rf, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_normal_form_test_pattern(C.normal_form_no_rf, ix_patt);


}

//--------------------------------------------------------------

extern "C" void test_c_branch (Bmad_branch_class* F, bool& c_ok) {

  CPP_branch C, C2;

  c_ok = true;

  branch_to_c (F, C);
  set_CPP_branch_test_pattern (C2, 1);

  if (C == C2) {
    cout << " branch: C side convert F->C: Good" << endl;
  } else {
    cout << " branch: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_branch_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_branch (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_branch_test_pattern (C, 3);
  if (C == C2) {
    cout << " branch: F side convert F->C: Good" << endl;
  } else {
    cout << " branch: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_branch_test_pattern (C2, 4);
  branch_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_lat (CPP_lat&, bool&);

void set_CPP_lat_test_pattern (CPP_lat& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[character, 0, NOT]
  C.use_name.resize(40);
  for (unsigned int i = 0; i < C.use_name.size(); i++)
    {int rhs = 101 + i + 1 + offset; C.use_name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.lattice.resize(40);
  for (unsigned int i = 0; i < C.lattice.size(); i++)
    {int rhs = 101 + i + 2 + offset; C.lattice[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.input_file_name.resize(200);
  for (unsigned int i = 0; i < C.input_file_name.size(); i++)
    {int rhs = 101 + i + 3 + offset; C.input_file_name[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 0, NOT]
  C.title.resize(80);
  for (unsigned int i = 0; i < C.title.size(); i++)
    {int rhs = 101 + i + 4 + offset; C.title[i] = 'a' + rhs % 26;}
  // c_side.test_pat[character, 1, ALLOC]
  if (ix_patt < 3) 
    C.attribute_alias.resize(0);
  else {
    C.attribute_alias.resize(3);
    for (unsigned int i = 0; i < C.attribute_alias.size(); i++){
      C.attribute_alias[i].resize(60);
      for (unsigned int j = 0; j < C.attribute_alias[0].size(); j++) {
        C.attribute_alias[i][j] = 'a' + (101 + i + 10*(j+1) + 5 + offset) % 26;
    } }
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_mode_info_test_pattern(C.a, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_mode_info_test_pattern(C.b, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_mode_info_test_pattern(C.z, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_lat_param_test_pattern(C.param, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_bookkeeping_state_test_pattern(C.lord_state, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_ele_test_pattern(C.ele_init, ix_patt);

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.ele.resize(0);
  else {
    C.ele.resize(3);
    for (unsigned int i = 0; i < C.ele.size(); i++)  {set_CPP_ele_test_pattern(C.ele[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.branch.resize(0);
  else {
    C.branch.resize(3);
    for (unsigned int i = 0; i < C.branch.size(); i++)  {set_CPP_branch_test_pattern(C.branch[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.control.resize(0);
  else {
    C.control.resize(3);
    for (unsigned int i = 0; i < C.control.size(); i++)  {set_CPP_control_test_pattern(C.control[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 1, PTR]
  if (ix_patt < 3) 
    C.surface.resize(0);
  else {
    C.surface.resize(3);
    for (unsigned int i = 0; i < C.surface.size(); i++)  {set_CPP_photon_reflect_surface_test_pattern(C.surface[i], ix_patt+i+1);}
  }

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.beam_start, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_pre_tracker_test_pattern(C.pre_tracker, ix_patt);

  // c_side.test_pat[integer, 0, NOT]
  rhs = 23 + offset; C.version = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 24 + offset; C.n_ele_track = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 25 + offset; C.n_ele_max = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 26 + offset; C.n_control_max = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 27 + offset; C.n_ic_max = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 28 + offset; C.input_taylor_order = rhs;

  // c_side.test_pat[integer, 1, ALLOC]
  if (ix_patt < 3) 
    C.ic.resize(0);
  else {
    C.ic.resize(3);
    for (unsigned int i = 0; i < C.ic.size(); i++)
      {int rhs = 101 + i + 29 + offset; C.ic[i] = rhs;}  }

  // c_side.test_pat[integer, 0, NOT]
  rhs = 31 + offset; C.photon_type = rhs;

  // c_side.test_pat[logical, 0, NOT]
  rhs = 32 + offset; C.absolute_time_tracking = (rhs % 2 == 0);

  // c_side.test_pat[logical, 0, NOT]
  rhs = 33 + offset; C.ptc_uses_hard_edge_drifts = (rhs % 2 == 0);


}

//--------------------------------------------------------------

extern "C" void test_c_lat (Bmad_lat_class* F, bool& c_ok) {

  CPP_lat C, C2;

  c_ok = true;

  lat_to_c (F, C);
  set_CPP_lat_test_pattern (C2, 1);

  if (C == C2) {
    cout << " lat: C side convert F->C: Good" << endl;
  } else {
    cout << " lat: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_lat (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_lat_test_pattern (C, 3);
  if (C == C2) {
    cout << " lat: F side convert F->C: Good" << endl;
  } else {
    cout << " lat: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_lat_test_pattern (C2, 4);
  lat_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_bunch (CPP_bunch&, bool&);

void set_CPP_bunch_test_pattern (CPP_bunch& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.particle.resize(0);
  else {
    C.particle.resize(3);
    for (unsigned int i = 0; i < C.particle.size(); i++)  {set_CPP_coord_test_pattern(C.particle[i], ix_patt+i+1);}
  }

  // c_side.test_pat[integer, 1, ALLOC]
  if (ix_patt < 3) 
    C.ix_z.resize(0);
  else {
    C.ix_z.resize(3);
    for (unsigned int i = 0; i < C.ix_z.size(); i++)
      {int rhs = 101 + i + 3 + offset; C.ix_z[i] = rhs;}  }

  // c_side.test_pat[real, 0, NOT]
  rhs = 5 + offset; C.charge_tot = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 6 + offset; C.charge_live = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 7 + offset; C.z_center = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 8 + offset; C.t_center = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 9 + offset; C.ix_ele = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 10 + offset; C.ix_bunch = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_bunch (Bmad_bunch_class* F, bool& c_ok) {

  CPP_bunch C, C2;

  c_ok = true;

  bunch_to_c (F, C);
  set_CPP_bunch_test_pattern (C2, 1);

  if (C == C2) {
    cout << " bunch: C side convert F->C: Good" << endl;
  } else {
    cout << " bunch: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bunch_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_bunch (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_bunch_test_pattern (C, 3);
  if (C == C2) {
    cout << " bunch: F side convert F->C: Good" << endl;
  } else {
    cout << " bunch: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bunch_test_pattern (C2, 4);
  bunch_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_beam_spin (CPP_beam_spin&, bool&);

void set_CPP_beam_spin_test_pattern (CPP_beam_spin& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[real, 0, NOT]
  rhs = 1 + offset; C.polarization = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 2 + offset; C.theta = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 3 + offset; C.phi = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_beam_spin (Bmad_beam_spin_class* F, bool& c_ok) {

  CPP_beam_spin C, C2;

  c_ok = true;

  beam_spin_to_c (F, C);
  set_CPP_beam_spin_test_pattern (C2, 1);

  if (C == C2) {
    cout << " beam_spin: C side convert F->C: Good" << endl;
  } else {
    cout << " beam_spin: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_beam_spin_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_beam_spin (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_beam_spin_test_pattern (C, 3);
  if (C == C2) {
    cout << " beam_spin: F side convert F->C: Good" << endl;
  } else {
    cout << " beam_spin: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_beam_spin_test_pattern (C2, 4);
  beam_spin_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_bunch_params (CPP_bunch_params&, bool&);

void set_CPP_bunch_params_test_pattern (CPP_bunch_params& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.x, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.y, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.z, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.a, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.b, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_twiss_test_pattern(C.c, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_coord_test_pattern(C.centroid, ix_patt);

  // c_side.test_pat[type, 0, NOT]
  set_CPP_beam_spin_test_pattern(C.spin, ix_patt);

  // c_side.test_pat[real, 2, NOT]
  for (unsigned int i = 0; i < C.sigma.size(); i++)  for (unsigned int j = 0; j < C.sigma[0].size(); j++) 
    {int rhs = 101 + i + 10*(j+1) + 9 + offset; C.sigma[i][j] = rhs;}
  // c_side.test_pat[real, 0, NOT]
  rhs = 10 + offset; C.s = rhs;

  // c_side.test_pat[real, 0, NOT]
  rhs = 11 + offset; C.charge_live = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 12 + offset; C.n_particle_tot = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 13 + offset; C.n_particle_live = rhs;

  // c_side.test_pat[integer, 0, NOT]
  rhs = 14 + offset; C.n_particle_lost_in_ele = rhs;


}

//--------------------------------------------------------------

extern "C" void test_c_bunch_params (Bmad_bunch_params_class* F, bool& c_ok) {

  CPP_bunch_params C, C2;

  c_ok = true;

  bunch_params_to_c (F, C);
  set_CPP_bunch_params_test_pattern (C2, 1);

  if (C == C2) {
    cout << " bunch_params: C side convert F->C: Good" << endl;
  } else {
    cout << " bunch_params: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bunch_params_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_bunch_params (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_bunch_params_test_pattern (C, 3);
  if (C == C2) {
    cout << " bunch_params: F side convert F->C: Good" << endl;
  } else {
    cout << " bunch_params: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_bunch_params_test_pattern (C2, 4);
  bunch_params_to_f (C2, F);

}

//--------------------------------------------------------------
//--------------------------------------------------------------

extern "C" void test2_f_beam (CPP_beam&, bool&);

void set_CPP_beam_test_pattern (CPP_beam& C, int ix_patt) {

  int rhs, offset = 100 * ix_patt;

  // c_side.test_pat[type, 1, ALLOC]
  if (ix_patt < 3) 
    C.bunch.resize(0);
  else {
    C.bunch.resize(3);
    for (unsigned int i = 0; i < C.bunch.size(); i++)  {set_CPP_bunch_test_pattern(C.bunch[i], ix_patt+i+1);}
  }


}

//--------------------------------------------------------------

extern "C" void test_c_beam (Bmad_beam_class* F, bool& c_ok) {

  CPP_beam C, C2;

  c_ok = true;

  beam_to_c (F, C);
  set_CPP_beam_test_pattern (C2, 1);

  if (C == C2) {
    cout << " beam: C side convert F->C: Good" << endl;
  } else {
    cout << " beam: C SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_beam_test_pattern (C2, 2);
  bool c_ok2;
  test2_f_beam (C2, c_ok2);
  if (!c_ok2) c_ok = false;

  set_CPP_beam_test_pattern (C, 3);
  if (C == C2) {
    cout << " beam: F side convert F->C: Good" << endl;
  } else {
    cout << " beam: F SIDE CONVERT F->C: FAILED!" << endl;
    c_ok = false;
  }

  set_CPP_beam_test_pattern (C2, 4);
  beam_to_f (C2, F);

}
