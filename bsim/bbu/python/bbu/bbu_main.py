#!/usr/bin/env python3

import subprocess
from bbu import find_threshold, drscan, phase_scan
import os
import math

# Parse the tracking result of a bbu run
# In: for_py.txt file generated by the bbu run
# Out: the parsed result, dictionary d
def parse_for_py(filename='for_py.txt'):
  d = {}
  f =  open(filename,'r')
  for line in f:
    line = line.strip()
    key, value = line.replace(' ','').split('=')
    if len(key) > 0:
      if (key == 'lostbool' or key == 'growth_rate_set'):
        if (value == 'True'): val = True
        elif (value == 'False'): val = False
        d[key] = val
      else:
        d[key] = float(value)
  f.close()
  return d

#==========================================================

def single_threshold( py_par ):
  
  my_file = open(os.path.join(py_par['temp_dir'],'thresholds.txt'), 'a')
  
#  if ( os.path.exists(os.path.join(py_par['temp_dir'],"for_py.txt")) ): os.remove(os.path.join(py_par['temp_dir'],"for_py.txt"))    

  is_Ith_found, final_curr = loop_to_pin_down_Ith(py_par, 'threshold')
  
  if (is_Ith_found):
    my_file.write(str(final_curr)+'\n')
  else:
    my_file.write('DID NOT CONVERGE\n')
  print('JUST WROTE TO thresholds.txt in the temporary directory')
  
  my_file.close()
#========================================================================    


def drscanner( py_par ):
  # Create thres_v_trotb.txt in temp_dir to store the computed Ith for each tr/tb 
  my_file = open(os.path.join(py_par['temp_dir'],'thresh_v_trotb.txt'),'w')

  # Define step size
  if(py_par['ndata_pnts_DR'] >= 2):
    print('Caution: Too many ndata_pnts_DR may take a long time!!')
    step_size = (py_par['end_dr_arctime']-py_par['start_dr_arctime'])/(py_par['ndata_pnts_DR']-1)
  elif(py_par['ndata_pnts_DR'] == 1):
    print('Just one data point.')
    step_size = 0
  else:
    print('Invalid ndata_pnts_DR specified!!!')

  for n in range (0, py_par['ndata_pnts_DR']):
    
    temp_arctime = py_par['start_dr_arctime'] + n*(step_size)
    # Make lat2 file to vary the arctime (i.e. vary arclength)
    drscan.setup_drscan( temp_arctime, py_par ) 

    is_Ith_found, final_curr = loop_to_pin_down_Ith(py_par, 'drscan')
    d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt')) # just to retrieve d['bunch_dt']
    if (is_Ith_found):
      trotb = temp_arctime / d['bunch_dt'] #tr/tb
      my_file.write(str(trotb)+'	'+str(final_curr)+'\n')
    else:
      my_file.write('DID NOT CONVERGE\n')
      print('JUST WROTE TO thresh_v_trotb.txt in the temporary directory')

  my_file.close()

  # If requested, plot Log(Ith) vs tr/tb for all arctimes 
  if (py_par['plot_drscan']):
    print('Producing plot(s). To continue, exit the plots.') 
    drscan.make_dr_plot(py_par)  


#def loop_to_pin_down_Ith(py_par, t, d):
# Mode allowed: 'threshold', 'drscan', 'phase_scan', 'phase_xy_scan'
def loop_to_pin_down_Ith(py_par, mode):
  t  = {'charge0':0,'charge1':-1,'growth_rate':0,'bunch_charge':0}
  find_threshold.run_bbu( py_par['threshold_start_curr'], py_par, mode )
  d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt')) # parse the result (from Fortran to Python)
  t['bunch_charge'] = py_par['threshold_start_curr'] * d['bunch_dt']   
  
  keep_looking = 1
  while ( keep_looking ):   # Nudge stable current very close to the higher, unstable current
    t['growth_rate'] = d['growth_rate']
    bool_stable = find_threshold.get_stability(d['v_gain'], d['lostbool']) #check stability 
    find_threshold.calc_new_charge( t, bool_stable ) # update t based on the stability of the test current
    temp_curr = t['bunch_charge'] / d['bunch_dt']                # compute new test current with updated t[bunch_charge]
    find_threshold.run_bbu( temp_curr, py_par, mode )    # Try the new test current
    d = parse_for_py(os.path.join(py_par['temp_dir'],'for_py.txt'))
    
    # If the difference between min_I_unstable and max_I_stable is within the tolerance, Ith is considered found 
    #if ( abs(t['charge1'] - t['charge0']) < abs(t['charge1']*d['rel_tol']) ): 
    if ( abs(t['charge1'] - t['charge0']) < abs(t['charge1']*py_par['final_rel_tol']) ): 
      keep_looking = 0 
      Ith_found = 1
      print('= = = Ith found = = =')
    if ( temp_curr < 10**-12 or temp_curr > 10**5 ): 
      keep_looking = 0
      Ith_found = 0
      print('==!!==!!==!!==')
      print('	THRESHOLD DID NOT CONVERGE WITHIN BOUNDS')
      if (temp_curr < 10**-12):
        print('Test current below 10^-12 A, no stable current found')
      else:
        print('Test current above 10^5 A, no unstable current found')
  d.clear()
  t.clear()
  return Ith_found, temp_curr

#==========================================================================

def phase_scanner( py_par ):
  # Create thres_v_phase.txt in temp_dir to store the computed Ith for each phase
  my_file = open(os.path.join(py_par['temp_dir'],'thresh_v_phase.txt'),'w')
  
  # Define step size
  if(py_par['ndata_pnts_PHASE'] >= 2):
    print('Caution: Too many ndata_pnts_PHASE may take a long time!!')
    step_size = (py_par['end_phase']-py_par['start_phase'])/(py_par['ndata_pnts_PHASE']-1)
  elif(py_par['ndata_pnts_PHASE'] == 1):
    print('Just one data point.')
    step_size = 0
  else:
    print('Invalid ndata_pnts_PHASE specified!!! ')

  # Looping over phases 
  for n in range (0, py_par['ndata_pnts_PHASE']):
    
    if (step_size > 0):  # If step_size is not defined, user has given invalid ndata_pnts_PHASE
      temp_phase = py_par['start_phase'] + n*(step_size)    # For scan (more than one data point, can be slow)
    elif (step_size == 0):
      temp_phase = py_par['ONE_phase']                      # For one data point
    
    # Make lat2 file with the temp_phase
    phase_scan.setup_phase_scan( temp_phase, py_par ) 

    is_Ith_found, final_curr = loop_to_pin_down_Ith(py_par, 'phase_scan')
    
    if (is_Ith_found):
      my_file.write(str(temp_phase)+'	'+str(final_curr)+'\n')
    else:
      my_file.write('DID NOT CONVERGE\n')
    print('JUST WROTE TO thresh_v_phase.txt in the temporary directory')

  my_file.close()

  # If requested, plot Log(Ith) vs phase 
  if (py_par['plot_phase_scan']):
    print('Producing plot(s). To continue, exit the plots.') 
    phase_scan.make_phase_plot(py_par)  

#==========================================================================

def phase_xy_scanner( py_par ):

  # Create thres_v_phase.txt in temp_dir to store the computed Ith for each phase combination
  my_file = open(os.path.join(py_par['temp_dir'],'thresh_v_phase_xy.txt'),'w')
    
  # Make lat2 file with the two temp_phases
  phase_scan.setup_phase_xy_scan( py_par ) 

  # For a specific x-y phase combination, find the Ith
  is_Ith_found, final_curr = loop_to_pin_down_Ith(py_par, 'phase_xy_scan')
  if (is_Ith_found):
    my_file.write(str(py_par['phase_x'])+' '+str(py_par['phase_y'])+'	'+str(final_curr)+'\n')
  else:
    my_file.write('DID NOT CONVERGE\n')
  print('JUST WROTE TO thresh_v_phase_xy.txt in the temporary directory')
  my_file.close()

