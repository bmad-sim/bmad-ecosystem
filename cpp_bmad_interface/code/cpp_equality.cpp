
//+
// C++ equality functions for Bmad / C++ structure interface.
//
// This file is generated as part of the Bmad/C++ interface code generation.
// The code generation files can be found in cpp_bmad_interface.
//
// DO NOT EDIT THIS FILE DIRECTLY! 
//-

#include <iostream>
#include <stdlib.h>
#include "cpp_bmad_classes.h"

using namespace std;

//---------------------------------------------------

template <class T> bool is_all_equal (const valarray<T>& vec1, const valarray<T>& vec2) {
  bool is_eq = true;
  if (vec1.size() != vec2.size()) return false;
  for (unsigned int i = 0; i < vec1.size(); i++) {
    is_eq = is_eq && (vec1[i] == vec2[i]);
  }
  return is_eq;
}

template <class T> bool is_all_equal (const valarray< valarray<T> >& mat1, const valarray< valarray<T> >& mat2) {
  bool is_eq = true;
  if (mat1.size() != mat2.size()) return false;
  for (unsigned int i = 0; i < mat1.size(); i++) {
    if (mat1[i].size() != mat2[i].size()) return false;
    for (unsigned int j = 0; j < mat1[i].size(); j++) {
      is_eq = is_eq && (mat1[i][j] == mat2[i][j]);
    }
  }
  return is_eq;
};

template <class T> bool is_all_equal (const valarray< valarray< valarray<T> > >& tensor1, const valarray< valarray< valarray<T> > >& tensor2) {
  bool is_eq = true;
  if (tensor1.size() != tensor2.size()) return false;
  for (unsigned int i = 0; i < tensor1.size(); i++) {
    if (tensor1[i].size() != tensor2[i].size()) return false;
    for (unsigned int j = 0; j < tensor1[i].size(); j++) {
      if (tensor1[i][j].size() != tensor2[i][j].size()) return false;
      for (unsigned int k = 0; k < tensor1[i][j].size(); k++) {
        is_eq = is_eq && (tensor1[i][j][k] == tensor2[i][j][k]);
      }
    }
  }
  return is_eq;
};

//---------------------------------------------------

template bool is_all_equal (const Bool_ARRAY&,     const Bool_ARRAY&);
template bool is_all_equal (const Complex_ARRAY&,  const Complex_ARRAY&);
template bool is_all_equal (const Real_ARRAY&,     const Real_ARRAY&);
template bool is_all_equal (const Int_ARRAY&,      const Int_ARRAY&);
template bool is_all_equal (const String_ARRAY&,   const String_ARRAY&);

template bool is_all_equal (const Bool_MATRIX&,     const Bool_MATRIX&);
template bool is_all_equal (const Complex_MATRIX&,  const Complex_MATRIX&);
template bool is_all_equal (const Real_MATRIX&,     const Real_MATRIX&);
template bool is_all_equal (const Int_MATRIX&,      const Int_MATRIX&);

template bool is_all_equal (const Complex_TENSOR&,  const Complex_TENSOR&);
template bool is_all_equal (const Real_TENSOR&,     const Real_TENSOR&);
template bool is_all_equal (const Int_TENSOR&,      const Int_TENSOR&);


//--------------------------------------------------------------

bool operator== (const CPP_spline& x, const CPP_spline& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.x0 == y.x0);
  is_eq = is_eq && (x.y0 == y.y0);
  is_eq = is_eq && (x.x1 == y.x1);
  is_eq = is_eq && is_all_equal(x.coef, y.coef);
  return is_eq;
};

template bool is_all_equal (const CPP_spline_ARRAY&, const CPP_spline_ARRAY&);
template bool is_all_equal (const CPP_spline_MATRIX&, const CPP_spline_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_spin_polar& x, const CPP_spin_polar& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.polarization == y.polarization);
  is_eq = is_eq && (x.theta == y.theta);
  is_eq = is_eq && (x.phi == y.phi);
  is_eq = is_eq && (x.xi == y.xi);
  return is_eq;
};

template bool is_all_equal (const CPP_spin_polar_ARRAY&, const CPP_spin_polar_ARRAY&);
template bool is_all_equal (const CPP_spin_polar_MATRIX&, const CPP_spin_polar_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_surface_orientation& x, const CPP_surface_orientation& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.dz_dx == y.dz_dx);
  is_eq = is_eq && (x.dz_dy == y.dz_dy);
  is_eq = is_eq && (x.dz_dx_rms == y.dz_dx_rms);
  is_eq = is_eq && (x.dz_dy_rms == y.dz_dy_rms);
  is_eq = is_eq && (x.dz2_dxdy == y.dz2_dxdy);
  return is_eq;
};

template bool is_all_equal (const CPP_surface_orientation_ARRAY&, const CPP_surface_orientation_ARRAY&);
template bool is_all_equal (const CPP_surface_orientation_MATRIX&, const CPP_surface_orientation_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_ac_kicker_time& x, const CPP_ac_kicker_time& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.amp == y.amp);
  is_eq = is_eq && (x.time == y.time);
  is_eq = is_eq && (x.spline == y.spline);
  return is_eq;
};

template bool is_all_equal (const CPP_ac_kicker_time_ARRAY&, const CPP_ac_kicker_time_ARRAY&);
template bool is_all_equal (const CPP_ac_kicker_time_MATRIX&, const CPP_ac_kicker_time_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_ac_kicker_freq& x, const CPP_ac_kicker_freq& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.f == y.f);
  is_eq = is_eq && (x.amp == y.amp);
  is_eq = is_eq && (x.phi == y.phi);
  is_eq = is_eq && (x.rf_clock_harmonic == y.rf_clock_harmonic);
  return is_eq;
};

template bool is_all_equal (const CPP_ac_kicker_freq_ARRAY&, const CPP_ac_kicker_freq_ARRAY&);
template bool is_all_equal (const CPP_ac_kicker_freq_MATRIX&, const CPP_ac_kicker_freq_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_ac_kicker& x, const CPP_ac_kicker& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.amp_vs_time, y.amp_vs_time);
  is_eq = is_eq && is_all_equal(x.frequency, y.frequency);
  return is_eq;
};

template bool is_all_equal (const CPP_ac_kicker_ARRAY&, const CPP_ac_kicker_ARRAY&);
template bool is_all_equal (const CPP_ac_kicker_MATRIX&, const CPP_ac_kicker_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_interval1_coef& x, const CPP_interval1_coef& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.c0 == y.c0);
  is_eq = is_eq && (x.c1 == y.c1);
  is_eq = is_eq && (x.n_exp == y.n_exp);
  return is_eq;
};

template bool is_all_equal (const CPP_interval1_coef_ARRAY&, const CPP_interval1_coef_ARRAY&);
template bool is_all_equal (const CPP_interval1_coef_MATRIX&, const CPP_interval1_coef_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_photon_reflect_table& x, const CPP_photon_reflect_table& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.angle, y.angle);
  is_eq = is_eq && is_all_equal(x.energy, y.energy);
  is_eq = is_eq && is_all_equal(x.int1, y.int1);
  is_eq = is_eq && is_all_equal(x.p_reflect, y.p_reflect);
  is_eq = is_eq && (x.max_energy == y.max_energy);
  is_eq = is_eq && is_all_equal(x.p_reflect_scratch, y.p_reflect_scratch);
  is_eq = is_eq && is_all_equal(x.bragg_angle, y.bragg_angle);
  return is_eq;
};

template bool is_all_equal (const CPP_photon_reflect_table_ARRAY&, const CPP_photon_reflect_table_ARRAY&);
template bool is_all_equal (const CPP_photon_reflect_table_MATRIX&, const CPP_photon_reflect_table_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_photon_reflect_surface& x, const CPP_photon_reflect_surface& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.name == y.name);
  is_eq = is_eq && (x.description == y.description);
  is_eq = is_eq && (x.reflectivity_file == y.reflectivity_file);
  is_eq = is_eq && is_all_equal(x.table, y.table);
  is_eq = is_eq && (x.surface_roughness_rms == y.surface_roughness_rms);
  is_eq = is_eq && (x.roughness_correlation_len == y.roughness_correlation_len);
  is_eq = is_eq && (x.ix_surface == y.ix_surface);
  return is_eq;
};

template bool is_all_equal (const CPP_photon_reflect_surface_ARRAY&, const CPP_photon_reflect_surface_ARRAY&);
template bool is_all_equal (const CPP_photon_reflect_surface_MATRIX&, const CPP_photon_reflect_surface_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_coord& x, const CPP_coord& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.vec, y.vec);
  is_eq = is_eq && (x.s == y.s);
  is_eq = is_eq && (x.t == y.t);
  is_eq = is_eq && is_all_equal(x.spin, y.spin);
  is_eq = is_eq && is_all_equal(x.field, y.field);
  is_eq = is_eq && is_all_equal(x.phase, y.phase);
  is_eq = is_eq && (x.charge == y.charge);
  is_eq = is_eq && (x.dt_ref == y.dt_ref);
  is_eq = is_eq && (x.r == y.r);
  is_eq = is_eq && (x.p0c == y.p0c);
  is_eq = is_eq && (x.e_potential == y.e_potential);
  is_eq = is_eq && (x.beta == y.beta);
  is_eq = is_eq && (x.ix_ele == y.ix_ele);
  is_eq = is_eq && (x.ix_branch == y.ix_branch);
  is_eq = is_eq && (x.ix_turn == y.ix_turn);
  is_eq = is_eq && (x.ix_user == y.ix_user);
  is_eq = is_eq && (x.state == y.state);
  is_eq = is_eq && (x.direction == y.direction);
  is_eq = is_eq && (x.time_dir == y.time_dir);
  is_eq = is_eq && (x.species == y.species);
  is_eq = is_eq && (x.location == y.location);
  return is_eq;
};

template bool is_all_equal (const CPP_coord_ARRAY&, const CPP_coord_ARRAY&);
template bool is_all_equal (const CPP_coord_MATRIX&, const CPP_coord_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_coord_array& x, const CPP_coord_array& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.orbit, y.orbit);
  return is_eq;
};

template bool is_all_equal (const CPP_coord_array_ARRAY&, const CPP_coord_array_ARRAY&);
template bool is_all_equal (const CPP_coord_array_MATRIX&, const CPP_coord_array_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_bpm_phase_coupling& x, const CPP_bpm_phase_coupling& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.k_22a == y.k_22a);
  is_eq = is_eq && (x.k_12a == y.k_12a);
  is_eq = is_eq && (x.k_11b == y.k_11b);
  is_eq = is_eq && (x.k_12b == y.k_12b);
  is_eq = is_eq && (x.cbar22_a == y.cbar22_a);
  is_eq = is_eq && (x.cbar12_a == y.cbar12_a);
  is_eq = is_eq && (x.cbar11_b == y.cbar11_b);
  is_eq = is_eq && (x.cbar12_b == y.cbar12_b);
  is_eq = is_eq && (x.phi_a == y.phi_a);
  is_eq = is_eq && (x.phi_b == y.phi_b);
  return is_eq;
};

template bool is_all_equal (const CPP_bpm_phase_coupling_ARRAY&, const CPP_bpm_phase_coupling_ARRAY&);
template bool is_all_equal (const CPP_bpm_phase_coupling_MATRIX&, const CPP_bpm_phase_coupling_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_expression_atom& x, const CPP_expression_atom& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.name == y.name);
  is_eq = is_eq && (x.type == y.type);
  is_eq = is_eq && (x.value == y.value);
  return is_eq;
};

template bool is_all_equal (const CPP_expression_atom_ARRAY&, const CPP_expression_atom_ARRAY&);
template bool is_all_equal (const CPP_expression_atom_MATRIX&, const CPP_expression_atom_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_wake_sr_mode& x, const CPP_wake_sr_mode& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.amp == y.amp);
  is_eq = is_eq && (x.damp == y.damp);
  is_eq = is_eq && (x.k == y.k);
  is_eq = is_eq && (x.phi == y.phi);
  is_eq = is_eq && (x.b_sin == y.b_sin);
  is_eq = is_eq && (x.b_cos == y.b_cos);
  is_eq = is_eq && (x.a_sin == y.a_sin);
  is_eq = is_eq && (x.a_cos == y.a_cos);
  is_eq = is_eq && (x.polarization == y.polarization);
  is_eq = is_eq && (x.position_dependence == y.position_dependence);
  return is_eq;
};

template bool is_all_equal (const CPP_wake_sr_mode_ARRAY&, const CPP_wake_sr_mode_ARRAY&);
template bool is_all_equal (const CPP_wake_sr_mode_MATRIX&, const CPP_wake_sr_mode_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_wake_sr& x, const CPP_wake_sr& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.file == y.file);
  is_eq = is_eq && is_all_equal(x.long_wake, y.long_wake);
  is_eq = is_eq && is_all_equal(x.trans_wake, y.trans_wake);
  is_eq = is_eq && (x.z_ref_long == y.z_ref_long);
  is_eq = is_eq && (x.z_ref_trans == y.z_ref_trans);
  is_eq = is_eq && (x.z_max == y.z_max);
  is_eq = is_eq && (x.amp_scale == y.amp_scale);
  is_eq = is_eq && (x.z_scale == y.z_scale);
  is_eq = is_eq && (x.scale_with_length == y.scale_with_length);
  return is_eq;
};

template bool is_all_equal (const CPP_wake_sr_ARRAY&, const CPP_wake_sr_ARRAY&);
template bool is_all_equal (const CPP_wake_sr_MATRIX&, const CPP_wake_sr_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_wake_lr_mode& x, const CPP_wake_lr_mode& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.freq == y.freq);
  is_eq = is_eq && (x.freq_in == y.freq_in);
  is_eq = is_eq && (x.r_over_q == y.r_over_q);
  is_eq = is_eq && (x.q == y.q);
  is_eq = is_eq && (x.damp == y.damp);
  is_eq = is_eq && (x.phi == y.phi);
  is_eq = is_eq && (x.angle == y.angle);
  is_eq = is_eq && (x.b_sin == y.b_sin);
  is_eq = is_eq && (x.b_cos == y.b_cos);
  is_eq = is_eq && (x.a_sin == y.a_sin);
  is_eq = is_eq && (x.a_cos == y.a_cos);
  is_eq = is_eq && (x.m == y.m);
  is_eq = is_eq && (x.polarized == y.polarized);
  return is_eq;
};

template bool is_all_equal (const CPP_wake_lr_mode_ARRAY&, const CPP_wake_lr_mode_ARRAY&);
template bool is_all_equal (const CPP_wake_lr_mode_MATRIX&, const CPP_wake_lr_mode_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_wake_lr& x, const CPP_wake_lr& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.file == y.file);
  is_eq = is_eq && is_all_equal(x.mode, y.mode);
  is_eq = is_eq && (x.t_ref == y.t_ref);
  is_eq = is_eq && (x.freq_spread == y.freq_spread);
  is_eq = is_eq && (x.amp_scale == y.amp_scale);
  is_eq = is_eq && (x.time_scale == y.time_scale);
  is_eq = is_eq && (x.self_wake_on == y.self_wake_on);
  return is_eq;
};

template bool is_all_equal (const CPP_wake_lr_ARRAY&, const CPP_wake_lr_ARRAY&);
template bool is_all_equal (const CPP_wake_lr_MATRIX&, const CPP_wake_lr_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_lat_ele_loc& x, const CPP_lat_ele_loc& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.ix_ele == y.ix_ele);
  is_eq = is_eq && (x.ix_branch == y.ix_branch);
  return is_eq;
};

template bool is_all_equal (const CPP_lat_ele_loc_ARRAY&, const CPP_lat_ele_loc_ARRAY&);
template bool is_all_equal (const CPP_lat_ele_loc_MATRIX&, const CPP_lat_ele_loc_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_wake& x, const CPP_wake& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.sr == y.sr);
  is_eq = is_eq && (x.lr == y.lr);
  return is_eq;
};

template bool is_all_equal (const CPP_wake_ARRAY&, const CPP_wake_ARRAY&);
template bool is_all_equal (const CPP_wake_MATRIX&, const CPP_wake_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_taylor_term& x, const CPP_taylor_term& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.coef == y.coef);
  is_eq = is_eq && is_all_equal(x.expn, y.expn);
  return is_eq;
};

template bool is_all_equal (const CPP_taylor_term_ARRAY&, const CPP_taylor_term_ARRAY&);
template bool is_all_equal (const CPP_taylor_term_MATRIX&, const CPP_taylor_term_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_taylor& x, const CPP_taylor& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.ref == y.ref);
  is_eq = is_eq && is_all_equal(x.term, y.term);
  return is_eq;
};

template bool is_all_equal (const CPP_taylor_ARRAY&, const CPP_taylor_ARRAY&);
template bool is_all_equal (const CPP_taylor_MATRIX&, const CPP_taylor_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_em_taylor_term& x, const CPP_em_taylor_term& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.coef == y.coef);
  is_eq = is_eq && is_all_equal(x.expn, y.expn);
  return is_eq;
};

template bool is_all_equal (const CPP_em_taylor_term_ARRAY&, const CPP_em_taylor_term_ARRAY&);
template bool is_all_equal (const CPP_em_taylor_term_MATRIX&, const CPP_em_taylor_term_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_em_taylor& x, const CPP_em_taylor& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.ref == y.ref);
  is_eq = is_eq && is_all_equal(x.term, y.term);
  return is_eq;
};

template bool is_all_equal (const CPP_em_taylor_ARRAY&, const CPP_em_taylor_ARRAY&);
template bool is_all_equal (const CPP_em_taylor_MATRIX&, const CPP_em_taylor_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_cartesian_map_term1& x, const CPP_cartesian_map_term1& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.coef == y.coef);
  is_eq = is_eq && (x.kx == y.kx);
  is_eq = is_eq && (x.ky == y.ky);
  is_eq = is_eq && (x.kz == y.kz);
  is_eq = is_eq && (x.x0 == y.x0);
  is_eq = is_eq && (x.y0 == y.y0);
  is_eq = is_eq && (x.phi_z == y.phi_z);
  is_eq = is_eq && (x.family == y.family);
  is_eq = is_eq && (x.form == y.form);
  return is_eq;
};

template bool is_all_equal (const CPP_cartesian_map_term1_ARRAY&, const CPP_cartesian_map_term1_ARRAY&);
template bool is_all_equal (const CPP_cartesian_map_term1_MATRIX&, const CPP_cartesian_map_term1_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_cartesian_map_term& x, const CPP_cartesian_map_term& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.file == y.file);
  is_eq = is_eq && (x.n_link == y.n_link);
  is_eq = is_eq && is_all_equal(x.term, y.term);
  return is_eq;
};

template bool is_all_equal (const CPP_cartesian_map_term_ARRAY&, const CPP_cartesian_map_term_ARRAY&);
template bool is_all_equal (const CPP_cartesian_map_term_MATRIX&, const CPP_cartesian_map_term_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_cartesian_map& x, const CPP_cartesian_map& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.field_scale == y.field_scale);
  is_eq = is_eq && is_all_equal(x.r0, y.r0);
  is_eq = is_eq && (x.master_parameter == y.master_parameter);
  is_eq = is_eq && (x.ele_anchor_pt == y.ele_anchor_pt);
  is_eq = is_eq && (x.field_type == y.field_type);
  is_eq = is_eq && ((x.ptr == NULL) == (y.ptr == NULL));
  if (!is_eq) return false;
  if (x.ptr != NULL) is_eq = (*x.ptr == *y.ptr);
  return is_eq;
};

template bool is_all_equal (const CPP_cartesian_map_ARRAY&, const CPP_cartesian_map_ARRAY&);
template bool is_all_equal (const CPP_cartesian_map_MATRIX&, const CPP_cartesian_map_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_cylindrical_map_term1& x, const CPP_cylindrical_map_term1& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.e_coef == y.e_coef);
  is_eq = is_eq && (x.b_coef == y.b_coef);
  return is_eq;
};

template bool is_all_equal (const CPP_cylindrical_map_term1_ARRAY&, const CPP_cylindrical_map_term1_ARRAY&);
template bool is_all_equal (const CPP_cylindrical_map_term1_MATRIX&, const CPP_cylindrical_map_term1_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_cylindrical_map_term& x, const CPP_cylindrical_map_term& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.file == y.file);
  is_eq = is_eq && (x.n_link == y.n_link);
  is_eq = is_eq && is_all_equal(x.term, y.term);
  return is_eq;
};

template bool is_all_equal (const CPP_cylindrical_map_term_ARRAY&, const CPP_cylindrical_map_term_ARRAY&);
template bool is_all_equal (const CPP_cylindrical_map_term_MATRIX&, const CPP_cylindrical_map_term_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_cylindrical_map& x, const CPP_cylindrical_map& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.m == y.m);
  is_eq = is_eq && (x.harmonic == y.harmonic);
  is_eq = is_eq && (x.phi0_fieldmap == y.phi0_fieldmap);
  is_eq = is_eq && (x.theta0_azimuth == y.theta0_azimuth);
  is_eq = is_eq && (x.field_scale == y.field_scale);
  is_eq = is_eq && (x.master_parameter == y.master_parameter);
  is_eq = is_eq && (x.ele_anchor_pt == y.ele_anchor_pt);
  is_eq = is_eq && (x.dz == y.dz);
  is_eq = is_eq && is_all_equal(x.r0, y.r0);
  is_eq = is_eq && ((x.ptr == NULL) == (y.ptr == NULL));
  if (!is_eq) return false;
  if (x.ptr != NULL) is_eq = (*x.ptr == *y.ptr);
  return is_eq;
};

template bool is_all_equal (const CPP_cylindrical_map_ARRAY&, const CPP_cylindrical_map_ARRAY&);
template bool is_all_equal (const CPP_cylindrical_map_MATRIX&, const CPP_cylindrical_map_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_grid_field_pt1& x, const CPP_grid_field_pt1& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.e, y.e);
  is_eq = is_eq && is_all_equal(x.b, y.b);
  return is_eq;
};

template bool is_all_equal (const CPP_grid_field_pt1_ARRAY&, const CPP_grid_field_pt1_ARRAY&);
template bool is_all_equal (const CPP_grid_field_pt1_MATRIX&, const CPP_grid_field_pt1_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_grid_field_pt& x, const CPP_grid_field_pt& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.file == y.file);
  is_eq = is_eq && (x.n_link == y.n_link);
  is_eq = is_eq && is_all_equal(x.pt, y.pt);
  return is_eq;
};

template bool is_all_equal (const CPP_grid_field_pt_ARRAY&, const CPP_grid_field_pt_ARRAY&);
template bool is_all_equal (const CPP_grid_field_pt_MATRIX&, const CPP_grid_field_pt_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_grid_field& x, const CPP_grid_field& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.geometry == y.geometry);
  is_eq = is_eq && (x.harmonic == y.harmonic);
  is_eq = is_eq && (x.phi0_fieldmap == y.phi0_fieldmap);
  is_eq = is_eq && (x.field_scale == y.field_scale);
  is_eq = is_eq && (x.field_type == y.field_type);
  is_eq = is_eq && (x.master_parameter == y.master_parameter);
  is_eq = is_eq && (x.ele_anchor_pt == y.ele_anchor_pt);
  is_eq = is_eq && (x.interpolation_order == y.interpolation_order);
  is_eq = is_eq && is_all_equal(x.dr, y.dr);
  is_eq = is_eq && is_all_equal(x.r0, y.r0);
  is_eq = is_eq && (x.curved_ref_frame == y.curved_ref_frame);
  is_eq = is_eq && ((x.ptr == NULL) == (y.ptr == NULL));
  if (!is_eq) return false;
  if (x.ptr != NULL) is_eq = (*x.ptr == *y.ptr);
  return is_eq;
};

template bool is_all_equal (const CPP_grid_field_ARRAY&, const CPP_grid_field_ARRAY&);
template bool is_all_equal (const CPP_grid_field_MATRIX&, const CPP_grid_field_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_floor_position& x, const CPP_floor_position& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.r, y.r);
  is_eq = is_eq && is_all_equal(x.w, y.w);
  is_eq = is_eq && (x.theta == y.theta);
  is_eq = is_eq && (x.phi == y.phi);
  is_eq = is_eq && (x.psi == y.psi);
  return is_eq;
};

template bool is_all_equal (const CPP_floor_position_ARRAY&, const CPP_floor_position_ARRAY&);
template bool is_all_equal (const CPP_floor_position_MATRIX&, const CPP_floor_position_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_high_energy_space_charge& x, const CPP_high_energy_space_charge& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.closed_orb == y.closed_orb);
  is_eq = is_eq && (x.kick_const == y.kick_const);
  is_eq = is_eq && (x.sig_x == y.sig_x);
  is_eq = is_eq && (x.sig_y == y.sig_y);
  is_eq = is_eq && (x.phi == y.phi);
  is_eq = is_eq && (x.sin_phi == y.sin_phi);
  is_eq = is_eq && (x.cos_phi == y.cos_phi);
  is_eq = is_eq && (x.sig_z == y.sig_z);
  return is_eq;
};

template bool is_all_equal (const CPP_high_energy_space_charge_ARRAY&, const CPP_high_energy_space_charge_ARRAY&);
template bool is_all_equal (const CPP_high_energy_space_charge_MATRIX&, const CPP_high_energy_space_charge_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_xy_disp& x, const CPP_xy_disp& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.eta == y.eta);
  is_eq = is_eq && (x.etap == y.etap);
  is_eq = is_eq && (x.deta_ds == y.deta_ds);
  is_eq = is_eq && (x.sigma == y.sigma);
  return is_eq;
};

template bool is_all_equal (const CPP_xy_disp_ARRAY&, const CPP_xy_disp_ARRAY&);
template bool is_all_equal (const CPP_xy_disp_MATRIX&, const CPP_xy_disp_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_twiss& x, const CPP_twiss& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.beta == y.beta);
  is_eq = is_eq && (x.alpha == y.alpha);
  is_eq = is_eq && (x.gamma == y.gamma);
  is_eq = is_eq && (x.phi == y.phi);
  is_eq = is_eq && (x.eta == y.eta);
  is_eq = is_eq && (x.etap == y.etap);
  is_eq = is_eq && (x.deta_ds == y.deta_ds);
  is_eq = is_eq && (x.sigma == y.sigma);
  is_eq = is_eq && (x.sigma_p == y.sigma_p);
  is_eq = is_eq && (x.emit == y.emit);
  is_eq = is_eq && (x.norm_emit == y.norm_emit);
  return is_eq;
};

template bool is_all_equal (const CPP_twiss_ARRAY&, const CPP_twiss_ARRAY&);
template bool is_all_equal (const CPP_twiss_MATRIX&, const CPP_twiss_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_mode3& x, const CPP_mode3& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.v, y.v);
  is_eq = is_eq && (x.a == y.a);
  is_eq = is_eq && (x.b == y.b);
  is_eq = is_eq && (x.c == y.c);
  is_eq = is_eq && (x.x == y.x);
  is_eq = is_eq && (x.y == y.y);
  return is_eq;
};

template bool is_all_equal (const CPP_mode3_ARRAY&, const CPP_mode3_ARRAY&);
template bool is_all_equal (const CPP_mode3_MATRIX&, const CPP_mode3_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_bookkeeping_state& x, const CPP_bookkeeping_state& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.attributes == y.attributes);
  is_eq = is_eq && (x.control == y.control);
  is_eq = is_eq && (x.floor_position == y.floor_position);
  is_eq = is_eq && (x.s_position == y.s_position);
  is_eq = is_eq && (x.ref_energy == y.ref_energy);
  is_eq = is_eq && (x.mat6 == y.mat6);
  is_eq = is_eq && (x.rad_int == y.rad_int);
  is_eq = is_eq && (x.ptc == y.ptc);
  return is_eq;
};

template bool is_all_equal (const CPP_bookkeeping_state_ARRAY&, const CPP_bookkeeping_state_ARRAY&);
template bool is_all_equal (const CPP_bookkeeping_state_MATRIX&, const CPP_bookkeeping_state_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_rad_map& x, const CPP_rad_map& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.ref_orb, y.ref_orb);
  is_eq = is_eq && is_all_equal(x.damp_dmat, y.damp_dmat);
  is_eq = is_eq && is_all_equal(x.xfer_damp_vec, y.xfer_damp_vec);
  is_eq = is_eq && is_all_equal(x.xfer_damp_mat, y.xfer_damp_mat);
  is_eq = is_eq && is_all_equal(x.stoc_mat, y.stoc_mat);
  return is_eq;
};

template bool is_all_equal (const CPP_rad_map_ARRAY&, const CPP_rad_map_ARRAY&);
template bool is_all_equal (const CPP_rad_map_MATRIX&, const CPP_rad_map_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_rad_map_ele& x, const CPP_rad_map_ele& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.rm0 == y.rm0);
  is_eq = is_eq && (x.rm1 == y.rm1);
  is_eq = is_eq && (x.stale == y.stale);
  return is_eq;
};

template bool is_all_equal (const CPP_rad_map_ele_ARRAY&, const CPP_rad_map_ele_ARRAY&);
template bool is_all_equal (const CPP_rad_map_ele_MATRIX&, const CPP_rad_map_ele_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_gen_grad1& x, const CPP_gen_grad1& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.m == y.m);
  is_eq = is_eq && (x.sincos == y.sincos);
  is_eq = is_eq && (x.n_deriv_max == y.n_deriv_max);
  is_eq = is_eq && is_all_equal(x.deriv, y.deriv);
  return is_eq;
};

template bool is_all_equal (const CPP_gen_grad1_ARRAY&, const CPP_gen_grad1_ARRAY&);
template bool is_all_equal (const CPP_gen_grad1_MATRIX&, const CPP_gen_grad1_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_gen_grad_map& x, const CPP_gen_grad_map& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.file == y.file);
  is_eq = is_eq && is_all_equal(x.gg, y.gg);
  is_eq = is_eq && (x.ele_anchor_pt == y.ele_anchor_pt);
  is_eq = is_eq && (x.field_type == y.field_type);
  is_eq = is_eq && (x.iz0 == y.iz0);
  is_eq = is_eq && (x.iz1 == y.iz1);
  is_eq = is_eq && (x.dz == y.dz);
  is_eq = is_eq && is_all_equal(x.r0, y.r0);
  is_eq = is_eq && (x.field_scale == y.field_scale);
  is_eq = is_eq && (x.master_parameter == y.master_parameter);
  is_eq = is_eq && (x.curved_ref_frame == y.curved_ref_frame);
  return is_eq;
};

template bool is_all_equal (const CPP_gen_grad_map_ARRAY&, const CPP_gen_grad_map_ARRAY&);
template bool is_all_equal (const CPP_gen_grad_map_MATRIX&, const CPP_gen_grad_map_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_surface_grid_pt& x, const CPP_surface_grid_pt& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.orientation == y.orientation);
  is_eq = is_eq && (x.z0 == y.z0);
  is_eq = is_eq && (x.x0 == y.x0);
  is_eq = is_eq && (x.y0 == y.y0);
  is_eq = is_eq && (x.dz_dx == y.dz_dx);
  is_eq = is_eq && (x.dz_dy == y.dz_dy);
  is_eq = is_eq && (x.d2z_dxdy == y.d2z_dxdy);
  return is_eq;
};

template bool is_all_equal (const CPP_surface_grid_pt_ARRAY&, const CPP_surface_grid_pt_ARRAY&);
template bool is_all_equal (const CPP_surface_grid_pt_MATRIX&, const CPP_surface_grid_pt_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_surface_grid& x, const CPP_surface_grid& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.active == y.active);
  is_eq = is_eq && (x.type == y.type);
  is_eq = is_eq && is_all_equal(x.dr, y.dr);
  is_eq = is_eq && is_all_equal(x.r0, y.r0);
  is_eq = is_eq && is_all_equal(x.pt, y.pt);
  return is_eq;
};

template bool is_all_equal (const CPP_surface_grid_ARRAY&, const CPP_surface_grid_ARRAY&);
template bool is_all_equal (const CPP_surface_grid_MATRIX&, const CPP_surface_grid_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_target_point& x, const CPP_target_point& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.r, y.r);
  return is_eq;
};

template bool is_all_equal (const CPP_target_point_ARRAY&, const CPP_target_point_ARRAY&);
template bool is_all_equal (const CPP_target_point_MATRIX&, const CPP_target_point_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_surface_curvature& x, const CPP_surface_curvature& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.xy, y.xy);
  is_eq = is_eq && (x.spherical == y.spherical);
  is_eq = is_eq && is_all_equal(x.elliptical, y.elliptical);
  is_eq = is_eq && (x.has_curvature == y.has_curvature);
  return is_eq;
};

template bool is_all_equal (const CPP_surface_curvature_ARRAY&, const CPP_surface_curvature_ARRAY&);
template bool is_all_equal (const CPP_surface_curvature_MATRIX&, const CPP_surface_curvature_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_photon_target& x, const CPP_photon_target& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.type == y.type);
  is_eq = is_eq && (x.n_corner == y.n_corner);
  is_eq = is_eq && (x.ele_loc == y.ele_loc);
  is_eq = is_eq && is_all_equal(x.corner, y.corner);
  is_eq = is_eq && (x.center == y.center);
  return is_eq;
};

template bool is_all_equal (const CPP_photon_target_ARRAY&, const CPP_photon_target_ARRAY&);
template bool is_all_equal (const CPP_photon_target_MATRIX&, const CPP_photon_target_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_photon_material& x, const CPP_photon_material& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.f0_m1 == y.f0_m1);
  is_eq = is_eq && (x.f0_m2 == y.f0_m2);
  is_eq = is_eq && (x.f_0 == y.f_0);
  is_eq = is_eq && (x.f_h == y.f_h);
  is_eq = is_eq && (x.f_hbar == y.f_hbar);
  is_eq = is_eq && (x.f_hkl == y.f_hkl);
  is_eq = is_eq && is_all_equal(x.h_norm, y.h_norm);
  is_eq = is_eq && is_all_equal(x.l_ref, y.l_ref);
  return is_eq;
};

template bool is_all_equal (const CPP_photon_material_ARRAY&, const CPP_photon_material_ARRAY&);
template bool is_all_equal (const CPP_photon_material_MATRIX&, const CPP_photon_material_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_pixel_pt& x, const CPP_pixel_pt& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.n_photon == y.n_photon);
  is_eq = is_eq && (x.e_x == y.e_x);
  is_eq = is_eq && (x.e_y == y.e_y);
  is_eq = is_eq && (x.intensity_x == y.intensity_x);
  is_eq = is_eq && (x.intensity_y == y.intensity_y);
  is_eq = is_eq && (x.intensity == y.intensity);
  is_eq = is_eq && is_all_equal(x.orbit, y.orbit);
  is_eq = is_eq && is_all_equal(x.orbit_rms, y.orbit_rms);
  is_eq = is_eq && is_all_equal(x.init_orbit, y.init_orbit);
  is_eq = is_eq && is_all_equal(x.init_orbit_rms, y.init_orbit_rms);
  return is_eq;
};

template bool is_all_equal (const CPP_pixel_pt_ARRAY&, const CPP_pixel_pt_ARRAY&);
template bool is_all_equal (const CPP_pixel_pt_MATRIX&, const CPP_pixel_pt_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_pixel_detec& x, const CPP_pixel_detec& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.dr, y.dr);
  is_eq = is_eq && is_all_equal(x.r0, y.r0);
  is_eq = is_eq && (x.n_track_tot == y.n_track_tot);
  is_eq = is_eq && (x.n_hit_detec == y.n_hit_detec);
  is_eq = is_eq && (x.n_hit_pixel == y.n_hit_pixel);
  is_eq = is_eq && is_all_equal(x.pt, y.pt);
  return is_eq;
};

template bool is_all_equal (const CPP_pixel_detec_ARRAY&, const CPP_pixel_detec_ARRAY&);
template bool is_all_equal (const CPP_pixel_detec_MATRIX&, const CPP_pixel_detec_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_photon_element& x, const CPP_photon_element& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.curvature == y.curvature);
  is_eq = is_eq && (x.target == y.target);
  is_eq = is_eq && (x.material == y.material);
  is_eq = is_eq && (x.grid == y.grid);
  is_eq = is_eq && (x.pixel == y.pixel);
  is_eq = is_eq && (x.reflectivity_table_type == y.reflectivity_table_type);
  is_eq = is_eq && (x.reflectivity_table_sigma == y.reflectivity_table_sigma);
  is_eq = is_eq && (x.reflectivity_table_pi == y.reflectivity_table_pi);
  is_eq = is_eq && is_all_equal(x.init_energy_prob, y.init_energy_prob);
  is_eq = is_eq && is_all_equal(x.integrated_init_energy_prob, y.integrated_init_energy_prob);
  return is_eq;
};

template bool is_all_equal (const CPP_photon_element_ARRAY&, const CPP_photon_element_ARRAY&);
template bool is_all_equal (const CPP_photon_element_MATRIX&, const CPP_photon_element_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_wall3d_vertex& x, const CPP_wall3d_vertex& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.x == y.x);
  is_eq = is_eq && (x.y == y.y);
  is_eq = is_eq && (x.radius_x == y.radius_x);
  is_eq = is_eq && (x.radius_y == y.radius_y);
  is_eq = is_eq && (x.tilt == y.tilt);
  is_eq = is_eq && (x.angle == y.angle);
  is_eq = is_eq && (x.x0 == y.x0);
  is_eq = is_eq && (x.y0 == y.y0);
  is_eq = is_eq && (x.type == y.type);
  return is_eq;
};

template bool is_all_equal (const CPP_wall3d_vertex_ARRAY&, const CPP_wall3d_vertex_ARRAY&);
template bool is_all_equal (const CPP_wall3d_vertex_MATRIX&, const CPP_wall3d_vertex_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_wall3d_section& x, const CPP_wall3d_section& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.name == y.name);
  is_eq = is_eq && (x.material == y.material);
  is_eq = is_eq && is_all_equal(x.v, y.v);
  is_eq = is_eq && ((x.surface == NULL) == (y.surface == NULL));
  if (!is_eq) return false;
  if (x.surface != NULL) is_eq = (*x.surface == *y.surface);
  is_eq = is_eq && (x.type == y.type);
  is_eq = is_eq && (x.n_vertex_input == y.n_vertex_input);
  is_eq = is_eq && (x.ix_ele == y.ix_ele);
  is_eq = is_eq && (x.ix_branch == y.ix_branch);
  is_eq = is_eq && (x.vertices_state == y.vertices_state);
  is_eq = is_eq && (x.patch_in_region == y.patch_in_region);
  is_eq = is_eq && (x.thickness == y.thickness);
  is_eq = is_eq && (x.s == y.s);
  is_eq = is_eq && is_all_equal(x.r0, y.r0);
  is_eq = is_eq && (x.dx0_ds == y.dx0_ds);
  is_eq = is_eq && (x.dy0_ds == y.dy0_ds);
  is_eq = is_eq && is_all_equal(x.x0_coef, y.x0_coef);
  is_eq = is_eq && is_all_equal(x.y0_coef, y.y0_coef);
  is_eq = is_eq && (x.dr_ds == y.dr_ds);
  is_eq = is_eq && is_all_equal(x.p1_coef, y.p1_coef);
  is_eq = is_eq && is_all_equal(x.p2_coef, y.p2_coef);
  return is_eq;
};

template bool is_all_equal (const CPP_wall3d_section_ARRAY&, const CPP_wall3d_section_ARRAY&);
template bool is_all_equal (const CPP_wall3d_section_MATRIX&, const CPP_wall3d_section_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_wall3d& x, const CPP_wall3d& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.name == y.name);
  is_eq = is_eq && (x.type == y.type);
  is_eq = is_eq && (x.ix_wall3d == y.ix_wall3d);
  is_eq = is_eq && (x.n_link == y.n_link);
  is_eq = is_eq && (x.thickness == y.thickness);
  is_eq = is_eq && (x.clear_material == y.clear_material);
  is_eq = is_eq && (x.opaque_material == y.opaque_material);
  is_eq = is_eq && (x.superimpose == y.superimpose);
  is_eq = is_eq && (x.ele_anchor_pt == y.ele_anchor_pt);
  is_eq = is_eq && is_all_equal(x.section, y.section);
  return is_eq;
};

template bool is_all_equal (const CPP_wall3d_ARRAY&, const CPP_wall3d_ARRAY&);
template bool is_all_equal (const CPP_wall3d_MATRIX&, const CPP_wall3d_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_control& x, const CPP_control& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.value == y.value);
  is_eq = is_eq && is_all_equal(x.y_knot, y.y_knot);
  is_eq = is_eq && is_all_equal(x.stack, y.stack);
  is_eq = is_eq && (x.slave == y.slave);
  is_eq = is_eq && (x.lord == y.lord);
  is_eq = is_eq && (x.slave_name == y.slave_name);
  is_eq = is_eq && (x.attribute == y.attribute);
  is_eq = is_eq && (x.ix_attrib == y.ix_attrib);
  return is_eq;
};

template bool is_all_equal (const CPP_control_ARRAY&, const CPP_control_ARRAY&);
template bool is_all_equal (const CPP_control_MATRIX&, const CPP_control_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_control_var1& x, const CPP_control_var1& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.name == y.name);
  is_eq = is_eq && (x.value == y.value);
  is_eq = is_eq && (x.old_value == y.old_value);
  return is_eq;
};

template bool is_all_equal (const CPP_control_var1_ARRAY&, const CPP_control_var1_ARRAY&);
template bool is_all_equal (const CPP_control_var1_MATRIX&, const CPP_control_var1_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_control_ramp1& x, const CPP_control_ramp1& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.value == y.value);
  is_eq = is_eq && is_all_equal(x.y_knot, y.y_knot);
  is_eq = is_eq && is_all_equal(x.stack, y.stack);
  is_eq = is_eq && (x.attribute == y.attribute);
  is_eq = is_eq && (x.slave_name == y.slave_name);
  is_eq = is_eq && (x.slave == y.slave);
  is_eq = is_eq && (x.is_controller == y.is_controller);
  return is_eq;
};

template bool is_all_equal (const CPP_control_ramp1_ARRAY&, const CPP_control_ramp1_ARRAY&);
template bool is_all_equal (const CPP_control_ramp1_MATRIX&, const CPP_control_ramp1_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_controller& x, const CPP_controller& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.var, y.var);
  is_eq = is_eq && is_all_equal(x.ramp, y.ramp);
  is_eq = is_eq && is_all_equal(x.x_knot, y.x_knot);
  return is_eq;
};

template bool is_all_equal (const CPP_controller_ARRAY&, const CPP_controller_ARRAY&);
template bool is_all_equal (const CPP_controller_MATRIX&, const CPP_controller_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_ellipse_beam_init& x, const CPP_ellipse_beam_init& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.part_per_ellipse == y.part_per_ellipse);
  is_eq = is_eq && (x.n_ellipse == y.n_ellipse);
  is_eq = is_eq && (x.sigma_cutoff == y.sigma_cutoff);
  return is_eq;
};

template bool is_all_equal (const CPP_ellipse_beam_init_ARRAY&, const CPP_ellipse_beam_init_ARRAY&);
template bool is_all_equal (const CPP_ellipse_beam_init_MATRIX&, const CPP_ellipse_beam_init_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_kv_beam_init& x, const CPP_kv_beam_init& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.part_per_phi, y.part_per_phi);
  is_eq = is_eq && (x.n_i2 == y.n_i2);
  is_eq = is_eq && (x.a == y.a);
  return is_eq;
};

template bool is_all_equal (const CPP_kv_beam_init_ARRAY&, const CPP_kv_beam_init_ARRAY&);
template bool is_all_equal (const CPP_kv_beam_init_MATRIX&, const CPP_kv_beam_init_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_grid_beam_init& x, const CPP_grid_beam_init& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.n_x == y.n_x);
  is_eq = is_eq && (x.n_px == y.n_px);
  is_eq = is_eq && (x.x_min == y.x_min);
  is_eq = is_eq && (x.x_max == y.x_max);
  is_eq = is_eq && (x.px_min == y.px_min);
  is_eq = is_eq && (x.px_max == y.px_max);
  return is_eq;
};

template bool is_all_equal (const CPP_grid_beam_init_ARRAY&, const CPP_grid_beam_init_ARRAY&);
template bool is_all_equal (const CPP_grid_beam_init_MATRIX&, const CPP_grid_beam_init_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_beam_init& x, const CPP_beam_init& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.position_file == y.position_file);
  is_eq = is_eq && is_all_equal(x.distribution_type, y.distribution_type);
  is_eq = is_eq && is_all_equal(x.spin, y.spin);
  is_eq = is_eq && is_all_equal(x.ellipse, y.ellipse);
  is_eq = is_eq && (x.kv == y.kv);
  is_eq = is_eq && is_all_equal(x.grid, y.grid);
  is_eq = is_eq && is_all_equal(x.center_jitter, y.center_jitter);
  is_eq = is_eq && is_all_equal(x.emit_jitter, y.emit_jitter);
  is_eq = is_eq && (x.sig_z_jitter == y.sig_z_jitter);
  is_eq = is_eq && (x.sig_pz_jitter == y.sig_pz_jitter);
  is_eq = is_eq && (x.n_particle == y.n_particle);
  is_eq = is_eq && (x.renorm_center == y.renorm_center);
  is_eq = is_eq && (x.renorm_sigma == y.renorm_sigma);
  is_eq = is_eq && (x.random_engine == y.random_engine);
  is_eq = is_eq && (x.random_gauss_converter == y.random_gauss_converter);
  is_eq = is_eq && (x.random_sigma_cutoff == y.random_sigma_cutoff);
  is_eq = is_eq && (x.a_norm_emit == y.a_norm_emit);
  is_eq = is_eq && (x.b_norm_emit == y.b_norm_emit);
  is_eq = is_eq && (x.a_emit == y.a_emit);
  is_eq = is_eq && (x.b_emit == y.b_emit);
  is_eq = is_eq && (x.dpz_dz == y.dpz_dz);
  is_eq = is_eq && is_all_equal(x.center, y.center);
  is_eq = is_eq && (x.t_offset == y.t_offset);
  is_eq = is_eq && (x.dt_bunch == y.dt_bunch);
  is_eq = is_eq && (x.sig_z == y.sig_z);
  is_eq = is_eq && (x.sig_pz == y.sig_pz);
  is_eq = is_eq && (x.bunch_charge == y.bunch_charge);
  is_eq = is_eq && (x.n_bunch == y.n_bunch);
  is_eq = is_eq && (x.ix_turn == y.ix_turn);
  is_eq = is_eq && (x.species == y.species);
  is_eq = is_eq && (x.full_6d_coupling_calc == y.full_6d_coupling_calc);
  is_eq = is_eq && (x.use_particle_start == y.use_particle_start);
  is_eq = is_eq && (x.use_t_coords == y.use_t_coords);
  is_eq = is_eq && (x.use_z_as_t == y.use_z_as_t);
  return is_eq;
};

template bool is_all_equal (const CPP_beam_init_ARRAY&, const CPP_beam_init_ARRAY&);
template bool is_all_equal (const CPP_beam_init_MATRIX&, const CPP_beam_init_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_lat_param& x, const CPP_lat_param& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.n_part == y.n_part);
  is_eq = is_eq && (x.total_length == y.total_length);
  is_eq = is_eq && (x.unstable_factor == y.unstable_factor);
  is_eq = is_eq && is_all_equal(x.t1_with_rf, y.t1_with_rf);
  is_eq = is_eq && is_all_equal(x.t1_no_rf, y.t1_no_rf);
  is_eq = is_eq && (x.spin_tune == y.spin_tune);
  is_eq = is_eq && (x.particle == y.particle);
  is_eq = is_eq && (x.default_tracking_species == y.default_tracking_species);
  is_eq = is_eq && (x.geometry == y.geometry);
  is_eq = is_eq && (x.ixx == y.ixx);
  is_eq = is_eq && (x.stable == y.stable);
  is_eq = is_eq && (x.live_branch == y.live_branch);
  is_eq = is_eq && (x.g1_integral == y.g1_integral);
  is_eq = is_eq && (x.g2_integral == y.g2_integral);
  is_eq = is_eq && (x.g3_integral == y.g3_integral);
  is_eq = is_eq && (x.bookkeeping_state == y.bookkeeping_state);
  is_eq = is_eq && (x.beam_init == y.beam_init);
  return is_eq;
};

template bool is_all_equal (const CPP_lat_param_ARRAY&, const CPP_lat_param_ARRAY&);
template bool is_all_equal (const CPP_lat_param_MATRIX&, const CPP_lat_param_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_mode_info& x, const CPP_mode_info& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.stable == y.stable);
  is_eq = is_eq && (x.tune == y.tune);
  is_eq = is_eq && (x.emit == y.emit);
  is_eq = is_eq && (x.chrom == y.chrom);
  is_eq = is_eq && (x.sigma == y.sigma);
  is_eq = is_eq && (x.sigmap == y.sigmap);
  return is_eq;
};

template bool is_all_equal (const CPP_mode_info_ARRAY&, const CPP_mode_info_ARRAY&);
template bool is_all_equal (const CPP_mode_info_MATRIX&, const CPP_mode_info_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_pre_tracker& x, const CPP_pre_tracker& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.who == y.who);
  is_eq = is_eq && (x.ix_ele_start == y.ix_ele_start);
  is_eq = is_eq && (x.ix_ele_end == y.ix_ele_end);
  is_eq = is_eq && (x.input_file == y.input_file);
  return is_eq;
};

template bool is_all_equal (const CPP_pre_tracker_ARRAY&, const CPP_pre_tracker_ARRAY&);
template bool is_all_equal (const CPP_pre_tracker_MATRIX&, const CPP_pre_tracker_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_anormal_mode& x, const CPP_anormal_mode& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.emittance == y.emittance);
  is_eq = is_eq && (x.emittance_no_vert == y.emittance_no_vert);
  is_eq = is_eq && is_all_equal(x.synch_int, y.synch_int);
  is_eq = is_eq && (x.j_damp == y.j_damp);
  is_eq = is_eq && (x.alpha_damp == y.alpha_damp);
  is_eq = is_eq && (x.chrom == y.chrom);
  is_eq = is_eq && (x.tune == y.tune);
  return is_eq;
};

template bool is_all_equal (const CPP_anormal_mode_ARRAY&, const CPP_anormal_mode_ARRAY&);
template bool is_all_equal (const CPP_anormal_mode_MATRIX&, const CPP_anormal_mode_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_linac_normal_mode& x, const CPP_linac_normal_mode& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.i2_e4 == y.i2_e4);
  is_eq = is_eq && (x.i3_e7 == y.i3_e7);
  is_eq = is_eq && (x.i5a_e6 == y.i5a_e6);
  is_eq = is_eq && (x.i5b_e6 == y.i5b_e6);
  is_eq = is_eq && (x.sig_e1 == y.sig_e1);
  is_eq = is_eq && (x.a_emittance_end == y.a_emittance_end);
  is_eq = is_eq && (x.b_emittance_end == y.b_emittance_end);
  return is_eq;
};

template bool is_all_equal (const CPP_linac_normal_mode_ARRAY&, const CPP_linac_normal_mode_ARRAY&);
template bool is_all_equal (const CPP_linac_normal_mode_MATRIX&, const CPP_linac_normal_mode_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_normal_modes& x, const CPP_normal_modes& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.synch_int, y.synch_int);
  is_eq = is_eq && (x.sige_e == y.sige_e);
  is_eq = is_eq && (x.sig_z == y.sig_z);
  is_eq = is_eq && (x.e_loss == y.e_loss);
  is_eq = is_eq && (x.rf_voltage == y.rf_voltage);
  is_eq = is_eq && (x.pz_aperture == y.pz_aperture);
  is_eq = is_eq && (x.pz_average == y.pz_average);
  is_eq = is_eq && (x.momentum_compaction == y.momentum_compaction);
  is_eq = is_eq && (x.dpz_damp == y.dpz_damp);
  is_eq = is_eq && (x.a == y.a);
  is_eq = is_eq && (x.b == y.b);
  is_eq = is_eq && (x.z == y.z);
  is_eq = is_eq && (x.lin == y.lin);
  return is_eq;
};

template bool is_all_equal (const CPP_normal_modes_ARRAY&, const CPP_normal_modes_ARRAY&);
template bool is_all_equal (const CPP_normal_modes_MATRIX&, const CPP_normal_modes_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_em_field& x, const CPP_em_field& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.e, y.e);
  is_eq = is_eq && is_all_equal(x.b, y.b);
  is_eq = is_eq && is_all_equal(x.de, y.de);
  is_eq = is_eq && is_all_equal(x.db, y.db);
  is_eq = is_eq && (x.phi == y.phi);
  is_eq = is_eq && (x.phi_b == y.phi_b);
  is_eq = is_eq && is_all_equal(x.a, y.a);
  return is_eq;
};

template bool is_all_equal (const CPP_em_field_ARRAY&, const CPP_em_field_ARRAY&);
template bool is_all_equal (const CPP_em_field_MATRIX&, const CPP_em_field_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_strong_beam& x, const CPP_strong_beam& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.ix_slice == y.ix_slice);
  is_eq = is_eq && (x.x_center == y.x_center);
  is_eq = is_eq && (x.y_center == y.y_center);
  is_eq = is_eq && (x.x_sigma == y.x_sigma);
  is_eq = is_eq && (x.y_sigma == y.y_sigma);
  is_eq = is_eq && (x.dx == y.dx);
  is_eq = is_eq && (x.dy == y.dy);
  return is_eq;
};

template bool is_all_equal (const CPP_strong_beam_ARRAY&, const CPP_strong_beam_ARRAY&);
template bool is_all_equal (const CPP_strong_beam_MATRIX&, const CPP_strong_beam_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_track_point& x, const CPP_track_point& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.s_body == y.s_body);
  is_eq = is_eq && (x.orb == y.orb);
  is_eq = is_eq && (x.field == y.field);
  is_eq = is_eq && (x.strong_beam == y.strong_beam);
  is_eq = is_eq && is_all_equal(x.vec0, y.vec0);
  is_eq = is_eq && is_all_equal(x.mat6, y.mat6);
  return is_eq;
};

template bool is_all_equal (const CPP_track_point_ARRAY&, const CPP_track_point_ARRAY&);
template bool is_all_equal (const CPP_track_point_MATRIX&, const CPP_track_point_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_track& x, const CPP_track& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.pt, y.pt);
  is_eq = is_eq && (x.ds_save == y.ds_save);
  is_eq = is_eq && (x.n_pt == y.n_pt);
  is_eq = is_eq && (x.n_bad == y.n_bad);
  is_eq = is_eq && (x.n_ok == y.n_ok);
  return is_eq;
};

template bool is_all_equal (const CPP_track_ARRAY&, const CPP_track_ARRAY&);
template bool is_all_equal (const CPP_track_MATRIX&, const CPP_track_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_space_charge_common& x, const CPP_space_charge_common& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.ds_track_step == y.ds_track_step);
  is_eq = is_eq && (x.dt_track_step == y.dt_track_step);
  is_eq = is_eq && (x.cathode_strength_cutoff == y.cathode_strength_cutoff);
  is_eq = is_eq && (x.rel_tol_tracking == y.rel_tol_tracking);
  is_eq = is_eq && (x.abs_tol_tracking == y.abs_tol_tracking);
  is_eq = is_eq && (x.beam_chamber_height == y.beam_chamber_height);
  is_eq = is_eq && (x.lsc_sigma_cutoff == y.lsc_sigma_cutoff);
  is_eq = is_eq && (x.particle_sigma_cutoff == y.particle_sigma_cutoff);
  is_eq = is_eq && is_all_equal(x.space_charge_mesh_size, y.space_charge_mesh_size);
  is_eq = is_eq && is_all_equal(x.csr3d_mesh_size, y.csr3d_mesh_size);
  is_eq = is_eq && (x.n_bin == y.n_bin);
  is_eq = is_eq && (x.particle_bin_span == y.particle_bin_span);
  is_eq = is_eq && (x.n_shield_images == y.n_shield_images);
  is_eq = is_eq && (x.sc_min_in_bin == y.sc_min_in_bin);
  is_eq = is_eq && (x.lsc_kick_transverse_dependence == y.lsc_kick_transverse_dependence);
  is_eq = is_eq && (x.debug == y.debug);
  is_eq = is_eq && (x.diagnostic_output_file == y.diagnostic_output_file);
  return is_eq;
};

template bool is_all_equal (const CPP_space_charge_common_ARRAY&, const CPP_space_charge_common_ARRAY&);
template bool is_all_equal (const CPP_space_charge_common_MATRIX&, const CPP_space_charge_common_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_bmad_common& x, const CPP_bmad_common& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.max_aperture_limit == y.max_aperture_limit);
  is_eq = is_eq && is_all_equal(x.d_orb, y.d_orb);
  is_eq = is_eq && (x.default_ds_step == y.default_ds_step);
  is_eq = is_eq && (x.significant_length == y.significant_length);
  is_eq = is_eq && (x.rel_tol_tracking == y.rel_tol_tracking);
  is_eq = is_eq && (x.abs_tol_tracking == y.abs_tol_tracking);
  is_eq = is_eq && (x.rel_tol_adaptive_tracking == y.rel_tol_adaptive_tracking);
  is_eq = is_eq && (x.abs_tol_adaptive_tracking == y.abs_tol_adaptive_tracking);
  is_eq = is_eq && (x.init_ds_adaptive_tracking == y.init_ds_adaptive_tracking);
  is_eq = is_eq && (x.min_ds_adaptive_tracking == y.min_ds_adaptive_tracking);
  is_eq = is_eq && (x.fatal_ds_adaptive_tracking == y.fatal_ds_adaptive_tracking);
  is_eq = is_eq && (x.autoscale_amp_abs_tol == y.autoscale_amp_abs_tol);
  is_eq = is_eq && (x.autoscale_amp_rel_tol == y.autoscale_amp_rel_tol);
  is_eq = is_eq && (x.autoscale_phase_tol == y.autoscale_phase_tol);
  is_eq = is_eq && (x.electric_dipole_moment == y.electric_dipole_moment);
  is_eq = is_eq && (x.synch_rad_scale == y.synch_rad_scale);
  is_eq = is_eq && (x.sad_eps_scale == y.sad_eps_scale);
  is_eq = is_eq && (x.sad_amp_max == y.sad_amp_max);
  is_eq = is_eq && (x.sad_n_div_max == y.sad_n_div_max);
  is_eq = is_eq && (x.taylor_order == y.taylor_order);
  is_eq = is_eq && (x.runge_kutta_order == y.runge_kutta_order);
  is_eq = is_eq && (x.default_integ_order == y.default_integ_order);
  is_eq = is_eq && (x.max_num_runge_kutta_step == y.max_num_runge_kutta_step);
  is_eq = is_eq && (x.rf_phase_below_transition_ref == y.rf_phase_below_transition_ref);
  is_eq = is_eq && (x.sr_wakes_on == y.sr_wakes_on);
  is_eq = is_eq && (x.lr_wakes_on == y.lr_wakes_on);
  is_eq = is_eq && (x.auto_bookkeeper == y.auto_bookkeeper);
  is_eq = is_eq && (x.high_energy_space_charge_on == y.high_energy_space_charge_on);
  is_eq = is_eq && (x.csr_and_space_charge_on == y.csr_and_space_charge_on);
  is_eq = is_eq && (x.spin_tracking_on == y.spin_tracking_on);
  is_eq = is_eq && (x.spin_sokolov_ternov_flipping_on == y.spin_sokolov_ternov_flipping_on);
  is_eq = is_eq && (x.radiation_damping_on == y.radiation_damping_on);
  is_eq = is_eq && (x.radiation_zero_average == y.radiation_zero_average);
  is_eq = is_eq && (x.radiation_fluctuations_on == y.radiation_fluctuations_on);
  is_eq = is_eq && (x.conserve_taylor_maps == y.conserve_taylor_maps);
  is_eq = is_eq && (x.absolute_time_tracking == y.absolute_time_tracking);
  is_eq = is_eq && (x.absolute_time_ref_shift == y.absolute_time_ref_shift);
  is_eq = is_eq && (x.convert_to_kinetic_momentum == y.convert_to_kinetic_momentum);
  is_eq = is_eq && (x.aperture_limit_on == y.aperture_limit_on);
  is_eq = is_eq && (x.debug == y.debug);
  return is_eq;
};

template bool is_all_equal (const CPP_bmad_common_ARRAY&, const CPP_bmad_common_ARRAY&);
template bool is_all_equal (const CPP_bmad_common_MATRIX&, const CPP_bmad_common_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_rad_int1& x, const CPP_rad_int1& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.i0 == y.i0);
  is_eq = is_eq && (x.i1 == y.i1);
  is_eq = is_eq && (x.i2 == y.i2);
  is_eq = is_eq && (x.i3 == y.i3);
  is_eq = is_eq && (x.i4a == y.i4a);
  is_eq = is_eq && (x.i4b == y.i4b);
  is_eq = is_eq && (x.i4z == y.i4z);
  is_eq = is_eq && (x.i5a == y.i5a);
  is_eq = is_eq && (x.i5b == y.i5b);
  is_eq = is_eq && (x.i6b == y.i6b);
  is_eq = is_eq && (x.lin_i2_e4 == y.lin_i2_e4);
  is_eq = is_eq && (x.lin_i3_e7 == y.lin_i3_e7);
  is_eq = is_eq && (x.lin_i5a_e6 == y.lin_i5a_e6);
  is_eq = is_eq && (x.lin_i5b_e6 == y.lin_i5b_e6);
  is_eq = is_eq && (x.lin_norm_emit_a == y.lin_norm_emit_a);
  is_eq = is_eq && (x.lin_norm_emit_b == y.lin_norm_emit_b);
  is_eq = is_eq && (x.lin_sig_e == y.lin_sig_e);
  is_eq = is_eq && (x.n_steps == y.n_steps);
  return is_eq;
};

template bool is_all_equal (const CPP_rad_int1_ARRAY&, const CPP_rad_int1_ARRAY&);
template bool is_all_equal (const CPP_rad_int1_MATRIX&, const CPP_rad_int1_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_rad_int_branch& x, const CPP_rad_int_branch& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.ele, y.ele);
  return is_eq;
};

template bool is_all_equal (const CPP_rad_int_branch_ARRAY&, const CPP_rad_int_branch_ARRAY&);
template bool is_all_equal (const CPP_rad_int_branch_MATRIX&, const CPP_rad_int_branch_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_rad_int_all_ele& x, const CPP_rad_int_all_ele& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.branch, y.branch);
  return is_eq;
};

template bool is_all_equal (const CPP_rad_int_all_ele_ARRAY&, const CPP_rad_int_all_ele_ARRAY&);
template bool is_all_equal (const CPP_rad_int_all_ele_MATRIX&, const CPP_rad_int_all_ele_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_ele& x, const CPP_ele& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.name == y.name);
  is_eq = is_eq && (x.type == y.type);
  is_eq = is_eq && (x.alias == y.alias);
  is_eq = is_eq && (x.component_name == y.component_name);
  is_eq = is_eq && ((x.descrip == NULL) == (y.descrip == NULL));
  if (!is_eq) return false;
  if (x.descrip != NULL) is_eq = (*x.descrip == *y.descrip);
  is_eq = is_eq && (x.a == y.a);
  is_eq = is_eq && (x.b == y.b);
  is_eq = is_eq && (x.z == y.z);
  is_eq = is_eq && (x.x == y.x);
  is_eq = is_eq && (x.y == y.y);
  is_eq = is_eq && ((x.ac_kick == NULL) == (y.ac_kick == NULL));
  if (!is_eq) return false;
  if (x.ac_kick != NULL) is_eq = (*x.ac_kick == *y.ac_kick);
  is_eq = is_eq && (x.bookkeeping_state == y.bookkeeping_state);
  is_eq = is_eq && ((x.control == NULL) == (y.control == NULL));
  if (!is_eq) return false;
  if (x.control != NULL) is_eq = (*x.control == *y.control);
  is_eq = is_eq && (x.floor == y.floor);
  is_eq = is_eq && ((x.high_energy_space_charge == NULL) == (y.high_energy_space_charge == NULL));
  if (!is_eq) return false;
  if (x.high_energy_space_charge != NULL) is_eq = (*x.high_energy_space_charge == *y.high_energy_space_charge);
  is_eq = is_eq && ((x.mode3 == NULL) == (y.mode3 == NULL));
  if (!is_eq) return false;
  if (x.mode3 != NULL) is_eq = (*x.mode3 == *y.mode3);
  is_eq = is_eq && ((x.photon == NULL) == (y.photon == NULL));
  if (!is_eq) return false;
  if (x.photon != NULL) is_eq = (*x.photon == *y.photon);
  is_eq = is_eq && ((x.rad_map == NULL) == (y.rad_map == NULL));
  if (!is_eq) return false;
  if (x.rad_map != NULL) is_eq = (*x.rad_map == *y.rad_map);
  is_eq = is_eq && is_all_equal(x.taylor, y.taylor);
  is_eq = is_eq && is_all_equal(x.spin_taylor_ref_orb_in, y.spin_taylor_ref_orb_in);
  is_eq = is_eq && is_all_equal(x.spin_taylor, y.spin_taylor);
  is_eq = is_eq && ((x.wake == NULL) == (y.wake == NULL));
  if (!is_eq) return false;
  if (x.wake != NULL) is_eq = (*x.wake == *y.wake);
  is_eq = is_eq && is_all_equal(x.wall3d, y.wall3d);
  is_eq = is_eq && is_all_equal(x.cartesian_map, y.cartesian_map);
  is_eq = is_eq && is_all_equal(x.cylindrical_map, y.cylindrical_map);
  is_eq = is_eq && is_all_equal(x.gen_grad_map, y.gen_grad_map);
  is_eq = is_eq && is_all_equal(x.grid_field, y.grid_field);
  is_eq = is_eq && (x.map_ref_orb_in == y.map_ref_orb_in);
  is_eq = is_eq && (x.map_ref_orb_out == y.map_ref_orb_out);
  is_eq = is_eq && (x.time_ref_orb_in == y.time_ref_orb_in);
  is_eq = is_eq && (x.time_ref_orb_out == y.time_ref_orb_out);
  is_eq = is_eq && is_all_equal(x.value, y.value);
  is_eq = is_eq && is_all_equal(x.old_value, y.old_value);
  is_eq = is_eq && is_all_equal(x.spin_q, y.spin_q);
  is_eq = is_eq && is_all_equal(x.vec0, y.vec0);
  is_eq = is_eq && is_all_equal(x.mat6, y.mat6);
  is_eq = is_eq && is_all_equal(x.c_mat, y.c_mat);
  is_eq = is_eq && (x.gamma_c == y.gamma_c);
  is_eq = is_eq && (x.s_start == y.s_start);
  is_eq = is_eq && (x.s == y.s);
  is_eq = is_eq && (x.ref_time == y.ref_time);
  is_eq = is_eq && is_all_equal(x.a_pole, y.a_pole);
  is_eq = is_eq && is_all_equal(x.b_pole, y.b_pole);
  is_eq = is_eq && is_all_equal(x.a_pole_elec, y.a_pole_elec);
  is_eq = is_eq && is_all_equal(x.b_pole_elec, y.b_pole_elec);
  is_eq = is_eq && is_all_equal(x.custom, y.custom);
  is_eq = is_eq && is_all_equal(x.r, y.r);
  is_eq = is_eq && (x.key == y.key);
  is_eq = is_eq && (x.sub_key == y.sub_key);
  is_eq = is_eq && (x.ix_ele == y.ix_ele);
  is_eq = is_eq && (x.ix_branch == y.ix_branch);
  is_eq = is_eq && (x.lord_status == y.lord_status);
  is_eq = is_eq && (x.n_slave == y.n_slave);
  is_eq = is_eq && (x.n_slave_field == y.n_slave_field);
  is_eq = is_eq && (x.ix1_slave == y.ix1_slave);
  is_eq = is_eq && (x.slave_status == y.slave_status);
  is_eq = is_eq && (x.n_lord == y.n_lord);
  is_eq = is_eq && (x.n_lord_field == y.n_lord_field);
  is_eq = is_eq && (x.ic1_lord == y.ic1_lord);
  is_eq = is_eq && (x.ix_pointer == y.ix_pointer);
  is_eq = is_eq && (x.ixx == y.ixx);
  is_eq = is_eq && (x.iyy == y.iyy);
  is_eq = is_eq && (x.izz == y.izz);
  is_eq = is_eq && (x.mat6_calc_method == y.mat6_calc_method);
  is_eq = is_eq && (x.tracking_method == y.tracking_method);
  is_eq = is_eq && (x.spin_tracking_method == y.spin_tracking_method);
  is_eq = is_eq && (x.csr_method == y.csr_method);
  is_eq = is_eq && (x.space_charge_method == y.space_charge_method);
  is_eq = is_eq && (x.ptc_integration_type == y.ptc_integration_type);
  is_eq = is_eq && (x.field_calc == y.field_calc);
  is_eq = is_eq && (x.aperture_at == y.aperture_at);
  is_eq = is_eq && (x.aperture_type == y.aperture_type);
  is_eq = is_eq && (x.ref_species == y.ref_species);
  is_eq = is_eq && (x.orientation == y.orientation);
  is_eq = is_eq && (x.symplectify == y.symplectify);
  is_eq = is_eq && (x.mode_flip == y.mode_flip);
  is_eq = is_eq && (x.multipoles_on == y.multipoles_on);
  is_eq = is_eq && (x.scale_multipoles == y.scale_multipoles);
  is_eq = is_eq && (x.taylor_map_includes_offsets == y.taylor_map_includes_offsets);
  is_eq = is_eq && (x.field_master == y.field_master);
  is_eq = is_eq && (x.is_on == y.is_on);
  is_eq = is_eq && (x.logic == y.logic);
  is_eq = is_eq && (x.bmad_logic == y.bmad_logic);
  is_eq = is_eq && (x.select == y.select);
  is_eq = is_eq && (x.offset_moves_aperture == y.offset_moves_aperture);
  return is_eq;
};

template bool is_all_equal (const CPP_ele_ARRAY&, const CPP_ele_ARRAY&);
template bool is_all_equal (const CPP_ele_MATRIX&, const CPP_ele_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_complex_taylor_term& x, const CPP_complex_taylor_term& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.coef == y.coef);
  is_eq = is_eq && is_all_equal(x.expn, y.expn);
  return is_eq;
};

template bool is_all_equal (const CPP_complex_taylor_term_ARRAY&, const CPP_complex_taylor_term_ARRAY&);
template bool is_all_equal (const CPP_complex_taylor_term_MATRIX&, const CPP_complex_taylor_term_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_complex_taylor& x, const CPP_complex_taylor& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.ref == y.ref);
  is_eq = is_eq && is_all_equal(x.term, y.term);
  return is_eq;
};

template bool is_all_equal (const CPP_complex_taylor_ARRAY&, const CPP_complex_taylor_ARRAY&);
template bool is_all_equal (const CPP_complex_taylor_MATRIX&, const CPP_complex_taylor_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_branch& x, const CPP_branch& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.name == y.name);
  is_eq = is_eq && (x.ix_branch == y.ix_branch);
  is_eq = is_eq && (x.ix_from_branch == y.ix_from_branch);
  is_eq = is_eq && (x.ix_from_ele == y.ix_from_ele);
  is_eq = is_eq && (x.ix_to_ele == y.ix_to_ele);
  is_eq = is_eq && (x.n_ele_track == y.n_ele_track);
  is_eq = is_eq && (x.n_ele_max == y.n_ele_max);
  is_eq = is_eq && (x.a == y.a);
  is_eq = is_eq && (x.b == y.b);
  is_eq = is_eq && (x.z == y.z);
  is_eq = is_eq && is_all_equal(x.ele, y.ele);
  is_eq = is_eq && (x.param == y.param);
  is_eq = is_eq && is_all_equal(x.wall3d, y.wall3d);
  return is_eq;
};

template bool is_all_equal (const CPP_branch_ARRAY&, const CPP_branch_ARRAY&);
template bool is_all_equal (const CPP_branch_MATRIX&, const CPP_branch_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_lat& x, const CPP_lat& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.use_name == y.use_name);
  is_eq = is_eq && (x.lattice == y.lattice);
  is_eq = is_eq && (x.machine == y.machine);
  is_eq = is_eq && (x.input_file_name == y.input_file_name);
  is_eq = is_eq && (x.title == y.title);
  is_eq = is_eq && is_all_equal(x.print_str, y.print_str);
  is_eq = is_eq && is_all_equal(x.constant, y.constant);
  is_eq = is_eq && ((x.a == NULL) == (y.a == NULL));
  if (!is_eq) return false;
  if (x.a != NULL) is_eq = (*x.a == *y.a);
  is_eq = is_eq && ((x.b == NULL) == (y.b == NULL));
  if (!is_eq) return false;
  if (x.b != NULL) is_eq = (*x.b == *y.b);
  is_eq = is_eq && ((x.z == NULL) == (y.z == NULL));
  if (!is_eq) return false;
  if (x.z != NULL) is_eq = (*x.z == *y.z);
  is_eq = is_eq && ((x.param == NULL) == (y.param == NULL));
  if (!is_eq) return false;
  if (x.param != NULL) is_eq = (*x.param == *y.param);
  is_eq = is_eq && (x.lord_state == y.lord_state);
  is_eq = is_eq && (x.ele_init == y.ele_init);
  is_eq = is_eq && is_all_equal(x.ele, y.ele);
  is_eq = is_eq && is_all_equal(x.branch, y.branch);
  is_eq = is_eq && is_all_equal(x.control, y.control);
  is_eq = is_eq && (x.particle_start == y.particle_start);
  is_eq = is_eq && (x.beam_init == y.beam_init);
  is_eq = is_eq && (x.pre_tracker == y.pre_tracker);
  is_eq = is_eq && is_all_equal(x.custom, y.custom);
  is_eq = is_eq && (x.version == y.version);
  is_eq = is_eq && ((x.n_ele_track == NULL) == (y.n_ele_track == NULL));
  if (!is_eq) return false;
  if (x.n_ele_track != NULL) is_eq = (*x.n_ele_track == *y.n_ele_track);
  is_eq = is_eq && ((x.n_ele_max == NULL) == (y.n_ele_max == NULL));
  if (!is_eq) return false;
  if (x.n_ele_max != NULL) is_eq = (*x.n_ele_max == *y.n_ele_max);
  is_eq = is_eq && (x.n_control_max == y.n_control_max);
  is_eq = is_eq && (x.n_ic_max == y.n_ic_max);
  is_eq = is_eq && (x.input_taylor_order == y.input_taylor_order);
  is_eq = is_eq && is_all_equal(x.ic, y.ic);
  is_eq = is_eq && (x.photon_type == y.photon_type);
  is_eq = is_eq && (x.creation_hash == y.creation_hash);
  return is_eq;
};

template bool is_all_equal (const CPP_lat_ARRAY&, const CPP_lat_ARRAY&);
template bool is_all_equal (const CPP_lat_MATRIX&, const CPP_lat_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_bunch& x, const CPP_bunch& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.particle, y.particle);
  is_eq = is_eq && is_all_equal(x.ix_z, y.ix_z);
  is_eq = is_eq && (x.charge_tot == y.charge_tot);
  is_eq = is_eq && (x.charge_live == y.charge_live);
  is_eq = is_eq && (x.z_center == y.z_center);
  is_eq = is_eq && (x.t_center == y.t_center);
  is_eq = is_eq && (x.t0 == y.t0);
  is_eq = is_eq && (x.drift_between_t_and_s == y.drift_between_t_and_s);
  is_eq = is_eq && (x.ix_ele == y.ix_ele);
  is_eq = is_eq && (x.ix_bunch == y.ix_bunch);
  is_eq = is_eq && (x.ix_turn == y.ix_turn);
  is_eq = is_eq && (x.n_live == y.n_live);
  is_eq = is_eq && (x.n_good == y.n_good);
  is_eq = is_eq && (x.n_bad == y.n_bad);
  return is_eq;
};

template bool is_all_equal (const CPP_bunch_ARRAY&, const CPP_bunch_ARRAY&);
template bool is_all_equal (const CPP_bunch_MATRIX&, const CPP_bunch_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_bunch_params& x, const CPP_bunch_params& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.centroid == y.centroid);
  is_eq = is_eq && (x.x == y.x);
  is_eq = is_eq && (x.y == y.y);
  is_eq = is_eq && (x.z == y.z);
  is_eq = is_eq && (x.a == y.a);
  is_eq = is_eq && (x.b == y.b);
  is_eq = is_eq && (x.c == y.c);
  is_eq = is_eq && is_all_equal(x.sigma, y.sigma);
  is_eq = is_eq && is_all_equal(x.rel_max, y.rel_max);
  is_eq = is_eq && is_all_equal(x.rel_min, y.rel_min);
  is_eq = is_eq && (x.s == y.s);
  is_eq = is_eq && (x.t == y.t);
  is_eq = is_eq && (x.sigma_t == y.sigma_t);
  is_eq = is_eq && (x.charge_live == y.charge_live);
  is_eq = is_eq && (x.charge_tot == y.charge_tot);
  is_eq = is_eq && (x.n_particle_tot == y.n_particle_tot);
  is_eq = is_eq && (x.n_particle_live == y.n_particle_live);
  is_eq = is_eq && (x.n_particle_lost_in_ele == y.n_particle_lost_in_ele);
  is_eq = is_eq && (x.n_good_steps == y.n_good_steps);
  is_eq = is_eq && (x.n_bad_steps == y.n_bad_steps);
  is_eq = is_eq && (x.ix_ele == y.ix_ele);
  is_eq = is_eq && (x.location == y.location);
  is_eq = is_eq && (x.twiss_valid == y.twiss_valid);
  return is_eq;
};

template bool is_all_equal (const CPP_bunch_params_ARRAY&, const CPP_bunch_params_ARRAY&);
template bool is_all_equal (const CPP_bunch_params_MATRIX&, const CPP_bunch_params_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_beam& x, const CPP_beam& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.bunch, y.bunch);
  return is_eq;
};

template bool is_all_equal (const CPP_beam_ARRAY&, const CPP_beam_ARRAY&);
template bool is_all_equal (const CPP_beam_MATRIX&, const CPP_beam_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_aperture_point& x, const CPP_aperture_point& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.x == y.x);
  is_eq = is_eq && (x.y == y.y);
  is_eq = is_eq && (x.plane == y.plane);
  is_eq = is_eq && (x.ix_ele == y.ix_ele);
  is_eq = is_eq && (x.i_turn == y.i_turn);
  return is_eq;
};

template bool is_all_equal (const CPP_aperture_point_ARRAY&, const CPP_aperture_point_ARRAY&);
template bool is_all_equal (const CPP_aperture_point_MATRIX&, const CPP_aperture_point_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_aperture_param& x, const CPP_aperture_param& y) {
  bool is_eq = true;
  is_eq = is_eq && (x.min_angle == y.min_angle);
  is_eq = is_eq && (x.max_angle == y.max_angle);
  is_eq = is_eq && (x.n_angle == y.n_angle);
  is_eq = is_eq && (x.n_turn == y.n_turn);
  is_eq = is_eq && (x.x_init == y.x_init);
  is_eq = is_eq && (x.y_init == y.y_init);
  is_eq = is_eq && (x.rel_accuracy == y.rel_accuracy);
  is_eq = is_eq && (x.abs_accuracy == y.abs_accuracy);
  is_eq = is_eq && (x.start_ele == y.start_ele);
  return is_eq;
};

template bool is_all_equal (const CPP_aperture_param_ARRAY&, const CPP_aperture_param_ARRAY&);
template bool is_all_equal (const CPP_aperture_param_MATRIX&, const CPP_aperture_param_MATRIX&);

//--------------------------------------------------------------

bool operator== (const CPP_aperture_scan& x, const CPP_aperture_scan& y) {
  bool is_eq = true;
  is_eq = is_eq && is_all_equal(x.point, y.point);
  is_eq = is_eq && (x.ref_orb == y.ref_orb);
  is_eq = is_eq && (x.pz_start == y.pz_start);
  return is_eq;
};

template bool is_all_equal (const CPP_aperture_scan_ARRAY&, const CPP_aperture_scan_ARRAY&);
template bool is_all_equal (const CPP_aperture_scan_MATRIX&, const CPP_aperture_scan_MATRIX&);
