
!+
! Fortran side of the Bmad / C++ structure interface.
!
! This file is generated by the Bmad/C++ interface code generation.
! The code generation files can be found in cpp_bmad_interface.
!
! DO NOT EDIT THIS FILE DIRECTLY! 
!-

module bmad_cpp_convert_mod

use bmad_struct
use fortran_cpp_utils
use, intrinsic :: iso_c_binding

!--------------------------------------------------------------------------

interface 
  subroutine spline_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine spin_polar_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine ac_kicker_time_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine ac_kicker_freq_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine ac_kicker_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine interval1_coef_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_reflect_table_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_reflect_surface_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine coord_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine coord_array_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bpm_phase_coupling_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine expression_atom_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wake_sr_z_long_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wake_sr_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wake_sr_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wake_lr_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wake_lr_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine lat_ele_loc_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wake_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine taylor_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine taylor_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_taylor_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_taylor_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine cartesian_map_term1_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine cartesian_map_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine cartesian_map_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine cylindrical_map_term1_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine cylindrical_map_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine cylindrical_map_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine grid_field_pt1_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine grid_field_pt_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine grid_field_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine floor_position_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine high_energy_space_charge_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine xy_disp_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine twiss_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine mode3_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bookkeeping_state_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_map_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_map_ele_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine gen_grad1_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine gen_grad_map_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine surface_segmented_pt_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine surface_segmented_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine surface_h_misalign_pt_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine surface_h_misalign_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine surface_displacement_pt_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine surface_displacement_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine target_point_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine surface_curvature_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_target_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_material_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine pixel_pt_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine pixel_detec_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine photon_element_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wall3d_vertex_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wall3d_section_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine wall3d_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine ramper_lord_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine control_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine control_var1_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine control_ramp1_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine controller_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine ellipse_beam_init_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine kv_beam_init_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine grid_beam_init_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine beam_init_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine lat_param_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine mode_info_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine pre_tracker_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine anormal_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine linac_normal_mode_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine normal_modes_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine em_field_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine strong_beam_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine track_point_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine track_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine space_charge_common_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bmad_common_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_int1_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_int_branch_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine rad_int_all_ele_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine ele_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine complex_taylor_term_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine complex_taylor_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine branch_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine lat_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bunch_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine bunch_params_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine beam_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine aperture_point_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine aperture_param_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

!--------------------------------------------------------------------------

interface 
  subroutine aperture_scan_to_f (C, Fp) bind(c)
    import c_ptr
    type(c_ptr), value :: C, Fp
  end subroutine
end interface

contains

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine spline_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad spline_struct to a C++ CPP_spline structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad spline_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_spline struct.
!-

subroutine spline_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine spline_to_c2 (C, z_x0, z_y0, z_x1, z_coef) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_x0, z_y0, z_x1, z_coef(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(spline_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call spline_to_c2 (C, F%x0, F%y0, F%x1, fvec2vec(F%coef, 4))

end subroutine spline_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine spline_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_spline structure to a Bmad spline_struct structure.
! This routine is called by spline_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the spline_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad spline_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine spline_to_f2 (Fp, z_x0, z_y0, z_x1, z_coef) bind(c)


implicit none

type(c_ptr), value :: Fp
type(spline_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_x0, z_y0, z_x1, z_coef(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0
!! f_side.to_f2_trans[real, 0, NOT]
F%x1 = z_x1
!! f_side.to_f2_trans[real, 1, NOT]
F%coef = z_coef(1:4)

end subroutine spline_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine spin_polar_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad spin_polar_struct to a C++ CPP_spin_polar structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad spin_polar_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_spin_polar struct.
!-

subroutine spin_polar_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine spin_polar_to_c2 (C, z_polarization, z_theta, z_phi, z_xi) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_polarization, z_theta, z_phi, z_xi
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(spin_polar_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call spin_polar_to_c2 (C, F%polarization, F%theta, F%phi, F%xi)

end subroutine spin_polar_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine spin_polar_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_spin_polar structure to a Bmad spin_polar_struct structure.
! This routine is called by spin_polar_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the spin_polar_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad spin_polar_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine spin_polar_to_f2 (Fp, z_polarization, z_theta, z_phi, z_xi) bind(c)


implicit none

type(c_ptr), value :: Fp
type(spin_polar_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_polarization, z_theta, z_phi, z_xi

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%polarization = z_polarization
!! f_side.to_f2_trans[real, 0, NOT]
F%theta = z_theta
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%xi = z_xi

end subroutine spin_polar_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ac_kicker_time_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad ac_kicker_time_struct to a C++ CPP_ac_kicker_time structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad ac_kicker_time_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_ac_kicker_time struct.
!-

subroutine ac_kicker_time_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine ac_kicker_time_to_c2 (C, z_amp, z_time, z_spline) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_amp, z_time
    type(c_ptr), value :: z_spline
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(ac_kicker_time_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call ac_kicker_time_to_c2 (C, F%amp, F%time, c_loc(F%spline))

end subroutine ac_kicker_time_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ac_kicker_time_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_ac_kicker_time structure to a Bmad ac_kicker_time_struct structure.
! This routine is called by ac_kicker_time_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the ac_kicker_time_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad ac_kicker_time_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine ac_kicker_time_to_f2 (Fp, z_amp, z_time, z_spline) bind(c)


implicit none

type(c_ptr), value :: Fp
type(ac_kicker_time_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_amp, z_time
type(c_ptr), value :: z_spline

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%amp = z_amp
!! f_side.to_f2_trans[real, 0, NOT]
F%time = z_time
!! f_side.to_f2_trans[type, 0, NOT]
call spline_to_f(z_spline, c_loc(F%spline))

end subroutine ac_kicker_time_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ac_kicker_freq_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad ac_kicker_freq_struct to a C++ CPP_ac_kicker_freq structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad ac_kicker_freq_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_ac_kicker_freq struct.
!-

subroutine ac_kicker_freq_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine ac_kicker_freq_to_c2 (C, z_f, z_amp, z_phi, z_rf_clock_harmonic) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_f, z_amp, z_phi
    integer(c_int) :: z_rf_clock_harmonic
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(ac_kicker_freq_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call ac_kicker_freq_to_c2 (C, F%f, F%amp, F%phi, F%rf_clock_harmonic)

end subroutine ac_kicker_freq_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ac_kicker_freq_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_ac_kicker_freq structure to a Bmad ac_kicker_freq_struct structure.
! This routine is called by ac_kicker_freq_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the ac_kicker_freq_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad ac_kicker_freq_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine ac_kicker_freq_to_f2 (Fp, z_f, z_amp, z_phi, z_rf_clock_harmonic) bind(c)


implicit none

type(c_ptr), value :: Fp
type(ac_kicker_freq_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_f, z_amp, z_phi
integer(c_int) :: z_rf_clock_harmonic

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%f = z_f
!! f_side.to_f2_trans[real, 0, NOT]
F%amp = z_amp
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[integer, 0, NOT]
F%rf_clock_harmonic = z_rf_clock_harmonic

end subroutine ac_kicker_freq_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ac_kicker_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad ac_kicker_struct to a C++ CPP_ac_kicker structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad ac_kicker_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_ac_kicker struct.
!-

subroutine ac_kicker_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine ac_kicker_to_c2 (C, z_amp_vs_time, n1_amp_vs_time, z_frequency, n1_frequency) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_amp_vs_time(*), z_frequency(*)
    integer(c_int), value :: n1_amp_vs_time, n1_frequency
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(ac_kicker_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_amp_vs_time(:)
integer(c_int) :: n1_amp_vs_time
type(c_ptr), allocatable :: z_frequency(:)
integer(c_int) :: n1_frequency

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_amp_vs_time = 0
if (allocated(F%amp_vs_time)) then
  n1_amp_vs_time = size(F%amp_vs_time); lb1 = lbound(F%amp_vs_time, 1) - 1
  allocate (z_amp_vs_time(n1_amp_vs_time))
  do jd1 = 1, n1_amp_vs_time
    z_amp_vs_time(jd1) = c_loc(F%amp_vs_time(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_frequency = 0
if (allocated(F%frequency)) then
  n1_frequency = size(F%frequency); lb1 = lbound(F%frequency, 1) - 1
  allocate (z_frequency(n1_frequency))
  do jd1 = 1, n1_frequency
    z_frequency(jd1) = c_loc(F%frequency(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call ac_kicker_to_c2 (C, z_amp_vs_time, n1_amp_vs_time, z_frequency, n1_frequency)

end subroutine ac_kicker_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ac_kicker_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_ac_kicker structure to a Bmad ac_kicker_struct structure.
! This routine is called by ac_kicker_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the ac_kicker_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad ac_kicker_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine ac_kicker_to_f2 (Fp, z_amp_vs_time, n1_amp_vs_time, z_frequency, n1_frequency) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(ac_kicker_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr) :: z_amp_vs_time(*), z_frequency(*)
integer(c_int), value :: n1_amp_vs_time, n1_frequency

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_amp_vs_time == 0) then
  if (allocated(F%amp_vs_time)) deallocate(F%amp_vs_time)
else
  if (allocated(F%amp_vs_time)) then
    if (n1_amp_vs_time == 0 .or. any(shape(F%amp_vs_time) /= [n1_amp_vs_time])) deallocate(F%amp_vs_time)
    if (any(lbound(F%amp_vs_time) /= 1)) deallocate(F%amp_vs_time)
  endif
  if (.not. allocated(F%amp_vs_time)) allocate(F%amp_vs_time(1:n1_amp_vs_time+1-1))
  do jd1 = 1, n1_amp_vs_time
    call ac_kicker_time_to_f (z_amp_vs_time(jd1), c_loc(F%amp_vs_time(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_frequency == 0) then
  if (allocated(F%frequency)) deallocate(F%frequency)
else
  if (allocated(F%frequency)) then
    if (n1_frequency == 0 .or. any(shape(F%frequency) /= [n1_frequency])) deallocate(F%frequency)
    if (any(lbound(F%frequency) /= 1)) deallocate(F%frequency)
  endif
  if (.not. allocated(F%frequency)) allocate(F%frequency(1:n1_frequency+1-1))
  do jd1 = 1, n1_frequency
    call ac_kicker_freq_to_f (z_frequency(jd1), c_loc(F%frequency(jd1+1-1)))
  enddo
endif


end subroutine ac_kicker_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine interval1_coef_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad interval1_coef_struct to a C++ CPP_interval1_coef structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad interval1_coef_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_interval1_coef struct.
!-

subroutine interval1_coef_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine interval1_coef_to_c2 (C, z_c0, z_c1, z_n_exp) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_c0, z_c1, z_n_exp
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(interval1_coef_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call interval1_coef_to_c2 (C, F%c0, F%c1, F%n_exp)

end subroutine interval1_coef_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine interval1_coef_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_interval1_coef structure to a Bmad interval1_coef_struct structure.
! This routine is called by interval1_coef_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the interval1_coef_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad interval1_coef_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine interval1_coef_to_f2 (Fp, z_c0, z_c1, z_n_exp) bind(c)


implicit none

type(c_ptr), value :: Fp
type(interval1_coef_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_c0, z_c1, z_n_exp

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%c0 = z_c0
!! f_side.to_f2_trans[real, 0, NOT]
F%c1 = z_c1
!! f_side.to_f2_trans[real, 0, NOT]
F%n_exp = z_n_exp

end subroutine interval1_coef_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_reflect_table_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_reflect_table_struct to a C++ CPP_photon_reflect_table structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_reflect_table_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_reflect_table struct.
!-

subroutine photon_reflect_table_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_reflect_table_to_c2 (C, z_angle, n1_angle, z_energy, n1_energy, z_int1, &
      n1_int1, z_p_reflect, n1_p_reflect, n2_p_reflect, z_max_energy, z_p_reflect_scratch, &
      n1_p_reflect_scratch, z_bragg_angle, n1_bragg_angle) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_angle(*), z_energy(*), z_p_reflect(*), z_max_energy, z_p_reflect_scratch(*), z_bragg_angle(*)
    integer(c_int), value :: n1_angle, n1_energy, n1_int1, n1_p_reflect, n2_p_reflect, n1_p_reflect_scratch, n1_bragg_angle
    type(c_ptr) :: z_int1(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_reflect_table_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n1_angle
integer(c_int) :: n1_energy
type(c_ptr), allocatable :: z_int1(:)
integer(c_int) :: n1_int1
integer(c_int) :: n1_p_reflect
integer(c_int) :: n2_p_reflect
integer(c_int) :: n1_p_reflect_scratch
integer(c_int) :: n1_bragg_angle

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[real, 1, ALLOC]
n1_angle = 0
if (allocated(F%angle)) then
  n1_angle = size(F%angle, 1)
endif
!! f_side.to_c_trans[real, 1, ALLOC]
n1_energy = 0
if (allocated(F%energy)) then
  n1_energy = size(F%energy, 1)
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_int1 = 0
if (allocated(F%int1)) then
  n1_int1 = size(F%int1); lb1 = lbound(F%int1, 1) - 1
  allocate (z_int1(n1_int1))
  do jd1 = 1, n1_int1
    z_int1(jd1) = c_loc(F%int1(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[real, 2, ALLOC]
if (allocated(F%p_reflect)) then
  n1_p_reflect = size(F%p_reflect, 1)
  n2_p_reflect = size(F%p_reflect, 2)
else
  n1_p_reflect = 0; n2_p_reflect = 0
endif
!! f_side.to_c_trans[real, 1, ALLOC]
n1_p_reflect_scratch = 0
if (allocated(F%p_reflect_scratch)) then
  n1_p_reflect_scratch = size(F%p_reflect_scratch, 1)
endif
!! f_side.to_c_trans[real, 1, ALLOC]
n1_bragg_angle = 0
if (allocated(F%bragg_angle)) then
  n1_bragg_angle = size(F%bragg_angle, 1)
endif

!! f_side.to_c2_call
call photon_reflect_table_to_c2 (C, fvec2vec(F%angle, n1_angle), n1_angle, fvec2vec(F%energy, &
    n1_energy), n1_energy, z_int1, n1_int1, mat2vec(F%p_reflect, n1_p_reflect*n2_p_reflect), &
    n1_p_reflect, n2_p_reflect, F%max_energy, fvec2vec(F%p_reflect_scratch, &
    n1_p_reflect_scratch), n1_p_reflect_scratch, fvec2vec(F%bragg_angle, n1_bragg_angle), &
    n1_bragg_angle)

end subroutine photon_reflect_table_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_reflect_table_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_reflect_table structure to a Bmad photon_reflect_table_struct structure.
! This routine is called by photon_reflect_table_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_reflect_table_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_reflect_table_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_reflect_table_to_f2 (Fp, z_angle, n1_angle, z_energy, n1_energy, z_int1, &
    n1_int1, z_p_reflect, n1_p_reflect, n2_p_reflect, z_max_energy, z_p_reflect_scratch, &
    n1_p_reflect_scratch, z_bragg_angle, n1_bragg_angle) bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_reflect_table_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_angle, z_energy, z_p_reflect, z_p_reflect_scratch, z_bragg_angle
real(c_double), pointer :: f_angle(:), f_energy(:), f_p_reflect(:), f_p_reflect_scratch(:), f_bragg_angle(:)
integer(c_int), value :: n1_angle, n1_energy, n1_int1, n1_p_reflect, n2_p_reflect, n1_p_reflect_scratch, n1_bragg_angle
type(c_ptr) :: z_int1(*)
real(c_double) :: z_max_energy

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%angle)) then
  if (n1_angle == 0 .or. any(shape(F%angle) /= [n1_angle])) deallocate(F%angle)
  if (any(lbound(F%angle) /= 1)) deallocate(F%angle)
endif
if (n1_angle /= 0) then
  call c_f_pointer (z_angle, f_angle, [n1_angle])
  if (.not. allocated(F%angle)) allocate(F%angle(n1_angle))
  F%angle = f_angle(1:n1_angle)
else
  if (allocated(F%angle)) deallocate(F%angle)
endif

!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%energy)) then
  if (n1_energy == 0 .or. any(shape(F%energy) /= [n1_energy])) deallocate(F%energy)
  if (any(lbound(F%energy) /= 1)) deallocate(F%energy)
endif
if (n1_energy /= 0) then
  call c_f_pointer (z_energy, f_energy, [n1_energy])
  if (.not. allocated(F%energy)) allocate(F%energy(n1_energy))
  F%energy = f_energy(1:n1_energy)
else
  if (allocated(F%energy)) deallocate(F%energy)
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_int1 == 0) then
  if (allocated(F%int1)) deallocate(F%int1)
else
  if (allocated(F%int1)) then
    if (n1_int1 == 0 .or. any(shape(F%int1) /= [n1_int1])) deallocate(F%int1)
    if (any(lbound(F%int1) /= 1)) deallocate(F%int1)
  endif
  if (.not. allocated(F%int1)) allocate(F%int1(1:n1_int1+1-1))
  do jd1 = 1, n1_int1
    call interval1_coef_to_f (z_int1(jd1), c_loc(F%int1(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 2, ALLOC]
if (allocated(F%p_reflect)) then
  if (n1_p_reflect == 0 .or. any(shape(F%p_reflect) /= [n1_p_reflect, n2_p_reflect])) deallocate(F%p_reflect)
  if (any(lbound(F%p_reflect) /= 1)) deallocate(F%p_reflect)
endif
if (n1_p_reflect /= 0) then
  call c_f_pointer (z_p_reflect, f_p_reflect, [n1_p_reflect*n2_p_reflect])
  if (.not. allocated(F%p_reflect)) allocate(F%p_reflect(n1_p_reflect, n2_p_reflect))
  call vec2mat(f_p_reflect, F%p_reflect)
else
  if (allocated(F%p_reflect)) deallocate(F%p_reflect)
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%max_energy = z_max_energy
!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%p_reflect_scratch)) then
  if (n1_p_reflect_scratch == 0 .or. any(shape(F%p_reflect_scratch) /= [n1_p_reflect_scratch])) deallocate(F%p_reflect_scratch)
  if (any(lbound(F%p_reflect_scratch) /= 1)) deallocate(F%p_reflect_scratch)
endif
if (n1_p_reflect_scratch /= 0) then
  call c_f_pointer (z_p_reflect_scratch, f_p_reflect_scratch, [n1_p_reflect_scratch])
  if (.not. allocated(F%p_reflect_scratch)) allocate(F%p_reflect_scratch(n1_p_reflect_scratch))
  F%p_reflect_scratch = f_p_reflect_scratch(1:n1_p_reflect_scratch)
else
  if (allocated(F%p_reflect_scratch)) deallocate(F%p_reflect_scratch)
endif

!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%bragg_angle)) then
  if (n1_bragg_angle == 0 .or. any(shape(F%bragg_angle) /= [n1_bragg_angle])) deallocate(F%bragg_angle)
  if (any(lbound(F%bragg_angle) /= 1)) deallocate(F%bragg_angle)
endif
if (n1_bragg_angle /= 0) then
  call c_f_pointer (z_bragg_angle, f_bragg_angle, [n1_bragg_angle])
  if (.not. allocated(F%bragg_angle)) allocate(F%bragg_angle(n1_bragg_angle))
  F%bragg_angle = f_bragg_angle(1:n1_bragg_angle)
else
  if (allocated(F%bragg_angle)) deallocate(F%bragg_angle)
endif


end subroutine photon_reflect_table_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_reflect_surface_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_reflect_surface_struct to a C++ CPP_photon_reflect_surface structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_reflect_surface_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_reflect_surface struct.
!-

subroutine photon_reflect_surface_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_reflect_surface_to_c2 (C, z_name, z_description, z_reflectivity_file, &
      z_table, n1_table, z_surface_roughness_rms, z_roughness_correlation_len, z_ix_surface) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_name(*), z_description(*), z_reflectivity_file(*)
    type(c_ptr) :: z_table(*)
    integer(c_int), value :: n1_table
    real(c_double) :: z_surface_roughness_rms, z_roughness_correlation_len
    integer(c_int) :: z_ix_surface
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_reflect_surface_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_table(:)
integer(c_int) :: n1_table

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_table = 0
if (allocated(F%table)) then
  n1_table = size(F%table); lb1 = lbound(F%table, 1) - 1
  allocate (z_table(n1_table))
  do jd1 = 1, n1_table
    z_table(jd1) = c_loc(F%table(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call photon_reflect_surface_to_c2 (C, trim(F%name) // c_null_char, trim(F%description) // &
    c_null_char, trim(F%reflectivity_file) // c_null_char, z_table, n1_table, &
    F%surface_roughness_rms, F%roughness_correlation_len, F%ix_surface)

end subroutine photon_reflect_surface_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_reflect_surface_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_reflect_surface structure to a Bmad photon_reflect_surface_struct structure.
! This routine is called by photon_reflect_surface_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_reflect_surface_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_reflect_surface_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_reflect_surface_to_f2 (Fp, z_name, z_description, z_reflectivity_file, &
    z_table, n1_table, z_surface_roughness_rms, z_roughness_correlation_len, z_ix_surface) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_reflect_surface_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_name(*), z_description(*), z_reflectivity_file(*)
type(c_ptr) :: z_table(*)
integer(c_int), value :: n1_table
real(c_double) :: z_surface_roughness_rms, z_roughness_correlation_len
integer(c_int) :: z_ix_surface

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_description, F%description)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_reflectivity_file, F%reflectivity_file)
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_table == 0) then
  if (allocated(F%table)) deallocate(F%table)
else
  if (allocated(F%table)) then
    if (n1_table == 0 .or. any(shape(F%table) /= [n1_table])) deallocate(F%table)
    if (any(lbound(F%table) /= 1)) deallocate(F%table)
  endif
  if (.not. allocated(F%table)) allocate(F%table(1:n1_table+1-1))
  do jd1 = 1, n1_table
    call photon_reflect_table_to_f (z_table(jd1), c_loc(F%table(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%surface_roughness_rms = z_surface_roughness_rms
!! f_side.to_f2_trans[real, 0, NOT]
F%roughness_correlation_len = z_roughness_correlation_len
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_surface = z_ix_surface

end subroutine photon_reflect_surface_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad coord_struct to a C++ CPP_coord structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad coord_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_coord struct.
!-

subroutine coord_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine coord_to_c2 (C, z_vec, z_s, z_t, z_spin, z_field, z_phase, z_charge, z_dt_ref, &
      z_r, z_p0c, z_e_potential, z_beta, z_ix_ele, z_ix_branch, z_ix_turn, z_ix_user, z_state, &
      z_direction, z_time_dir, z_species, z_location) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_vec(*), z_s, z_t, z_spin(*), z_field(*), z_phase(*), z_charge
    real(c_double) :: z_dt_ref, z_r, z_p0c, z_e_potential, z_beta
    integer(c_int) :: z_ix_ele, z_ix_branch, z_ix_turn, z_ix_user, z_state, z_direction, z_time_dir
    integer(c_int) :: z_species, z_location
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(coord_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call coord_to_c2 (C, fvec2vec(F%vec, 6), F%s, real(F%t, rp), fvec2vec(F%spin, 3), fvec2vec(F%field, 2), &
    fvec2vec(F%phase, 2), F%charge, F%dt_ref, F%r, F%p0c, F%e_potential, F%beta, F%ix_ele, &
    F%ix_branch, F%ix_turn, F%ix_user, F%state, F%direction, F%time_dir, F%species, F%location)

end subroutine coord_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_coord structure to a Bmad coord_struct structure.
! This routine is called by coord_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the coord_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad coord_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine coord_to_f2 (Fp, z_vec, z_s, z_t, z_spin, z_field, z_phase, z_charge, z_dt_ref, z_r, &
    z_p0c, z_e_potential, z_beta, z_ix_ele, z_ix_branch, z_ix_turn, z_ix_user, z_state, &
    z_direction, z_time_dir, z_species, z_location) bind(c)


implicit none

type(c_ptr), value :: Fp
type(coord_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_vec(*), z_s, z_t, z_spin(*), z_field(*), z_phase(*), z_charge
real(c_double) :: z_dt_ref, z_r, z_p0c, z_e_potential, z_beta
integer(c_int) :: z_ix_ele, z_ix_branch, z_ix_turn, z_ix_user, z_state, z_direction, z_time_dir
integer(c_int) :: z_species, z_location

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%vec = z_vec(1:6)
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[real, 0, NOT]
F%t = z_t
!! f_side.to_f2_trans[real, 1, NOT]
F%spin = z_spin(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%field = z_field(1:2)
!! f_side.to_f2_trans[real, 1, NOT]
F%phase = z_phase(1:2)
!! f_side.to_f2_trans[real, 0, NOT]
F%charge = z_charge
!! f_side.to_f2_trans[real, 0, NOT]
F%dt_ref = z_dt_ref
!! f_side.to_f2_trans[real, 0, NOT]
F%r = z_r
!! f_side.to_f2_trans[real, 0, NOT]
F%p0c = z_p0c
!! f_side.to_f2_trans[real, 0, NOT]
F%e_potential = z_e_potential
!! f_side.to_f2_trans[real, 0, NOT]
F%beta = z_beta
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_turn = z_ix_turn
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_user = z_ix_user
!! f_side.to_f2_trans[integer, 0, NOT]
F%state = z_state
!! f_side.to_f2_trans[integer, 0, NOT]
F%direction = z_direction
!! f_side.to_f2_trans[integer, 0, NOT]
F%time_dir = z_time_dir
!! f_side.to_f2_trans[integer, 0, NOT]
F%species = z_species
!! f_side.to_f2_trans[integer, 0, NOT]
F%location = z_location

end subroutine coord_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_array_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad coord_array_struct to a C++ CPP_coord_array structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad coord_array_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_coord_array struct.
!-

subroutine coord_array_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine coord_array_to_c2 (C, z_orbit, n1_orbit) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_orbit(*)
    integer(c_int), value :: n1_orbit
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(coord_array_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_orbit(:)
integer(c_int) :: n1_orbit

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_orbit = 0
if (allocated(F%orbit)) then
  n1_orbit = size(F%orbit); lb1 = lbound(F%orbit, 1) - 1
  allocate (z_orbit(n1_orbit))
  do jd1 = 1, n1_orbit
    z_orbit(jd1) = c_loc(F%orbit(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call coord_array_to_c2 (C, z_orbit, n1_orbit)

end subroutine coord_array_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine coord_array_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_coord_array structure to a Bmad coord_array_struct structure.
! This routine is called by coord_array_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the coord_array_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad coord_array_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine coord_array_to_f2 (Fp, z_orbit, n1_orbit) bind(c)


implicit none

type(c_ptr), value :: Fp
type(coord_array_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr) :: z_orbit(*)
integer(c_int), value :: n1_orbit

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_orbit == 0) then
  if (allocated(F%orbit)) deallocate(F%orbit)
else
  if (allocated(F%orbit)) then
    if (n1_orbit == 0 .or. any(shape(F%orbit) /= [n1_orbit])) deallocate(F%orbit)
    if (any(lbound(F%orbit) /= 1)) deallocate(F%orbit)
  endif
  if (.not. allocated(F%orbit)) allocate(F%orbit(1:n1_orbit+1-1))
  do jd1 = 1, n1_orbit
    call coord_to_f (z_orbit(jd1), c_loc(F%orbit(jd1+1-1)))
  enddo
endif


end subroutine coord_array_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bpm_phase_coupling_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bpm_phase_coupling_struct to a C++ CPP_bpm_phase_coupling structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bpm_phase_coupling_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bpm_phase_coupling struct.
!-

subroutine bpm_phase_coupling_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bpm_phase_coupling_to_c2 (C, z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, &
      z_cbar12_a, z_cbar11_b, z_cbar12_b, z_phi_a, z_phi_b) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, z_cbar12_a, z_cbar11_b
    real(c_double) :: z_cbar12_b, z_phi_a, z_phi_b
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bpm_phase_coupling_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bpm_phase_coupling_to_c2 (C, F%k_22a, F%k_12a, F%k_11b, F%k_12b, F%cbar22_a, F%cbar12_a, &
    F%cbar11_b, F%cbar12_b, F%phi_a, F%phi_b)

end subroutine bpm_phase_coupling_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bpm_phase_coupling_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bpm_phase_coupling structure to a Bmad bpm_phase_coupling_struct structure.
! This routine is called by bpm_phase_coupling_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bpm_phase_coupling_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bpm_phase_coupling_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bpm_phase_coupling_to_f2 (Fp, z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, &
    z_cbar12_a, z_cbar11_b, z_cbar12_b, z_phi_a, z_phi_b) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bpm_phase_coupling_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_k_22a, z_k_12a, z_k_11b, z_k_12b, z_cbar22_a, z_cbar12_a, z_cbar11_b
real(c_double) :: z_cbar12_b, z_phi_a, z_phi_b

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%k_22a = z_k_22a
!! f_side.to_f2_trans[real, 0, NOT]
F%k_12a = z_k_12a
!! f_side.to_f2_trans[real, 0, NOT]
F%k_11b = z_k_11b
!! f_side.to_f2_trans[real, 0, NOT]
F%k_12b = z_k_12b
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar22_a = z_cbar22_a
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar12_a = z_cbar12_a
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar11_b = z_cbar11_b
!! f_side.to_f2_trans[real, 0, NOT]
F%cbar12_b = z_cbar12_b
!! f_side.to_f2_trans[real, 0, NOT]
F%phi_a = z_phi_a
!! f_side.to_f2_trans[real, 0, NOT]
F%phi_b = z_phi_b

end subroutine bpm_phase_coupling_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine expression_atom_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad expression_atom_struct to a C++ CPP_expression_atom structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad expression_atom_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_expression_atom struct.
!-

subroutine expression_atom_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine expression_atom_to_c2 (C, z_name, z_type, z_value) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_name(*)
    integer(c_int) :: z_type
    real(c_double) :: z_value
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(expression_atom_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call expression_atom_to_c2 (C, trim(F%name) // c_null_char, F%type, F%value)

end subroutine expression_atom_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine expression_atom_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_expression_atom structure to a Bmad expression_atom_struct structure.
! This routine is called by expression_atom_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the expression_atom_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad expression_atom_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine expression_atom_to_f2 (Fp, z_name, z_type, z_value) bind(c)


implicit none

type(c_ptr), value :: Fp
type(expression_atom_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_name(*)
integer(c_int) :: z_type
real(c_double) :: z_value

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type
!! f_side.to_f2_trans[real, 0, NOT]
F%value = z_value

end subroutine expression_atom_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_sr_z_long_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wake_sr_z_long_struct to a C++ CPP_wake_sr_z_long structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wake_sr_z_long_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wake_sr_z_long struct.
!-

subroutine wake_sr_z_long_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wake_sr_z_long_to_c2 (C, z_w, n1_w, z_fw, n1_fw, z_fbunch, n1_fbunch, z_w_out, &
      n1_w_out, z_dz, z_z0, z_smoothing_sigma, z_position_dependence, z_time_based) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_w(*), z_dz, z_z0, z_smoothing_sigma
    integer(c_int), value :: n1_w, n1_fw, n1_fbunch, n1_w_out
    complex(c_double_complex) :: z_fw(*), z_fbunch(*), z_w_out(*)
    integer(c_int) :: z_position_dependence
    logical(c_bool) :: z_time_based
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wake_sr_z_long_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n1_w
integer(c_int) :: n1_fw
integer(c_int) :: n1_fbunch
integer(c_int) :: n1_w_out

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[real, 1, ALLOC]
n1_w = 0
if (allocated(F%w)) then
  n1_w = size(F%w, 1)
endif
!! f_side.to_c_trans[complex, 1, ALLOC]
n1_fw = 0
if (allocated(F%fw)) then
  n1_fw = size(F%fw, 1)
endif
!! f_side.to_c_trans[complex, 1, ALLOC]
n1_fbunch = 0
if (allocated(F%fbunch)) then
  n1_fbunch = size(F%fbunch, 1)
endif
!! f_side.to_c_trans[complex, 1, ALLOC]
n1_w_out = 0
if (allocated(F%w_out)) then
  n1_w_out = size(F%w_out, 1)
endif

!! f_side.to_c2_call
call wake_sr_z_long_to_c2 (C, fvec2vec(F%w, n1_w), n1_w, fvec2vec(F%fw, n1_fw), n1_fw, &
    fvec2vec(F%fbunch, n1_fbunch), n1_fbunch, fvec2vec(F%w_out, n1_w_out), n1_w_out, F%dz, &
    F%z0, F%smoothing_sigma, F%position_dependence, c_logic(F%time_based))

end subroutine wake_sr_z_long_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_sr_z_long_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wake_sr_z_long structure to a Bmad wake_sr_z_long_struct structure.
! This routine is called by wake_sr_z_long_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wake_sr_z_long_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wake_sr_z_long_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wake_sr_z_long_to_f2 (Fp, z_w, n1_w, z_fw, n1_fw, z_fbunch, n1_fbunch, z_w_out, &
    n1_w_out, z_dz, z_z0, z_smoothing_sigma, z_position_dependence, z_time_based) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wake_sr_z_long_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_w, z_fw, z_fbunch, z_w_out
real(c_double), pointer :: f_w(:)
integer(c_int), value :: n1_w, n1_fw, n1_fbunch, n1_w_out
complex(c_double_complex), pointer :: f_fw(:), f_fbunch(:), f_w_out(:)
real(c_double) :: z_dz, z_z0, z_smoothing_sigma
integer(c_int) :: z_position_dependence
logical(c_bool) :: z_time_based

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%w)) then
  if (n1_w == 0 .or. any(shape(F%w) /= [n1_w])) deallocate(F%w)
  if (any(lbound(F%w) /= 1)) deallocate(F%w)
endif
if (n1_w /= 0) then
  call c_f_pointer (z_w, f_w, [n1_w])
  if (.not. allocated(F%w)) allocate(F%w(n1_w))
  F%w = f_w(1:n1_w)
else
  if (allocated(F%w)) deallocate(F%w)
endif

!! f_side.to_f2_trans[complex, 1, ALLOC]
if (allocated(F%fw)) then
  if (n1_fw == 0 .or. any(shape(F%fw) /= [n1_fw])) deallocate(F%fw)
  if (any(lbound(F%fw) /= 1)) deallocate(F%fw)
endif
if (n1_fw /= 0) then
  call c_f_pointer (z_fw, f_fw, [n1_fw])
  if (.not. allocated(F%fw)) allocate(F%fw(n1_fw))
  F%fw = f_fw(1:n1_fw)
else
  if (allocated(F%fw)) deallocate(F%fw)
endif

!! f_side.to_f2_trans[complex, 1, ALLOC]
if (allocated(F%fbunch)) then
  if (n1_fbunch == 0 .or. any(shape(F%fbunch) /= [n1_fbunch])) deallocate(F%fbunch)
  if (any(lbound(F%fbunch) /= 1)) deallocate(F%fbunch)
endif
if (n1_fbunch /= 0) then
  call c_f_pointer (z_fbunch, f_fbunch, [n1_fbunch])
  if (.not. allocated(F%fbunch)) allocate(F%fbunch(n1_fbunch))
  F%fbunch = f_fbunch(1:n1_fbunch)
else
  if (allocated(F%fbunch)) deallocate(F%fbunch)
endif

!! f_side.to_f2_trans[complex, 1, ALLOC]
if (allocated(F%w_out)) then
  if (n1_w_out == 0 .or. any(shape(F%w_out) /= [n1_w_out])) deallocate(F%w_out)
  if (any(lbound(F%w_out) /= 1)) deallocate(F%w_out)
endif
if (n1_w_out /= 0) then
  call c_f_pointer (z_w_out, f_w_out, [n1_w_out])
  if (.not. allocated(F%w_out)) allocate(F%w_out(n1_w_out))
  F%w_out = f_w_out(1:n1_w_out)
else
  if (allocated(F%w_out)) deallocate(F%w_out)
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%dz = z_dz
!! f_side.to_f2_trans[real, 0, NOT]
F%z0 = z_z0
!! f_side.to_f2_trans[real, 0, NOT]
F%smoothing_sigma = z_smoothing_sigma
!! f_side.to_f2_trans[integer, 0, NOT]
F%position_dependence = z_position_dependence
!! f_side.to_f2_trans[logical, 0, NOT]
F%time_based = f_logic(z_time_based)

end subroutine wake_sr_z_long_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_sr_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wake_sr_mode_struct to a C++ CPP_wake_sr_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wake_sr_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wake_sr_mode struct.
!-

subroutine wake_sr_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wake_sr_mode_to_c2 (C, z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin, &
      z_a_cos, z_polarization, z_position_dependence) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin
    real(c_double) :: z_a_cos
    integer(c_int) :: z_polarization, z_position_dependence
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wake_sr_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wake_sr_mode_to_c2 (C, F%amp, F%damp, F%k, F%phi, F%b_sin, F%b_cos, F%a_sin, F%a_cos, &
    F%polarization, F%position_dependence)

end subroutine wake_sr_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_sr_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wake_sr_mode structure to a Bmad wake_sr_mode_struct structure.
! This routine is called by wake_sr_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wake_sr_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wake_sr_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wake_sr_mode_to_f2 (Fp, z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin, &
    z_a_cos, z_polarization, z_position_dependence) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wake_sr_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_amp, z_damp, z_k, z_phi, z_b_sin, z_b_cos, z_a_sin
real(c_double) :: z_a_cos
integer(c_int) :: z_polarization, z_position_dependence

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%amp = z_amp
!! f_side.to_f2_trans[real, 0, NOT]
F%damp = z_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%k = z_k
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%b_sin = z_b_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%b_cos = z_b_cos
!! f_side.to_f2_trans[real, 0, NOT]
F%a_sin = z_a_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%a_cos = z_a_cos
!! f_side.to_f2_trans[integer, 0, NOT]
F%polarization = z_polarization
!! f_side.to_f2_trans[integer, 0, NOT]
F%position_dependence = z_position_dependence

end subroutine wake_sr_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_sr_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wake_sr_struct to a C++ CPP_wake_sr structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wake_sr_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wake_sr struct.
!-

subroutine wake_sr_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wake_sr_to_c2 (C, z_file, z_z_long, z_long, n1_long, z_trans, n1_trans, &
      z_z_ref_long, z_z_ref_trans, z_z_max, z_amp_scale, z_z_scale, z_scale_with_length) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_file(*)
    type(c_ptr), value :: z_z_long
    type(c_ptr) :: z_long(*), z_trans(*)
    integer(c_int), value :: n1_long, n1_trans
    real(c_double) :: z_z_ref_long, z_z_ref_trans, z_z_max, z_amp_scale, z_z_scale
    logical(c_bool) :: z_scale_with_length
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wake_sr_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_long(:)
integer(c_int) :: n1_long
type(c_ptr), allocatable :: z_trans(:)
integer(c_int) :: n1_trans

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_long = 0
if (allocated(F%long)) then
  n1_long = size(F%long); lb1 = lbound(F%long, 1) - 1
  allocate (z_long(n1_long))
  do jd1 = 1, n1_long
    z_long(jd1) = c_loc(F%long(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_trans = 0
if (allocated(F%trans)) then
  n1_trans = size(F%trans); lb1 = lbound(F%trans, 1) - 1
  allocate (z_trans(n1_trans))
  do jd1 = 1, n1_trans
    z_trans(jd1) = c_loc(F%trans(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call wake_sr_to_c2 (C, trim(F%file) // c_null_char, c_loc(F%z_long), z_long, n1_long, z_trans, &
    n1_trans, F%z_ref_long, F%z_ref_trans, F%z_max, F%amp_scale, F%z_scale, &
    c_logic(F%scale_with_length))

end subroutine wake_sr_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_sr_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wake_sr structure to a Bmad wake_sr_struct structure.
! This routine is called by wake_sr_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wake_sr_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wake_sr_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wake_sr_to_f2 (Fp, z_file, z_z_long, z_long, n1_long, z_trans, n1_trans, &
    z_z_ref_long, z_z_ref_trans, z_z_max, z_amp_scale, z_z_scale, z_scale_with_length) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wake_sr_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_file(*)
type(c_ptr), value :: z_z_long
type(c_ptr) :: z_long(*), z_trans(*)
integer(c_int), value :: n1_long, n1_trans
real(c_double) :: z_z_ref_long, z_z_ref_trans, z_z_max, z_amp_scale, z_z_scale
logical(c_bool) :: z_scale_with_length

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[type, 0, NOT]
call wake_sr_z_long_to_f(z_z_long, c_loc(F%z_long))
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_long == 0) then
  if (allocated(F%long)) deallocate(F%long)
else
  if (allocated(F%long)) then
    if (n1_long == 0 .or. any(shape(F%long) /= [n1_long])) deallocate(F%long)
    if (any(lbound(F%long) /= 1)) deallocate(F%long)
  endif
  if (.not. allocated(F%long)) allocate(F%long(1:n1_long+1-1))
  do jd1 = 1, n1_long
    call wake_sr_mode_to_f (z_long(jd1), c_loc(F%long(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_trans == 0) then
  if (allocated(F%trans)) deallocate(F%trans)
else
  if (allocated(F%trans)) then
    if (n1_trans == 0 .or. any(shape(F%trans) /= [n1_trans])) deallocate(F%trans)
    if (any(lbound(F%trans) /= 1)) deallocate(F%trans)
  endif
  if (.not. allocated(F%trans)) allocate(F%trans(1:n1_trans+1-1))
  do jd1 = 1, n1_trans
    call wake_sr_mode_to_f (z_trans(jd1), c_loc(F%trans(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%z_ref_long = z_z_ref_long
!! f_side.to_f2_trans[real, 0, NOT]
F%z_ref_trans = z_z_ref_trans
!! f_side.to_f2_trans[real, 0, NOT]
F%z_max = z_z_max
!! f_side.to_f2_trans[real, 0, NOT]
F%amp_scale = z_amp_scale
!! f_side.to_f2_trans[real, 0, NOT]
F%z_scale = z_z_scale
!! f_side.to_f2_trans[logical, 0, NOT]
F%scale_with_length = f_logic(z_scale_with_length)

end subroutine wake_sr_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_lr_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wake_lr_mode_struct to a C++ CPP_wake_lr_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wake_lr_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wake_lr_mode struct.
!-

subroutine wake_lr_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wake_lr_mode_to_c2 (C, z_freq, z_freq_in, z_r_over_q, z_q, z_damp, z_phi, z_angle, &
      z_b_sin, z_b_cos, z_a_sin, z_a_cos, z_m, z_polarized) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_freq, z_freq_in, z_r_over_q, z_q, z_damp, z_phi, z_angle
    real(c_double) :: z_b_sin, z_b_cos, z_a_sin, z_a_cos
    integer(c_int) :: z_m
    logical(c_bool) :: z_polarized
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wake_lr_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wake_lr_mode_to_c2 (C, F%freq, F%freq_in, F%r_over_q, F%q, F%damp, F%phi, F%angle, &
    F%b_sin, F%b_cos, F%a_sin, F%a_cos, F%m, c_logic(F%polarized))

end subroutine wake_lr_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_lr_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wake_lr_mode structure to a Bmad wake_lr_mode_struct structure.
! This routine is called by wake_lr_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wake_lr_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wake_lr_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wake_lr_mode_to_f2 (Fp, z_freq, z_freq_in, z_r_over_q, z_q, z_damp, z_phi, z_angle, &
    z_b_sin, z_b_cos, z_a_sin, z_a_cos, z_m, z_polarized) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wake_lr_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_freq, z_freq_in, z_r_over_q, z_q, z_damp, z_phi, z_angle
real(c_double) :: z_b_sin, z_b_cos, z_a_sin, z_a_cos
integer(c_int) :: z_m
logical(c_bool) :: z_polarized

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%freq = z_freq
!! f_side.to_f2_trans[real, 0, NOT]
F%freq_in = z_freq_in
!! f_side.to_f2_trans[real, 0, NOT]
F%r_over_q = z_r_over_q
!! f_side.to_f2_trans[real, 0, NOT]
F%q = z_q
!! f_side.to_f2_trans[real, 0, NOT]
F%damp = z_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%angle = z_angle
!! f_side.to_f2_trans[real, 0, NOT]
F%b_sin = z_b_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%b_cos = z_b_cos
!! f_side.to_f2_trans[real, 0, NOT]
F%a_sin = z_a_sin
!! f_side.to_f2_trans[real, 0, NOT]
F%a_cos = z_a_cos
!! f_side.to_f2_trans[integer, 0, NOT]
F%m = z_m
!! f_side.to_f2_trans[logical, 0, NOT]
F%polarized = f_logic(z_polarized)

end subroutine wake_lr_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_lr_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wake_lr_struct to a C++ CPP_wake_lr structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wake_lr_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wake_lr struct.
!-

subroutine wake_lr_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wake_lr_to_c2 (C, z_file, z_mode, n1_mode, z_t_ref, z_freq_spread, z_amp_scale, &
      z_time_scale, z_self_wake_on) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_file(*)
    type(c_ptr) :: z_mode(*)
    integer(c_int), value :: n1_mode
    real(c_double) :: z_t_ref, z_freq_spread, z_amp_scale, z_time_scale
    logical(c_bool) :: z_self_wake_on
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wake_lr_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_mode(:)
integer(c_int) :: n1_mode

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_mode = 0
if (allocated(F%mode)) then
  n1_mode = size(F%mode); lb1 = lbound(F%mode, 1) - 1
  allocate (z_mode(n1_mode))
  do jd1 = 1, n1_mode
    z_mode(jd1) = c_loc(F%mode(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call wake_lr_to_c2 (C, trim(F%file) // c_null_char, z_mode, n1_mode, F%t_ref, F%freq_spread, &
    F%amp_scale, F%time_scale, c_logic(F%self_wake_on))

end subroutine wake_lr_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_lr_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wake_lr structure to a Bmad wake_lr_struct structure.
! This routine is called by wake_lr_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wake_lr_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wake_lr_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wake_lr_to_f2 (Fp, z_file, z_mode, n1_mode, z_t_ref, z_freq_spread, z_amp_scale, &
    z_time_scale, z_self_wake_on) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wake_lr_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_file(*)
type(c_ptr) :: z_mode(*)
integer(c_int), value :: n1_mode
real(c_double) :: z_t_ref, z_freq_spread, z_amp_scale, z_time_scale
logical(c_bool) :: z_self_wake_on

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_mode == 0) then
  if (allocated(F%mode)) deallocate(F%mode)
else
  if (allocated(F%mode)) then
    if (n1_mode == 0 .or. any(shape(F%mode) /= [n1_mode])) deallocate(F%mode)
    if (any(lbound(F%mode) /= 1)) deallocate(F%mode)
  endif
  if (.not. allocated(F%mode)) allocate(F%mode(1:n1_mode+1-1))
  do jd1 = 1, n1_mode
    call wake_lr_mode_to_f (z_mode(jd1), c_loc(F%mode(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%t_ref = z_t_ref
!! f_side.to_f2_trans[real, 0, NOT]
F%freq_spread = z_freq_spread
!! f_side.to_f2_trans[real, 0, NOT]
F%amp_scale = z_amp_scale
!! f_side.to_f2_trans[real, 0, NOT]
F%time_scale = z_time_scale
!! f_side.to_f2_trans[logical, 0, NOT]
F%self_wake_on = f_logic(z_self_wake_on)

end subroutine wake_lr_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_ele_loc_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad lat_ele_loc_struct to a C++ CPP_lat_ele_loc structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad lat_ele_loc_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_lat_ele_loc struct.
!-

subroutine lat_ele_loc_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine lat_ele_loc_to_c2 (C, z_ix_ele, z_ix_branch) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_ix_ele, z_ix_branch
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(lat_ele_loc_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call lat_ele_loc_to_c2 (C, F%ix_ele, F%ix_branch)

end subroutine lat_ele_loc_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_ele_loc_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_lat_ele_loc structure to a Bmad lat_ele_loc_struct structure.
! This routine is called by lat_ele_loc_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the lat_ele_loc_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad lat_ele_loc_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine lat_ele_loc_to_f2 (Fp, z_ix_ele, z_ix_branch) bind(c)


implicit none

type(c_ptr), value :: Fp
type(lat_ele_loc_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_ix_ele, z_ix_branch

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch

end subroutine lat_ele_loc_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wake_struct to a C++ CPP_wake structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wake_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wake struct.
!-

subroutine wake_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wake_to_c2 (C, z_sr, z_lr) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_sr, z_lr
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wake_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wake_to_c2 (C, c_loc(F%sr), c_loc(F%lr))

end subroutine wake_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wake_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wake structure to a Bmad wake_struct structure.
! This routine is called by wake_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wake_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wake_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wake_to_f2 (Fp, z_sr, z_lr) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wake_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_sr, z_lr

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 0, NOT]
call wake_sr_to_f(z_sr, c_loc(F%sr))
!! f_side.to_f2_trans[type, 0, NOT]
call wake_lr_to_f(z_lr, c_loc(F%lr))

end subroutine wake_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad taylor_term_struct to a C++ CPP_taylor_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad taylor_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_taylor_term struct.
!-

subroutine taylor_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine taylor_term_to_c2 (C, z_coef, z_expn) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_coef
    integer(c_int) :: z_expn(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call taylor_term_to_c2 (C, F%coef, fvec2vec(F%expn, 6))

end subroutine taylor_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_taylor_term structure to a Bmad taylor_term_struct structure.
! This routine is called by taylor_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the taylor_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad taylor_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine taylor_term_to_f2 (Fp, z_coef, z_expn) bind(c)


implicit none

type(c_ptr), value :: Fp
type(taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_coef
integer(c_int) :: z_expn(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[integer, 1, NOT]
F%expn = z_expn(1:6)

end subroutine taylor_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad taylor_struct to a C++ CPP_taylor structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad taylor_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_taylor struct.
!-

subroutine taylor_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine taylor_to_c2 (C, z_ref, z_term, n1_term) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_ref
    type(c_ptr) :: z_term(*)
    integer(c_int), value :: n1_term
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, PTR]
 n1_term = 0
if (associated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call taylor_to_c2 (C, F%ref, z_term, n1_term)

end subroutine taylor_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine taylor_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_taylor structure to a Bmad taylor_struct structure.
! This routine is called by taylor_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the taylor_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad taylor_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine taylor_to_f2 (Fp, z_ref, z_term, n1_term) bind(c)


implicit none

type(c_ptr), value :: Fp
type(taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_ref
type(c_ptr) :: z_term(*)
integer(c_int), value :: n1_term

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%ref = z_ref
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_term == 0) then
  if (associated(F%term)) deallocate(F%term)
else
  if (associated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. associated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call taylor_term_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine taylor_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_taylor_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_taylor_term_struct to a C++ CPP_em_taylor_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_taylor_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_taylor_term struct.
!-

subroutine em_taylor_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_taylor_term_to_c2 (C, z_coef, z_expn) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_coef
    integer(c_int) :: z_expn(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call em_taylor_term_to_c2 (C, F%coef, fvec2vec(F%expn, 2))

end subroutine em_taylor_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_taylor_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_taylor_term structure to a Bmad em_taylor_term_struct structure.
! This routine is called by em_taylor_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_taylor_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_taylor_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_taylor_term_to_f2 (Fp, z_coef, z_expn) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_coef
integer(c_int) :: z_expn(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[integer, 1, NOT]
F%expn = z_expn(1:2)

end subroutine em_taylor_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_taylor_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_taylor_struct to a C++ CPP_em_taylor structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_taylor_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_taylor struct.
!-

subroutine em_taylor_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_taylor_to_c2 (C, z_ref, z_term, n1_term) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_ref
    type(c_ptr) :: z_term(*)
    integer(c_int), value :: n1_term
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_term = 0
if (allocated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call em_taylor_to_c2 (C, F%ref, z_term, n1_term)

end subroutine em_taylor_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_taylor_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_taylor structure to a Bmad em_taylor_struct structure.
! This routine is called by em_taylor_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_taylor_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_taylor_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_taylor_to_f2 (Fp, z_ref, z_term, n1_term) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_ref
type(c_ptr) :: z_term(*)
integer(c_int), value :: n1_term

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%ref = z_ref
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_term == 0) then
  if (allocated(F%term)) deallocate(F%term)
else
  if (allocated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. allocated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call em_taylor_term_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine em_taylor_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cartesian_map_term1_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad cartesian_map_term1_struct to a C++ CPP_cartesian_map_term1 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad cartesian_map_term1_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_cartesian_map_term1 struct.
!-

subroutine cartesian_map_term1_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine cartesian_map_term1_to_c2 (C, z_coef, z_kx, z_ky, z_kz, z_x0, z_y0, z_phi_z, &
      z_family, z_form) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_coef, z_kx, z_ky, z_kz, z_x0, z_y0, z_phi_z
    integer(c_int) :: z_family, z_form
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(cartesian_map_term1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call cartesian_map_term1_to_c2 (C, F%coef, F%kx, F%ky, F%kz, F%x0, F%y0, F%phi_z, F%family, &
    F%form)

end subroutine cartesian_map_term1_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cartesian_map_term1_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_cartesian_map_term1 structure to a Bmad cartesian_map_term1_struct structure.
! This routine is called by cartesian_map_term1_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the cartesian_map_term1_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad cartesian_map_term1_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine cartesian_map_term1_to_f2 (Fp, z_coef, z_kx, z_ky, z_kz, z_x0, z_y0, z_phi_z, &
    z_family, z_form) bind(c)


implicit none

type(c_ptr), value :: Fp
type(cartesian_map_term1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_coef, z_kx, z_ky, z_kz, z_x0, z_y0, z_phi_z
integer(c_int) :: z_family, z_form

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[real, 0, NOT]
F%kx = z_kx
!! f_side.to_f2_trans[real, 0, NOT]
F%ky = z_ky
!! f_side.to_f2_trans[real, 0, NOT]
F%kz = z_kz
!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0
!! f_side.to_f2_trans[real, 0, NOT]
F%phi_z = z_phi_z
!! f_side.to_f2_trans[integer, 0, NOT]
F%family = z_family
!! f_side.to_f2_trans[integer, 0, NOT]
F%form = z_form

end subroutine cartesian_map_term1_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cartesian_map_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad cartesian_map_term_struct to a C++ CPP_cartesian_map_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad cartesian_map_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_cartesian_map_term struct.
!-

subroutine cartesian_map_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine cartesian_map_term_to_c2 (C, z_file, z_n_link, z_term, n1_term) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_file(*)
    integer(c_int) :: z_n_link
    type(c_ptr) :: z_term(*)
    integer(c_int), value :: n1_term
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(cartesian_map_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_term = 0
if (allocated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call cartesian_map_term_to_c2 (C, trim(F%file) // c_null_char, F%n_link, z_term, n1_term)

end subroutine cartesian_map_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cartesian_map_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_cartesian_map_term structure to a Bmad cartesian_map_term_struct structure.
! This routine is called by cartesian_map_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the cartesian_map_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad cartesian_map_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine cartesian_map_term_to_f2 (Fp, z_file, z_n_link, z_term, n1_term) bind(c)


implicit none

type(c_ptr), value :: Fp
type(cartesian_map_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_file(*)
integer(c_int) :: z_n_link
type(c_ptr) :: z_term(*)
integer(c_int), value :: n1_term

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_term == 0) then
  if (allocated(F%term)) deallocate(F%term)
else
  if (allocated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. allocated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call cartesian_map_term1_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine cartesian_map_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cartesian_map_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad cartesian_map_struct to a C++ CPP_cartesian_map structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad cartesian_map_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_cartesian_map struct.
!-

subroutine cartesian_map_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine cartesian_map_to_c2 (C, z_field_scale, z_r0, z_master_parameter, z_ele_anchor_pt, &
      z_field_type, z_ptr, n_ptr) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_field_scale, z_r0(*)
    integer(c_int) :: z_master_parameter, z_ele_anchor_pt, z_field_type
    type(c_ptr), value :: z_ptr
    integer(c_int), value :: n_ptr
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(cartesian_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n_ptr

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 0, PTR]
n_ptr = 0
if (associated(F%ptr)) n_ptr = 1

!! f_side.to_c2_call
call cartesian_map_to_c2 (C, F%field_scale, fvec2vec(F%r0, 3), F%master_parameter, &
    F%ele_anchor_pt, F%field_type, c_loc(F%ptr), n_ptr)

end subroutine cartesian_map_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cartesian_map_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_cartesian_map structure to a Bmad cartesian_map_struct structure.
! This routine is called by cartesian_map_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the cartesian_map_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad cartesian_map_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine cartesian_map_to_f2 (Fp, z_field_scale, z_r0, z_master_parameter, z_ele_anchor_pt, &
    z_field_type, z_ptr, n_ptr) bind(c)


implicit none

type(c_ptr), value :: Fp
type(cartesian_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_field_scale, z_r0(*)
integer(c_int) :: z_master_parameter, z_ele_anchor_pt, z_field_type
type(c_ptr), value :: z_ptr
type(cartesian_map_term_struct), pointer :: f_ptr
integer(c_int), value :: n_ptr

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%field_scale = z_field_scale
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:3)
!! f_side.to_f2_trans[integer, 0, NOT]
F%master_parameter = z_master_parameter
!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[integer, 0, NOT]
F%field_type = z_field_type
!! f_side.to_f2_trans[type, 0, PTR]
if (n_ptr == 0) then
  if (associated(F%ptr)) deallocate(F%ptr)
else
  if (.not. associated(F%ptr)) allocate(F%ptr)
  call cartesian_map_term_to_f (z_ptr, c_loc(F%ptr))
endif


end subroutine cartesian_map_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cylindrical_map_term1_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad cylindrical_map_term1_struct to a C++ CPP_cylindrical_map_term1 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad cylindrical_map_term1_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_cylindrical_map_term1 struct.
!-

subroutine cylindrical_map_term1_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine cylindrical_map_term1_to_c2 (C, z_e_coef, z_b_coef) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_e_coef, z_b_coef
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(cylindrical_map_term1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call cylindrical_map_term1_to_c2 (C, F%e_coef, F%b_coef)

end subroutine cylindrical_map_term1_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cylindrical_map_term1_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_cylindrical_map_term1 structure to a Bmad cylindrical_map_term1_struct structure.
! This routine is called by cylindrical_map_term1_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the cylindrical_map_term1_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad cylindrical_map_term1_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine cylindrical_map_term1_to_f2 (Fp, z_e_coef, z_b_coef) bind(c)


implicit none

type(c_ptr), value :: Fp
type(cylindrical_map_term1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_e_coef, z_b_coef

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 0, NOT]
F%e_coef = z_e_coef
!! f_side.to_f2_trans[complex, 0, NOT]
F%b_coef = z_b_coef

end subroutine cylindrical_map_term1_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cylindrical_map_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad cylindrical_map_term_struct to a C++ CPP_cylindrical_map_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad cylindrical_map_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_cylindrical_map_term struct.
!-

subroutine cylindrical_map_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine cylindrical_map_term_to_c2 (C, z_file, z_n_link, z_term, n1_term) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_file(*)
    integer(c_int) :: z_n_link
    type(c_ptr) :: z_term(*)
    integer(c_int), value :: n1_term
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(cylindrical_map_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_term = 0
if (allocated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call cylindrical_map_term_to_c2 (C, trim(F%file) // c_null_char, F%n_link, z_term, n1_term)

end subroutine cylindrical_map_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cylindrical_map_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_cylindrical_map_term structure to a Bmad cylindrical_map_term_struct structure.
! This routine is called by cylindrical_map_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the cylindrical_map_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad cylindrical_map_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine cylindrical_map_term_to_f2 (Fp, z_file, z_n_link, z_term, n1_term) bind(c)


implicit none

type(c_ptr), value :: Fp
type(cylindrical_map_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_file(*)
integer(c_int) :: z_n_link
type(c_ptr) :: z_term(*)
integer(c_int), value :: n1_term

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_term == 0) then
  if (allocated(F%term)) deallocate(F%term)
else
  if (allocated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. allocated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call cylindrical_map_term1_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine cylindrical_map_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cylindrical_map_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad cylindrical_map_struct to a C++ CPP_cylindrical_map structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad cylindrical_map_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_cylindrical_map struct.
!-

subroutine cylindrical_map_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine cylindrical_map_to_c2 (C, z_m, z_harmonic, z_phi0_fieldmap, z_theta0_azimuth, &
      z_field_scale, z_master_parameter, z_ele_anchor_pt, z_dz, z_r0, z_ptr, n_ptr) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_m, z_harmonic, z_master_parameter, z_ele_anchor_pt
    real(c_double) :: z_phi0_fieldmap, z_theta0_azimuth, z_field_scale, z_dz, z_r0(*)
    type(c_ptr), value :: z_ptr
    integer(c_int), value :: n_ptr
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(cylindrical_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n_ptr

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 0, PTR]
n_ptr = 0
if (associated(F%ptr)) n_ptr = 1

!! f_side.to_c2_call
call cylindrical_map_to_c2 (C, F%m, F%harmonic, F%phi0_fieldmap, F%theta0_azimuth, &
    F%field_scale, F%master_parameter, F%ele_anchor_pt, F%dz, fvec2vec(F%r0, 3), c_loc(F%ptr), &
    n_ptr)

end subroutine cylindrical_map_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine cylindrical_map_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_cylindrical_map structure to a Bmad cylindrical_map_struct structure.
! This routine is called by cylindrical_map_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the cylindrical_map_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad cylindrical_map_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine cylindrical_map_to_f2 (Fp, z_m, z_harmonic, z_phi0_fieldmap, z_theta0_azimuth, &
    z_field_scale, z_master_parameter, z_ele_anchor_pt, z_dz, z_r0, z_ptr, n_ptr) bind(c)


implicit none

type(c_ptr), value :: Fp
type(cylindrical_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_m, z_harmonic, z_master_parameter, z_ele_anchor_pt
real(c_double) :: z_phi0_fieldmap, z_theta0_azimuth, z_field_scale, z_dz, z_r0(*)
type(c_ptr), value :: z_ptr
type(cylindrical_map_term_struct), pointer :: f_ptr
integer(c_int), value :: n_ptr

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%m = z_m
!! f_side.to_f2_trans[integer, 0, NOT]
F%harmonic = z_harmonic
!! f_side.to_f2_trans[real, 0, NOT]
F%phi0_fieldmap = z_phi0_fieldmap
!! f_side.to_f2_trans[real, 0, NOT]
F%theta0_azimuth = z_theta0_azimuth
!! f_side.to_f2_trans[real, 0, NOT]
F%field_scale = z_field_scale
!! f_side.to_f2_trans[integer, 0, NOT]
F%master_parameter = z_master_parameter
!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[real, 0, NOT]
F%dz = z_dz
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:3)
!! f_side.to_f2_trans[type, 0, PTR]
if (n_ptr == 0) then
  if (associated(F%ptr)) deallocate(F%ptr)
else
  if (.not. associated(F%ptr)) allocate(F%ptr)
  call cylindrical_map_term_to_f (z_ptr, c_loc(F%ptr))
endif


end subroutine cylindrical_map_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine grid_field_pt1_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad grid_field_pt1_struct to a C++ CPP_grid_field_pt1 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad grid_field_pt1_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_grid_field_pt1 struct.
!-

subroutine grid_field_pt1_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine grid_field_pt1_to_c2 (C, z_e, z_b) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_e(*), z_b(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(grid_field_pt1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call grid_field_pt1_to_c2 (C, fvec2vec(F%e, 3), fvec2vec(F%b, 3))

end subroutine grid_field_pt1_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine grid_field_pt1_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_grid_field_pt1 structure to a Bmad grid_field_pt1_struct structure.
! This routine is called by grid_field_pt1_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the grid_field_pt1_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad grid_field_pt1_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine grid_field_pt1_to_f2 (Fp, z_e, z_b) bind(c)


implicit none

type(c_ptr), value :: Fp
type(grid_field_pt1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_e(*), z_b(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 1, NOT]
F%e = z_e(1:3)
!! f_side.to_f2_trans[complex, 1, NOT]
F%b = z_b(1:3)

end subroutine grid_field_pt1_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine grid_field_pt_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad grid_field_pt_struct to a C++ CPP_grid_field_pt structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad grid_field_pt_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_grid_field_pt struct.
!-

subroutine grid_field_pt_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine grid_field_pt_to_c2 (C, z_file, z_n_link, z_pt, n1_pt, n2_pt, n3_pt) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_file(*)
    integer(c_int) :: z_n_link
    type(c_ptr) :: z_pt(*)
    integer(c_int), value :: n1_pt, n2_pt, n3_pt
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(grid_field_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_pt(:)
integer(c_int) :: n1_pt
integer(c_int) :: n2_pt
integer(c_int) :: n3_pt

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 3, ALLOC]
if (allocated(F%pt)) then
  n1_pt = size(F%pt, 1); lb1 = lbound(F%pt, 1) - 1
  n2_pt = size(F%pt, 2); lb2 = lbound(F%pt, 2) - 1
  n3_pt = size(F%pt, 3); lb3 = lbound(F%pt, 3) - 1
  allocate (z_pt(n1_pt * n2_pt * n3_pt))
  do jd1 = 1, n1_pt; do jd2 = 1, n2_pt; do jd3 = 1, n3_pt
    z_pt(n3_pt*n2_pt*(jd1-1) + n3_pt*(jd2-1) + jd3) = c_loc(F%pt(jd1+lb1, jd2+lb2, jd3+lb3))
  enddo;  enddo; enddo
else
  n1_pt = 0; n2_pt = 0; n3_pt = 0
endif

!! f_side.to_c2_call
call grid_field_pt_to_c2 (C, trim(F%file) // c_null_char, F%n_link, z_pt, n1_pt, n2_pt, n3_pt)

end subroutine grid_field_pt_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine grid_field_pt_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_grid_field_pt structure to a Bmad grid_field_pt_struct structure.
! This routine is called by grid_field_pt_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the grid_field_pt_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad grid_field_pt_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine grid_field_pt_to_f2 (Fp, z_file, z_n_link, z_pt, n1_pt, n2_pt, n3_pt) bind(c)


implicit none

type(c_ptr), value :: Fp
type(grid_field_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_file(*)
integer(c_int) :: z_n_link
type(c_ptr) :: z_pt(*)
integer(c_int), value :: n1_pt, n2_pt, n3_pt

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[type, 3, ALLOC]
if (n1_pt == 0) then
  if (allocated(F%pt)) deallocate(F%pt)
else
  if (allocated(F%pt)) then
    if (n1_pt == 0 .or. any(shape(F%pt) /= [n1_pt, n2_pt, n3_pt])) deallocate(F%pt)
    if (any(lbound(F%pt) /= 1)) deallocate(F%pt)
  endif
  if (.not. allocated(F%pt)) allocate(F%pt(1:n1_pt+1-1, 1:n2_pt+1-1, 1:n3_pt+1-1))
  do jd1 = 1, n1_pt;  do jd2 = 1, n2_pt;  do jd3 = 1, n3_pt
    call grid_field_pt1_to_f (z_pt(n3_pt*n2_pt*(jd1-1) + n3_pt*(jd2-1) + jd3), c_loc(F%pt(jd1+1-1,jd2+1-1,jd3+1-1)))
  enddo;  enddo;  enddo
endif


end subroutine grid_field_pt_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine grid_field_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad grid_field_struct to a C++ CPP_grid_field structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad grid_field_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_grid_field struct.
!-

subroutine grid_field_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine grid_field_to_c2 (C, z_geometry, z_harmonic, z_phi0_fieldmap, z_field_scale, &
      z_field_type, z_master_parameter, z_ele_anchor_pt, z_interpolation_order, z_dr, z_r0, &
      z_curved_ref_frame, z_ptr, n_ptr) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_geometry, z_harmonic, z_field_type, z_master_parameter, z_ele_anchor_pt, z_interpolation_order
    real(c_double) :: z_phi0_fieldmap, z_field_scale, z_dr(*), z_r0(*)
    logical(c_bool) :: z_curved_ref_frame
    type(c_ptr), value :: z_ptr
    integer(c_int), value :: n_ptr
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(grid_field_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n_ptr

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 0, PTR]
n_ptr = 0
if (associated(F%ptr)) n_ptr = 1

!! f_side.to_c2_call
call grid_field_to_c2 (C, F%geometry, F%harmonic, F%phi0_fieldmap, F%field_scale, F%field_type, &
    F%master_parameter, F%ele_anchor_pt, F%interpolation_order, fvec2vec(F%dr, 3), &
    fvec2vec(F%r0, 3), c_logic(F%curved_ref_frame), c_loc(F%ptr), n_ptr)

end subroutine grid_field_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine grid_field_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_grid_field structure to a Bmad grid_field_struct structure.
! This routine is called by grid_field_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the grid_field_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad grid_field_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine grid_field_to_f2 (Fp, z_geometry, z_harmonic, z_phi0_fieldmap, z_field_scale, &
    z_field_type, z_master_parameter, z_ele_anchor_pt, z_interpolation_order, z_dr, z_r0, &
    z_curved_ref_frame, z_ptr, n_ptr) bind(c)


implicit none

type(c_ptr), value :: Fp
type(grid_field_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_geometry, z_harmonic, z_field_type, z_master_parameter, z_ele_anchor_pt, z_interpolation_order
real(c_double) :: z_phi0_fieldmap, z_field_scale, z_dr(*), z_r0(*)
logical(c_bool) :: z_curved_ref_frame
type(c_ptr), value :: z_ptr
type(grid_field_pt_struct), pointer :: f_ptr
integer(c_int), value :: n_ptr

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%geometry = z_geometry
!! f_side.to_f2_trans[integer, 0, NOT]
F%harmonic = z_harmonic
!! f_side.to_f2_trans[real, 0, NOT]
F%phi0_fieldmap = z_phi0_fieldmap
!! f_side.to_f2_trans[real, 0, NOT]
F%field_scale = z_field_scale
!! f_side.to_f2_trans[integer, 0, NOT]
F%field_type = z_field_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%master_parameter = z_master_parameter
!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[integer, 0, NOT]
F%interpolation_order = z_interpolation_order
!! f_side.to_f2_trans[real, 1, NOT]
F%dr = z_dr(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:3)
!! f_side.to_f2_trans[logical, 0, NOT]
F%curved_ref_frame = f_logic(z_curved_ref_frame)
!! f_side.to_f2_trans[type, 0, PTR]
if (n_ptr == 0) then
  if (associated(F%ptr)) deallocate(F%ptr)
else
  if (.not. associated(F%ptr)) allocate(F%ptr)
  call grid_field_pt_to_f (z_ptr, c_loc(F%ptr))
endif


end subroutine grid_field_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine floor_position_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad floor_position_struct to a C++ CPP_floor_position structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad floor_position_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_floor_position struct.
!-

subroutine floor_position_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine floor_position_to_c2 (C, z_r, z_w, z_theta, z_phi, z_psi) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_r(*), z_w(*), z_theta, z_phi, z_psi
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(floor_position_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call floor_position_to_c2 (C, fvec2vec(F%r, 3), mat2vec(F%w, 3*3), F%theta, F%phi, F%psi)

end subroutine floor_position_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine floor_position_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_floor_position structure to a Bmad floor_position_struct structure.
! This routine is called by floor_position_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the floor_position_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad floor_position_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine floor_position_to_f2 (Fp, z_r, z_w, z_theta, z_phi, z_psi) bind(c)


implicit none

type(c_ptr), value :: Fp
type(floor_position_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_r(*), z_w(*), z_theta, z_phi, z_psi

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%r = z_r(1:3)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_w, F%w)
!! f_side.to_f2_trans[real, 0, NOT]
F%theta = z_theta
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%psi = z_psi

end subroutine floor_position_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine high_energy_space_charge_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad high_energy_space_charge_struct to a C++ CPP_high_energy_space_charge structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad high_energy_space_charge_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_high_energy_space_charge struct.
!-

subroutine high_energy_space_charge_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine high_energy_space_charge_to_c2 (C, z_closed_orb, z_kick_const, z_sig_x, z_sig_y, &
      z_phi, z_sin_phi, z_cos_phi, z_sig_z) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_closed_orb
    real(c_double) :: z_kick_const, z_sig_x, z_sig_y, z_phi, z_sin_phi, z_cos_phi, z_sig_z
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(high_energy_space_charge_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call high_energy_space_charge_to_c2 (C, c_loc(F%closed_orb), F%kick_const, F%sig_x, F%sig_y, &
    F%phi, F%sin_phi, F%cos_phi, F%sig_z)

end subroutine high_energy_space_charge_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine high_energy_space_charge_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_high_energy_space_charge structure to a Bmad high_energy_space_charge_struct structure.
! This routine is called by high_energy_space_charge_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the high_energy_space_charge_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad high_energy_space_charge_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine high_energy_space_charge_to_f2 (Fp, z_closed_orb, z_kick_const, z_sig_x, z_sig_y, &
    z_phi, z_sin_phi, z_cos_phi, z_sig_z) bind(c)


implicit none

type(c_ptr), value :: Fp
type(high_energy_space_charge_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_closed_orb
real(c_double) :: z_kick_const, z_sig_x, z_sig_y, z_phi, z_sin_phi, z_cos_phi, z_sig_z

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_closed_orb, c_loc(F%closed_orb))
!! f_side.to_f2_trans[real, 0, NOT]
F%kick_const = z_kick_const
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_x = z_sig_x
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_y = z_sig_y
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%sin_phi = z_sin_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%cos_phi = z_cos_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_z = z_sig_z

end subroutine high_energy_space_charge_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine xy_disp_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad xy_disp_struct to a C++ CPP_xy_disp structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad xy_disp_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_xy_disp struct.
!-

subroutine xy_disp_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine xy_disp_to_c2 (C, z_eta, z_etap, z_deta_ds, z_sigma) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_eta, z_etap, z_deta_ds, z_sigma
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(xy_disp_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call xy_disp_to_c2 (C, F%eta, F%etap, F%deta_ds, F%sigma)

end subroutine xy_disp_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine xy_disp_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_xy_disp structure to a Bmad xy_disp_struct structure.
! This routine is called by xy_disp_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the xy_disp_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad xy_disp_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine xy_disp_to_f2 (Fp, z_eta, z_etap, z_deta_ds, z_sigma) bind(c)


implicit none

type(c_ptr), value :: Fp
type(xy_disp_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_eta, z_etap, z_deta_ds, z_sigma

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%eta = z_eta
!! f_side.to_f2_trans[real, 0, NOT]
F%etap = z_etap
!! f_side.to_f2_trans[real, 0, NOT]
F%deta_ds = z_deta_ds
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma = z_sigma

end subroutine xy_disp_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine twiss_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad twiss_struct to a C++ CPP_twiss structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad twiss_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_twiss struct.
!-

subroutine twiss_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine twiss_to_c2 (C, z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_deta_ds, &
      z_sigma, z_sigma_p, z_emit, z_norm_emit) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_deta_ds
    real(c_double) :: z_sigma, z_sigma_p, z_emit, z_norm_emit
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(twiss_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call twiss_to_c2 (C, F%beta, F%alpha, F%gamma, F%phi, F%eta, F%etap, F%deta_ds, F%sigma, &
    F%sigma_p, F%emit, F%norm_emit)

end subroutine twiss_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine twiss_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_twiss structure to a Bmad twiss_struct structure.
! This routine is called by twiss_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the twiss_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad twiss_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine twiss_to_f2 (Fp, z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_deta_ds, z_sigma, &
    z_sigma_p, z_emit, z_norm_emit) bind(c)


implicit none

type(c_ptr), value :: Fp
type(twiss_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_beta, z_alpha, z_gamma, z_phi, z_eta, z_etap, z_deta_ds
real(c_double) :: z_sigma, z_sigma_p, z_emit, z_norm_emit

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%beta = z_beta
!! f_side.to_f2_trans[real, 0, NOT]
F%alpha = z_alpha
!! f_side.to_f2_trans[real, 0, NOT]
F%gamma = z_gamma
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%eta = z_eta
!! f_side.to_f2_trans[real, 0, NOT]
F%etap = z_etap
!! f_side.to_f2_trans[real, 0, NOT]
F%deta_ds = z_deta_ds
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma = z_sigma
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma_p = z_sigma_p
!! f_side.to_f2_trans[real, 0, NOT]
F%emit = z_emit
!! f_side.to_f2_trans[real, 0, NOT]
F%norm_emit = z_norm_emit

end subroutine twiss_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode3_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad mode3_struct to a C++ CPP_mode3 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad mode3_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_mode3 struct.
!-

subroutine mode3_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine mode3_to_c2 (C, z_v, z_a, z_b, z_c, z_x, z_y) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_v(*)
    type(c_ptr), value :: z_a, z_b, z_c, z_x, z_y
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(mode3_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call mode3_to_c2 (C, mat2vec(F%v, 6*6), c_loc(F%a), c_loc(F%b), c_loc(F%c), c_loc(F%x), &
    c_loc(F%y))

end subroutine mode3_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode3_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_mode3 structure to a Bmad mode3_struct structure.
! This routine is called by mode3_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the mode3_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad mode3_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine mode3_to_f2 (Fp, z_v, z_a, z_b, z_c, z_x, z_y) bind(c)


implicit none

type(c_ptr), value :: Fp
type(mode3_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_v(*)
type(c_ptr), value :: z_a, z_b, z_c, z_x, z_y

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_v, F%v)
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_c, c_loc(F%c))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_x, c_loc(F%x))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_y, c_loc(F%y))

end subroutine mode3_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bookkeeping_state_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bookkeeping_state_struct to a C++ CPP_bookkeeping_state structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bookkeeping_state_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bookkeeping_state struct.
!-

subroutine bookkeeping_state_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bookkeeping_state_to_c2 (C, z_attributes, z_control, z_floor_position, &
      z_s_position, z_ref_energy, z_mat6, z_rad_int, z_ptc, z_has_misalign) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_attributes, z_control, z_floor_position, z_s_position, z_ref_energy, z_mat6, z_rad_int
    integer(c_int) :: z_ptc
    logical(c_bool) :: z_has_misalign
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bookkeeping_state_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bookkeeping_state_to_c2 (C, F%attributes, F%control, F%floor_position, F%s_position, &
    F%ref_energy, F%mat6, F%rad_int, F%ptc, c_logic(F%has_misalign))

end subroutine bookkeeping_state_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bookkeeping_state_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bookkeeping_state structure to a Bmad bookkeeping_state_struct structure.
! This routine is called by bookkeeping_state_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bookkeeping_state_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bookkeeping_state_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bookkeeping_state_to_f2 (Fp, z_attributes, z_control, z_floor_position, &
    z_s_position, z_ref_energy, z_mat6, z_rad_int, z_ptc, z_has_misalign) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bookkeeping_state_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_attributes, z_control, z_floor_position, z_s_position, z_ref_energy, z_mat6, z_rad_int
integer(c_int) :: z_ptc
logical(c_bool) :: z_has_misalign

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%attributes = z_attributes
!! f_side.to_f2_trans[integer, 0, NOT]
F%control = z_control
!! f_side.to_f2_trans[integer, 0, NOT]
F%floor_position = z_floor_position
!! f_side.to_f2_trans[integer, 0, NOT]
F%s_position = z_s_position
!! f_side.to_f2_trans[integer, 0, NOT]
F%ref_energy = z_ref_energy
!! f_side.to_f2_trans[integer, 0, NOT]
F%mat6 = z_mat6
!! f_side.to_f2_trans[integer, 0, NOT]
F%rad_int = z_rad_int
!! f_side.to_f2_trans[integer, 0, NOT]
F%ptc = z_ptc
!! f_side.to_f2_trans[logical, 0, NOT]
F%has_misalign = f_logic(z_has_misalign)

end subroutine bookkeeping_state_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_map_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_map_struct to a C++ CPP_rad_map structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_map_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_map struct.
!-

subroutine rad_map_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_map_to_c2 (C, z_ref_orb, z_damp_dmat, z_xfer_damp_vec, z_xfer_damp_mat, &
      z_stoc_mat) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_ref_orb(*), z_damp_dmat(*), z_xfer_damp_vec(*), z_xfer_damp_mat(*), z_stoc_mat(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call rad_map_to_c2 (C, fvec2vec(F%ref_orb, 6), mat2vec(F%damp_dmat, 6*6), &
    fvec2vec(F%xfer_damp_vec, 6), mat2vec(F%xfer_damp_mat, 6*6), mat2vec(F%stoc_mat, 6*6))

end subroutine rad_map_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_map_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_map structure to a Bmad rad_map_struct structure.
! This routine is called by rad_map_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_map_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_map_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_map_to_f2 (Fp, z_ref_orb, z_damp_dmat, z_xfer_damp_vec, z_xfer_damp_mat, &
    z_stoc_mat) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_ref_orb(*), z_damp_dmat(*), z_xfer_damp_vec(*), z_xfer_damp_mat(*), z_stoc_mat(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%ref_orb = z_ref_orb(1:6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_damp_dmat, F%damp_dmat)
!! f_side.to_f2_trans[real, 1, NOT]
F%xfer_damp_vec = z_xfer_damp_vec(1:6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_xfer_damp_mat, F%xfer_damp_mat)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_stoc_mat, F%stoc_mat)

end subroutine rad_map_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_map_ele_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_map_ele_struct to a C++ CPP_rad_map_ele structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_map_ele_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_map_ele struct.
!-

subroutine rad_map_ele_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_map_ele_to_c2 (C, z_rm0, z_rm1, z_stale) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_rm0, z_rm1
    logical(c_bool) :: z_stale
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_map_ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call rad_map_ele_to_c2 (C, c_loc(F%rm0), c_loc(F%rm1), c_logic(F%stale))

end subroutine rad_map_ele_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_map_ele_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_map_ele structure to a Bmad rad_map_ele_struct structure.
! This routine is called by rad_map_ele_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_map_ele_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_map_ele_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_map_ele_to_f2 (Fp, z_rm0, z_rm1, z_stale) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_map_ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_rm0, z_rm1
logical(c_bool) :: z_stale

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 0, NOT]
call rad_map_to_f(z_rm0, c_loc(F%rm0))
!! f_side.to_f2_trans[type, 0, NOT]
call rad_map_to_f(z_rm1, c_loc(F%rm1))
!! f_side.to_f2_trans[logical, 0, NOT]
F%stale = f_logic(z_stale)

end subroutine rad_map_ele_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine gen_grad1_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad gen_grad1_struct to a C++ CPP_gen_grad1 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad gen_grad1_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_gen_grad1 struct.
!-

subroutine gen_grad1_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine gen_grad1_to_c2 (C, z_m, z_sincos, z_n_deriv_max, z_deriv, n1_deriv, n2_deriv) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_m, z_sincos, z_n_deriv_max
    real(c_double) :: z_deriv(*)
    integer(c_int), value :: n1_deriv, n2_deriv
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(gen_grad1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n1_deriv
integer(c_int) :: n2_deriv

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[real, 2, ALLOC]
if (allocated(F%deriv)) then
  n1_deriv = size(F%deriv, 1)
  n2_deriv = size(F%deriv, 2)
else
  n1_deriv = 0; n2_deriv = 0
endif

!! f_side.to_c2_call
call gen_grad1_to_c2 (C, F%m, F%sincos, F%n_deriv_max, mat2vec(F%deriv, n1_deriv*n2_deriv), &
    n1_deriv, n2_deriv)

end subroutine gen_grad1_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine gen_grad1_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_gen_grad1 structure to a Bmad gen_grad1_struct structure.
! This routine is called by gen_grad1_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the gen_grad1_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad gen_grad1_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine gen_grad1_to_f2 (Fp, z_m, z_sincos, z_n_deriv_max, z_deriv, n1_deriv, n2_deriv) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(gen_grad1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_m, z_sincos, z_n_deriv_max
type(c_ptr), value :: z_deriv
real(c_double), pointer :: f_deriv(:)
integer(c_int), value :: n1_deriv, n2_deriv

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%m = z_m
!! f_side.to_f2_trans[integer, 0, NOT]
F%sincos = z_sincos
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_deriv_max = z_n_deriv_max
!! f_side.to_f2_trans[real, 2, ALLOC]
if (allocated(F%deriv)) then
  if (n1_deriv == 0 .or. any(shape(F%deriv) /= [n1_deriv, n2_deriv])) deallocate(F%deriv)
  if (any(lbound(F%deriv) /= 1)) deallocate(F%deriv)
endif
if (n1_deriv /= 0) then
  call c_f_pointer (z_deriv, f_deriv, [n1_deriv*n2_deriv])
  if (.not. allocated(F%deriv)) allocate(F%deriv(n1_deriv, n2_deriv))
  call vec2mat(f_deriv, F%deriv)
else
  if (allocated(F%deriv)) deallocate(F%deriv)
endif


end subroutine gen_grad1_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine gen_grad_map_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad gen_grad_map_struct to a C++ CPP_gen_grad_map structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad gen_grad_map_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_gen_grad_map struct.
!-

subroutine gen_grad_map_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine gen_grad_map_to_c2 (C, z_file, z_gg, n1_gg, z_ele_anchor_pt, z_field_type, z_iz0, &
      z_iz1, z_dz, z_r0, z_field_scale, z_master_parameter, z_curved_ref_frame) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_file(*)
    type(c_ptr) :: z_gg(*)
    integer(c_int), value :: n1_gg
    integer(c_int) :: z_ele_anchor_pt, z_field_type, z_iz0, z_iz1, z_master_parameter
    real(c_double) :: z_dz, z_r0(*), z_field_scale
    logical(c_bool) :: z_curved_ref_frame
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(gen_grad_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_gg(:)
integer(c_int) :: n1_gg

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_gg = 0
if (allocated(F%gg)) then
  n1_gg = size(F%gg); lb1 = lbound(F%gg, 1) - 1
  allocate (z_gg(n1_gg))
  do jd1 = 1, n1_gg
    z_gg(jd1) = c_loc(F%gg(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call gen_grad_map_to_c2 (C, trim(F%file) // c_null_char, z_gg, n1_gg, F%ele_anchor_pt, &
    F%field_type, F%iz0, F%iz1, F%dz, fvec2vec(F%r0, 3), F%field_scale, F%master_parameter, &
    c_logic(F%curved_ref_frame))

end subroutine gen_grad_map_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine gen_grad_map_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_gen_grad_map structure to a Bmad gen_grad_map_struct structure.
! This routine is called by gen_grad_map_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the gen_grad_map_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad gen_grad_map_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine gen_grad_map_to_f2 (Fp, z_file, z_gg, n1_gg, z_ele_anchor_pt, z_field_type, z_iz0, &
    z_iz1, z_dz, z_r0, z_field_scale, z_master_parameter, z_curved_ref_frame) bind(c)


implicit none

type(c_ptr), value :: Fp
type(gen_grad_map_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_file(*)
type(c_ptr) :: z_gg(*)
integer(c_int), value :: n1_gg
integer(c_int) :: z_ele_anchor_pt, z_field_type, z_iz0, z_iz1, z_master_parameter
real(c_double) :: z_dz, z_r0(*), z_field_scale
logical(c_bool) :: z_curved_ref_frame

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file, F%file)
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_gg == 0) then
  if (allocated(F%gg)) deallocate(F%gg)
else
  if (allocated(F%gg)) then
    if (n1_gg == 0 .or. any(shape(F%gg) /= [n1_gg])) deallocate(F%gg)
    if (any(lbound(F%gg) /= 1)) deallocate(F%gg)
  endif
  if (.not. allocated(F%gg)) allocate(F%gg(1:n1_gg+1-1))
  do jd1 = 1, n1_gg
    call gen_grad1_to_f (z_gg(jd1), c_loc(F%gg(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[integer, 0, NOT]
F%field_type = z_field_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%iz0 = z_iz0
!! f_side.to_f2_trans[integer, 0, NOT]
F%iz1 = z_iz1
!! f_side.to_f2_trans[real, 0, NOT]
F%dz = z_dz
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:3)
!! f_side.to_f2_trans[real, 0, NOT]
F%field_scale = z_field_scale
!! f_side.to_f2_trans[integer, 0, NOT]
F%master_parameter = z_master_parameter
!! f_side.to_f2_trans[logical, 0, NOT]
F%curved_ref_frame = f_logic(z_curved_ref_frame)

end subroutine gen_grad_map_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_segmented_pt_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad surface_segmented_pt_struct to a C++ CPP_surface_segmented_pt structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad surface_segmented_pt_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_surface_segmented_pt struct.
!-

subroutine surface_segmented_pt_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine surface_segmented_pt_to_c2 (C, z_x0, z_y0, z_z0, z_dz_dx, z_dz_dy) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_x0, z_y0, z_z0, z_dz_dx, z_dz_dy
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(surface_segmented_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call surface_segmented_pt_to_c2 (C, F%x0, F%y0, F%z0, F%dz_dx, F%dz_dy)

end subroutine surface_segmented_pt_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_segmented_pt_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_surface_segmented_pt structure to a Bmad surface_segmented_pt_struct structure.
! This routine is called by surface_segmented_pt_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the surface_segmented_pt_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad surface_segmented_pt_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine surface_segmented_pt_to_f2 (Fp, z_x0, z_y0, z_z0, z_dz_dx, z_dz_dy) bind(c)


implicit none

type(c_ptr), value :: Fp
type(surface_segmented_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_x0, z_y0, z_z0, z_dz_dx, z_dz_dy

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0
!! f_side.to_f2_trans[real, 0, NOT]
F%z0 = z_z0
!! f_side.to_f2_trans[real, 0, NOT]
F%dz_dx = z_dz_dx
!! f_side.to_f2_trans[real, 0, NOT]
F%dz_dy = z_dz_dy

end subroutine surface_segmented_pt_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_segmented_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad surface_segmented_struct to a C++ CPP_surface_segmented structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad surface_segmented_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_surface_segmented struct.
!-

subroutine surface_segmented_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine surface_segmented_to_c2 (C, z_active, z_dr, z_r0, z_pt, n1_pt, n2_pt) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_active
    real(c_double) :: z_dr(*), z_r0(*)
    type(c_ptr) :: z_pt(*)
    integer(c_int), value :: n1_pt, n2_pt
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(surface_segmented_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_pt(:)
integer(c_int) :: n1_pt
integer(c_int) :: n2_pt

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 2, ALLOC]
if (allocated(F%pt)) then
  n1_pt = size(F%pt, 1); lb1 = lbound(F%pt, 1) - 1
  n2_pt = size(F%pt, 2); lb2 = lbound(F%pt, 2) - 1
  allocate (z_pt(n1_pt * n2_pt))
  do jd1 = 1, n1_pt; do jd2 = 1, n2_pt
    z_pt(n2_pt*(jd1-1) + jd2) = c_loc(F%pt(jd1+lb1, jd2+lb2))
  enddo;  enddo
else
  n1_pt = 0; n2_pt = 0
endif

!! f_side.to_c2_call
call surface_segmented_to_c2 (C, c_logic(F%active), fvec2vec(F%dr, 2), fvec2vec(F%r0, 2), z_pt, &
    n1_pt, n2_pt)

end subroutine surface_segmented_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_segmented_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_surface_segmented structure to a Bmad surface_segmented_struct structure.
! This routine is called by surface_segmented_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the surface_segmented_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad surface_segmented_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine surface_segmented_to_f2 (Fp, z_active, z_dr, z_r0, z_pt, n1_pt, n2_pt) bind(c)


implicit none

type(c_ptr), value :: Fp
type(surface_segmented_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_active
real(c_double) :: z_dr(*), z_r0(*)
type(c_ptr) :: z_pt(*)
integer(c_int), value :: n1_pt, n2_pt

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[logical, 0, NOT]
F%active = f_logic(z_active)
!! f_side.to_f2_trans[real, 1, NOT]
F%dr = z_dr(1:2)
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:2)
!! f_side.to_f2_trans[type, 2, ALLOC]
if (n1_pt == 0) then
  if (allocated(F%pt)) deallocate(F%pt)
else
  if (allocated(F%pt)) then
    if (n1_pt == 0 .or. any(shape(F%pt) /= [n1_pt, n2_pt])) deallocate(F%pt)
    if (any(lbound(F%pt) /= 1)) deallocate(F%pt)
  endif
  if (.not. allocated(F%pt)) allocate(F%pt(1:n1_pt+1-1, 1:n2_pt+1-1))
  do jd1 = 1, n1_pt
  do jd2 = 1, n2_pt
    call surface_segmented_pt_to_f (z_pt(n2_pt*(jd1-1) + jd2), c_loc(F%pt(jd1+1-1,jd2+1-1)))
  enddo
  enddo
endif


end subroutine surface_segmented_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_h_misalign_pt_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad surface_h_misalign_pt_struct to a C++ CPP_surface_h_misalign_pt structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad surface_h_misalign_pt_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_surface_h_misalign_pt struct.
!-

subroutine surface_h_misalign_pt_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine surface_h_misalign_pt_to_c2 (C, z_x0, z_y0, z_rot_y, z_rot_t, z_rot_y_rms, &
      z_rot_t_rms) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_x0, z_y0, z_rot_y, z_rot_t, z_rot_y_rms, z_rot_t_rms
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(surface_h_misalign_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call surface_h_misalign_pt_to_c2 (C, F%x0, F%y0, F%rot_y, F%rot_t, F%rot_y_rms, F%rot_t_rms)

end subroutine surface_h_misalign_pt_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_h_misalign_pt_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_surface_h_misalign_pt structure to a Bmad surface_h_misalign_pt_struct structure.
! This routine is called by surface_h_misalign_pt_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the surface_h_misalign_pt_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad surface_h_misalign_pt_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine surface_h_misalign_pt_to_f2 (Fp, z_x0, z_y0, z_rot_y, z_rot_t, z_rot_y_rms, &
    z_rot_t_rms) bind(c)


implicit none

type(c_ptr), value :: Fp
type(surface_h_misalign_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_x0, z_y0, z_rot_y, z_rot_t, z_rot_y_rms, z_rot_t_rms

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0
!! f_side.to_f2_trans[real, 0, NOT]
F%rot_y = z_rot_y
!! f_side.to_f2_trans[real, 0, NOT]
F%rot_t = z_rot_t
!! f_side.to_f2_trans[real, 0, NOT]
F%rot_y_rms = z_rot_y_rms
!! f_side.to_f2_trans[real, 0, NOT]
F%rot_t_rms = z_rot_t_rms

end subroutine surface_h_misalign_pt_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_h_misalign_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad surface_h_misalign_struct to a C++ CPP_surface_h_misalign structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad surface_h_misalign_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_surface_h_misalign struct.
!-

subroutine surface_h_misalign_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine surface_h_misalign_to_c2 (C, z_active, z_dr, z_r0, z_pt, n1_pt, n2_pt) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_active
    real(c_double) :: z_dr(*), z_r0(*)
    type(c_ptr) :: z_pt(*)
    integer(c_int), value :: n1_pt, n2_pt
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(surface_h_misalign_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_pt(:)
integer(c_int) :: n1_pt
integer(c_int) :: n2_pt

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 2, ALLOC]
if (allocated(F%pt)) then
  n1_pt = size(F%pt, 1); lb1 = lbound(F%pt, 1) - 1
  n2_pt = size(F%pt, 2); lb2 = lbound(F%pt, 2) - 1
  allocate (z_pt(n1_pt * n2_pt))
  do jd1 = 1, n1_pt; do jd2 = 1, n2_pt
    z_pt(n2_pt*(jd1-1) + jd2) = c_loc(F%pt(jd1+lb1, jd2+lb2))
  enddo;  enddo
else
  n1_pt = 0; n2_pt = 0
endif

!! f_side.to_c2_call
call surface_h_misalign_to_c2 (C, c_logic(F%active), fvec2vec(F%dr, 2), fvec2vec(F%r0, 2), &
    z_pt, n1_pt, n2_pt)

end subroutine surface_h_misalign_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_h_misalign_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_surface_h_misalign structure to a Bmad surface_h_misalign_struct structure.
! This routine is called by surface_h_misalign_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the surface_h_misalign_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad surface_h_misalign_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine surface_h_misalign_to_f2 (Fp, z_active, z_dr, z_r0, z_pt, n1_pt, n2_pt) bind(c)


implicit none

type(c_ptr), value :: Fp
type(surface_h_misalign_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_active
real(c_double) :: z_dr(*), z_r0(*)
type(c_ptr) :: z_pt(*)
integer(c_int), value :: n1_pt, n2_pt

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[logical, 0, NOT]
F%active = f_logic(z_active)
!! f_side.to_f2_trans[real, 1, NOT]
F%dr = z_dr(1:2)
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:2)
!! f_side.to_f2_trans[type, 2, ALLOC]
if (n1_pt == 0) then
  if (allocated(F%pt)) deallocate(F%pt)
else
  if (allocated(F%pt)) then
    if (n1_pt == 0 .or. any(shape(F%pt) /= [n1_pt, n2_pt])) deallocate(F%pt)
    if (any(lbound(F%pt) /= 1)) deallocate(F%pt)
  endif
  if (.not. allocated(F%pt)) allocate(F%pt(1:n1_pt+1-1, 1:n2_pt+1-1))
  do jd1 = 1, n1_pt
  do jd2 = 1, n2_pt
    call surface_h_misalign_pt_to_f (z_pt(n2_pt*(jd1-1) + jd2), c_loc(F%pt(jd1+1-1,jd2+1-1)))
  enddo
  enddo
endif


end subroutine surface_h_misalign_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_displacement_pt_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad surface_displacement_pt_struct to a C++ CPP_surface_displacement_pt structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad surface_displacement_pt_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_surface_displacement_pt struct.
!-

subroutine surface_displacement_pt_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine surface_displacement_pt_to_c2 (C, z_x0, z_y0, z_z0, z_dz_dx, z_dz_dy, z_d2z_dxdy) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_x0, z_y0, z_z0, z_dz_dx, z_dz_dy, z_d2z_dxdy
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(surface_displacement_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call surface_displacement_pt_to_c2 (C, F%x0, F%y0, F%z0, F%dz_dx, F%dz_dy, F%d2z_dxdy)

end subroutine surface_displacement_pt_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_displacement_pt_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_surface_displacement_pt structure to a Bmad surface_displacement_pt_struct structure.
! This routine is called by surface_displacement_pt_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the surface_displacement_pt_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad surface_displacement_pt_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine surface_displacement_pt_to_f2 (Fp, z_x0, z_y0, z_z0, z_dz_dx, z_dz_dy, z_d2z_dxdy) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(surface_displacement_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_x0, z_y0, z_z0, z_dz_dx, z_dz_dy, z_d2z_dxdy

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0
!! f_side.to_f2_trans[real, 0, NOT]
F%z0 = z_z0
!! f_side.to_f2_trans[real, 0, NOT]
F%dz_dx = z_dz_dx
!! f_side.to_f2_trans[real, 0, NOT]
F%dz_dy = z_dz_dy
!! f_side.to_f2_trans[real, 0, NOT]
F%d2z_dxdy = z_d2z_dxdy

end subroutine surface_displacement_pt_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_displacement_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad surface_displacement_struct to a C++ CPP_surface_displacement structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad surface_displacement_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_surface_displacement struct.
!-

subroutine surface_displacement_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine surface_displacement_to_c2 (C, z_active, z_dr, z_r0, z_pt, n1_pt, n2_pt) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_active
    real(c_double) :: z_dr(*), z_r0(*)
    type(c_ptr) :: z_pt(*)
    integer(c_int), value :: n1_pt, n2_pt
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(surface_displacement_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_pt(:)
integer(c_int) :: n1_pt
integer(c_int) :: n2_pt

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 2, ALLOC]
if (allocated(F%pt)) then
  n1_pt = size(F%pt, 1); lb1 = lbound(F%pt, 1) - 1
  n2_pt = size(F%pt, 2); lb2 = lbound(F%pt, 2) - 1
  allocate (z_pt(n1_pt * n2_pt))
  do jd1 = 1, n1_pt; do jd2 = 1, n2_pt
    z_pt(n2_pt*(jd1-1) + jd2) = c_loc(F%pt(jd1+lb1, jd2+lb2))
  enddo;  enddo
else
  n1_pt = 0; n2_pt = 0
endif

!! f_side.to_c2_call
call surface_displacement_to_c2 (C, c_logic(F%active), fvec2vec(F%dr, 2), fvec2vec(F%r0, 2), &
    z_pt, n1_pt, n2_pt)

end subroutine surface_displacement_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_displacement_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_surface_displacement structure to a Bmad surface_displacement_struct structure.
! This routine is called by surface_displacement_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the surface_displacement_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad surface_displacement_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine surface_displacement_to_f2 (Fp, z_active, z_dr, z_r0, z_pt, n1_pt, n2_pt) bind(c)


implicit none

type(c_ptr), value :: Fp
type(surface_displacement_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_active
real(c_double) :: z_dr(*), z_r0(*)
type(c_ptr) :: z_pt(*)
integer(c_int), value :: n1_pt, n2_pt

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[logical, 0, NOT]
F%active = f_logic(z_active)
!! f_side.to_f2_trans[real, 1, NOT]
F%dr = z_dr(1:2)
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:2)
!! f_side.to_f2_trans[type, 2, ALLOC]
if (n1_pt == 0) then
  if (allocated(F%pt)) deallocate(F%pt)
else
  if (allocated(F%pt)) then
    if (n1_pt == 0 .or. any(shape(F%pt) /= [n1_pt, n2_pt])) deallocate(F%pt)
    if (any(lbound(F%pt) /= 1)) deallocate(F%pt)
  endif
  if (.not. allocated(F%pt)) allocate(F%pt(1:n1_pt+1-1, 1:n2_pt+1-1))
  do jd1 = 1, n1_pt
  do jd2 = 1, n2_pt
    call surface_displacement_pt_to_f (z_pt(n2_pt*(jd1-1) + jd2), c_loc(F%pt(jd1+1-1,jd2+1-1)))
  enddo
  enddo
endif


end subroutine surface_displacement_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine target_point_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad target_point_struct to a C++ CPP_target_point structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad target_point_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_target_point struct.
!-

subroutine target_point_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine target_point_to_c2 (C, z_r) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_r(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(target_point_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call target_point_to_c2 (C, fvec2vec(F%r, 3))

end subroutine target_point_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine target_point_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_target_point structure to a Bmad target_point_struct structure.
! This routine is called by target_point_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the target_point_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad target_point_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine target_point_to_f2 (Fp, z_r) bind(c)


implicit none

type(c_ptr), value :: Fp
type(target_point_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_r(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%r = z_r(1:3)

end subroutine target_point_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_curvature_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad surface_curvature_struct to a C++ CPP_surface_curvature structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad surface_curvature_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_surface_curvature struct.
!-

subroutine surface_curvature_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine surface_curvature_to_c2 (C, z_xy, z_spherical, z_elliptical, z_has_curvature) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_xy(*), z_spherical, z_elliptical(*)
    logical(c_bool) :: z_has_curvature
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(surface_curvature_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call surface_curvature_to_c2 (C, mat2vec(F%xy, 7*7), F%spherical, fvec2vec(F%elliptical, 3), &
    c_logic(F%has_curvature))

end subroutine surface_curvature_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine surface_curvature_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_surface_curvature structure to a Bmad surface_curvature_struct structure.
! This routine is called by surface_curvature_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the surface_curvature_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad surface_curvature_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine surface_curvature_to_f2 (Fp, z_xy, z_spherical, z_elliptical, z_has_curvature) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(surface_curvature_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_xy(*), z_spherical, z_elliptical(*)
logical(c_bool) :: z_has_curvature

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_xy, F%xy)
!! f_side.to_f2_trans[real, 0, NOT]
F%spherical = z_spherical
!! f_side.to_f2_trans[real, 1, NOT]
F%elliptical = z_elliptical(1:3)
!! f_side.to_f2_trans[logical, 0, NOT]
F%has_curvature = f_logic(z_has_curvature)

end subroutine surface_curvature_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_target_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_target_struct to a C++ CPP_photon_target structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_target_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_target struct.
!-

subroutine photon_target_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_target_to_c2 (C, z_type, z_n_corner, z_ele_loc, z_corner, z_center) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_type, z_n_corner
    type(c_ptr), value :: z_ele_loc, z_center
    type(c_ptr) :: z_corner(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_target_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr) :: z_corner(8)

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%corner,1); lb1 = lbound(F%corner,1) - 1
  z_corner(jd1) = c_loc(F%corner(jd1+lb1))
enddo

!! f_side.to_c2_call
call photon_target_to_c2 (C, F%type, F%n_corner, c_loc(F%ele_loc), z_corner, c_loc(F%center))

end subroutine photon_target_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_target_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_target structure to a Bmad photon_target_struct structure.
! This routine is called by photon_target_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_target_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_target_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_target_to_f2 (Fp, z_type, z_n_corner, z_ele_loc, z_corner, z_center) bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_target_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_type, z_n_corner
type(c_ptr), value :: z_ele_loc, z_center
type(c_ptr) :: z_corner(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_corner = z_n_corner
!! f_side.to_f2_trans[type, 0, NOT]
call lat_ele_loc_to_f(z_ele_loc, c_loc(F%ele_loc))
!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%corner,1); lb1 = lbound(F%corner,1) - 1
  call target_point_to_f(z_corner(jd1), c_loc(F%corner(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 0, NOT]
call target_point_to_f(z_center, c_loc(F%center))

end subroutine photon_target_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_material_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_material_struct to a C++ CPP_photon_material structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_material_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_material struct.
!-

subroutine photon_material_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_material_to_c2 (C, z_f0_m1, z_f0_m2, z_f_0, z_f_h, z_f_hbar, z_f_hkl, &
      z_h_norm, z_l_ref) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_f0_m1, z_f0_m2, z_f_0, z_f_h, z_f_hbar, z_f_hkl
    real(c_double) :: z_h_norm(*), z_l_ref(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_material_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call photon_material_to_c2 (C, F%f0_m1, F%f0_m2, F%f_0, F%f_h, F%f_hbar, F%f_hkl, &
    fvec2vec(F%h_norm, 3), fvec2vec(F%l_ref, 3))

end subroutine photon_material_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_material_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_material structure to a Bmad photon_material_struct structure.
! This routine is called by photon_material_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_material_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_material_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_material_to_f2 (Fp, z_f0_m1, z_f0_m2, z_f_0, z_f_h, z_f_hbar, z_f_hkl, &
    z_h_norm, z_l_ref) bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_material_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_f0_m1, z_f0_m2, z_f_0, z_f_h, z_f_hbar, z_f_hkl
real(c_double) :: z_h_norm(*), z_l_ref(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 0, NOT]
F%f0_m1 = z_f0_m1
!! f_side.to_f2_trans[complex, 0, NOT]
F%f0_m2 = z_f0_m2
!! f_side.to_f2_trans[complex, 0, NOT]
F%f_0 = z_f_0
!! f_side.to_f2_trans[complex, 0, NOT]
F%f_h = z_f_h
!! f_side.to_f2_trans[complex, 0, NOT]
F%f_hbar = z_f_hbar
!! f_side.to_f2_trans[complex, 0, NOT]
F%f_hkl = z_f_hkl
!! f_side.to_f2_trans[real, 1, NOT]
F%h_norm = z_h_norm(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%l_ref = z_l_ref(1:3)

end subroutine photon_material_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine pixel_pt_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad pixel_pt_struct to a C++ CPP_pixel_pt structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad pixel_pt_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_pixel_pt struct.
!-

subroutine pixel_pt_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine pixel_pt_to_c2 (C, z_n_photon, z_e_x, z_e_y, z_intensity_x, z_intensity_y, &
      z_intensity, z_orbit, z_orbit_rms, z_init_orbit, z_init_orbit_rms) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_long) :: z_n_photon
    complex(c_double_complex) :: z_e_x, z_e_y
    real(c_double) :: z_intensity_x, z_intensity_y, z_intensity, z_orbit(*), z_orbit_rms(*), z_init_orbit(*), z_init_orbit_rms(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(pixel_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call pixel_pt_to_c2 (C, F%n_photon, F%e_x, F%e_y, F%intensity_x, F%intensity_y, F%intensity, &
    fvec2vec(F%orbit, 6), fvec2vec(F%orbit_rms, 6), fvec2vec(F%init_orbit, 6), &
    fvec2vec(F%init_orbit_rms, 6))

end subroutine pixel_pt_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine pixel_pt_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_pixel_pt structure to a Bmad pixel_pt_struct structure.
! This routine is called by pixel_pt_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the pixel_pt_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad pixel_pt_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine pixel_pt_to_f2 (Fp, z_n_photon, z_e_x, z_e_y, z_intensity_x, z_intensity_y, &
    z_intensity, z_orbit, z_orbit_rms, z_init_orbit, z_init_orbit_rms) bind(c)


implicit none

type(c_ptr), value :: Fp
type(pixel_pt_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_long) :: z_n_photon
complex(c_double_complex) :: z_e_x, z_e_y
real(c_double) :: z_intensity_x, z_intensity_y, z_intensity, z_orbit(*), z_orbit_rms(*), z_init_orbit(*), z_init_orbit_rms(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer8, 0, NOT]
F%n_photon = z_n_photon
!! f_side.to_f2_trans[complex, 0, NOT]
F%e_x = z_e_x
!! f_side.to_f2_trans[complex, 0, NOT]
F%e_y = z_e_y
!! f_side.to_f2_trans[real, 0, NOT]
F%intensity_x = z_intensity_x
!! f_side.to_f2_trans[real, 0, NOT]
F%intensity_y = z_intensity_y
!! f_side.to_f2_trans[real, 0, NOT]
F%intensity = z_intensity
!! f_side.to_f2_trans[real, 1, NOT]
F%orbit = z_orbit(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%orbit_rms = z_orbit_rms(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%init_orbit = z_init_orbit(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%init_orbit_rms = z_init_orbit_rms(1:6)

end subroutine pixel_pt_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine pixel_detec_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad pixel_detec_struct to a C++ CPP_pixel_detec structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad pixel_detec_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_pixel_detec struct.
!-

subroutine pixel_detec_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine pixel_detec_to_c2 (C, z_dr, z_r0, z_n_track_tot, z_n_hit_detec, z_n_hit_pixel, &
      z_pt, n1_pt, n2_pt) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_dr(*), z_r0(*)
    integer(c_long) :: z_n_track_tot, z_n_hit_detec, z_n_hit_pixel
    type(c_ptr) :: z_pt(*)
    integer(c_int), value :: n1_pt, n2_pt
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(pixel_detec_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_pt(:)
integer(c_int) :: n1_pt
integer(c_int) :: n2_pt

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 2, ALLOC]
if (allocated(F%pt)) then
  n1_pt = size(F%pt, 1); lb1 = lbound(F%pt, 1) - 1
  n2_pt = size(F%pt, 2); lb2 = lbound(F%pt, 2) - 1
  allocate (z_pt(n1_pt * n2_pt))
  do jd1 = 1, n1_pt; do jd2 = 1, n2_pt
    z_pt(n2_pt*(jd1-1) + jd2) = c_loc(F%pt(jd1+lb1, jd2+lb2))
  enddo;  enddo
else
  n1_pt = 0; n2_pt = 0
endif

!! f_side.to_c2_call
call pixel_detec_to_c2 (C, fvec2vec(F%dr, 2), fvec2vec(F%r0, 2), F%n_track_tot, F%n_hit_detec, &
    F%n_hit_pixel, z_pt, n1_pt, n2_pt)

end subroutine pixel_detec_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine pixel_detec_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_pixel_detec structure to a Bmad pixel_detec_struct structure.
! This routine is called by pixel_detec_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the pixel_detec_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad pixel_detec_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine pixel_detec_to_f2 (Fp, z_dr, z_r0, z_n_track_tot, z_n_hit_detec, z_n_hit_pixel, &
    z_pt, n1_pt, n2_pt) bind(c)


implicit none

type(c_ptr), value :: Fp
type(pixel_detec_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_dr(*), z_r0(*)
integer(c_long) :: z_n_track_tot, z_n_hit_detec, z_n_hit_pixel
type(c_ptr) :: z_pt(*)
integer(c_int), value :: n1_pt, n2_pt

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%dr = z_dr(1:2)
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:2)
!! f_side.to_f2_trans[integer8, 0, NOT]
F%n_track_tot = z_n_track_tot
!! f_side.to_f2_trans[integer8, 0, NOT]
F%n_hit_detec = z_n_hit_detec
!! f_side.to_f2_trans[integer8, 0, NOT]
F%n_hit_pixel = z_n_hit_pixel
!! f_side.to_f2_trans[type, 2, ALLOC]
if (n1_pt == 0) then
  if (allocated(F%pt)) deallocate(F%pt)
else
  if (allocated(F%pt)) then
    if (n1_pt == 0 .or. any(shape(F%pt) /= [n1_pt, n2_pt])) deallocate(F%pt)
    if (any(lbound(F%pt) /= 1)) deallocate(F%pt)
  endif
  if (.not. allocated(F%pt)) allocate(F%pt(1:n1_pt+1-1, 1:n2_pt+1-1))
  do jd1 = 1, n1_pt
  do jd2 = 1, n2_pt
    call pixel_pt_to_f (z_pt(n2_pt*(jd1-1) + jd2), c_loc(F%pt(jd1+1-1,jd2+1-1)))
  enddo
  enddo
endif


end subroutine pixel_detec_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_element_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad photon_element_struct to a C++ CPP_photon_element structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad photon_element_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_photon_element struct.
!-

subroutine photon_element_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine photon_element_to_c2 (C, z_curvature, z_target, z_material, z_segmented, &
      z_h_misalign, z_displacement, z_pixel, z_reflectivity_table_type, &
      z_reflectivity_table_sigma, z_reflectivity_table_pi, z_init_energy_prob, &
      n1_init_energy_prob, z_integrated_init_energy_prob, n1_integrated_init_energy_prob) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_curvature, z_target, z_material, z_segmented, z_h_misalign, z_displacement, z_pixel
    type(c_ptr), value :: z_reflectivity_table_sigma, z_reflectivity_table_pi
    integer(c_int) :: z_reflectivity_table_type
    type(c_ptr) :: z_init_energy_prob(*)
    integer(c_int), value :: n1_init_energy_prob, n1_integrated_init_energy_prob
    real(c_double) :: z_integrated_init_energy_prob(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(photon_element_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_init_energy_prob(:)
integer(c_int) :: n1_init_energy_prob
integer(c_int) :: n1_integrated_init_energy_prob

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_init_energy_prob = 0
if (allocated(F%init_energy_prob)) then
  n1_init_energy_prob = size(F%init_energy_prob); lb1 = lbound(F%init_energy_prob, 1) - 1
  allocate (z_init_energy_prob(n1_init_energy_prob))
  do jd1 = 1, n1_init_energy_prob
    z_init_energy_prob(jd1) = c_loc(F%init_energy_prob(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[real, 1, ALLOC]
n1_integrated_init_energy_prob = 0
if (allocated(F%integrated_init_energy_prob)) then
  n1_integrated_init_energy_prob = size(F%integrated_init_energy_prob, 1)
endif

!! f_side.to_c2_call
call photon_element_to_c2 (C, c_loc(F%curvature), c_loc(F%target), c_loc(F%material), &
    c_loc(F%segmented), c_loc(F%h_misalign), c_loc(F%displacement), c_loc(F%pixel), &
    F%reflectivity_table_type, c_loc(F%reflectivity_table_sigma), &
    c_loc(F%reflectivity_table_pi), z_init_energy_prob, n1_init_energy_prob, &
    fvec2vec(F%integrated_init_energy_prob, n1_integrated_init_energy_prob), &
    n1_integrated_init_energy_prob)

end subroutine photon_element_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine photon_element_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_photon_element structure to a Bmad photon_element_struct structure.
! This routine is called by photon_element_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the photon_element_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad photon_element_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine photon_element_to_f2 (Fp, z_curvature, z_target, z_material, z_segmented, &
    z_h_misalign, z_displacement, z_pixel, z_reflectivity_table_type, &
    z_reflectivity_table_sigma, z_reflectivity_table_pi, z_init_energy_prob, &
    n1_init_energy_prob, z_integrated_init_energy_prob, n1_integrated_init_energy_prob) bind(c)


implicit none

type(c_ptr), value :: Fp
type(photon_element_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_curvature, z_target, z_material, z_segmented, z_h_misalign, z_displacement, z_pixel
type(c_ptr), value :: z_reflectivity_table_sigma, z_reflectivity_table_pi, z_integrated_init_energy_prob
integer(c_int) :: z_reflectivity_table_type
type(c_ptr) :: z_init_energy_prob(*)
integer(c_int), value :: n1_init_energy_prob, n1_integrated_init_energy_prob
real(c_double), pointer :: f_integrated_init_energy_prob(:)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 0, NOT]
call surface_curvature_to_f(z_curvature, c_loc(F%curvature))
!! f_side.to_f2_trans[type, 0, NOT]
call photon_target_to_f(z_target, c_loc(F%target))
!! f_side.to_f2_trans[type, 0, NOT]
call photon_material_to_f(z_material, c_loc(F%material))
!! f_side.to_f2_trans[type, 0, NOT]
call surface_segmented_to_f(z_segmented, c_loc(F%segmented))
!! f_side.to_f2_trans[type, 0, NOT]
call surface_h_misalign_to_f(z_h_misalign, c_loc(F%h_misalign))
!! f_side.to_f2_trans[type, 0, NOT]
call surface_displacement_to_f(z_displacement, c_loc(F%displacement))
!! f_side.to_f2_trans[type, 0, NOT]
call pixel_detec_to_f(z_pixel, c_loc(F%pixel))
!! f_side.to_f2_trans[integer, 0, NOT]
F%reflectivity_table_type = z_reflectivity_table_type
!! f_side.to_f2_trans[type, 0, NOT]
call photon_reflect_table_to_f(z_reflectivity_table_sigma, c_loc(F%reflectivity_table_sigma))
!! f_side.to_f2_trans[type, 0, NOT]
call photon_reflect_table_to_f(z_reflectivity_table_pi, c_loc(F%reflectivity_table_pi))
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_init_energy_prob == 0) then
  if (allocated(F%init_energy_prob)) deallocate(F%init_energy_prob)
else
  if (allocated(F%init_energy_prob)) then
    if (n1_init_energy_prob == 0 .or. any(shape(F%init_energy_prob) /= [n1_init_energy_prob])) deallocate(F%init_energy_prob)
    if (any(lbound(F%init_energy_prob) /= 1)) deallocate(F%init_energy_prob)
  endif
  if (.not. allocated(F%init_energy_prob)) allocate(F%init_energy_prob(1:n1_init_energy_prob+1-1))
  do jd1 = 1, n1_init_energy_prob
    call spline_to_f (z_init_energy_prob(jd1), c_loc(F%init_energy_prob(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%integrated_init_energy_prob)) then
  if (n1_integrated_init_energy_prob == 0 .or. any(shape(F%integrated_init_energy_prob) /= [n1_integrated_init_energy_prob])) deallocate(F%integrated_init_energy_prob)
  if (any(lbound(F%integrated_init_energy_prob) /= 1)) deallocate(F%integrated_init_energy_prob)
endif
if (n1_integrated_init_energy_prob /= 0) then
  call c_f_pointer (z_integrated_init_energy_prob, f_integrated_init_energy_prob, [n1_integrated_init_energy_prob])
  if (.not. allocated(F%integrated_init_energy_prob)) allocate(F%integrated_init_energy_prob(n1_integrated_init_energy_prob))
  F%integrated_init_energy_prob = f_integrated_init_energy_prob(1:n1_integrated_init_energy_prob)
else
  if (allocated(F%integrated_init_energy_prob)) deallocate(F%integrated_init_energy_prob)
endif


end subroutine photon_element_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_vertex_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wall3d_vertex_struct to a C++ CPP_wall3d_vertex structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wall3d_vertex_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wall3d_vertex struct.
!-

subroutine wall3d_vertex_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wall3d_vertex_to_c2 (C, z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0, &
      z_y0, z_type) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0
    real(c_double) :: z_y0
    integer(c_int) :: z_type
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wall3d_vertex_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call wall3d_vertex_to_c2 (C, F%x, F%y, F%radius_x, F%radius_y, F%tilt, F%angle, F%x0, F%y0, &
    F%type)

end subroutine wall3d_vertex_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_vertex_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wall3d_vertex structure to a Bmad wall3d_vertex_struct structure.
! This routine is called by wall3d_vertex_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wall3d_vertex_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wall3d_vertex_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wall3d_vertex_to_f2 (Fp, z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0, &
    z_y0, z_type) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wall3d_vertex_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_x, z_y, z_radius_x, z_radius_y, z_tilt, z_angle, z_x0
real(c_double) :: z_y0
integer(c_int) :: z_type

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%x = z_x
!! f_side.to_f2_trans[real, 0, NOT]
F%y = z_y
!! f_side.to_f2_trans[real, 0, NOT]
F%radius_x = z_radius_x
!! f_side.to_f2_trans[real, 0, NOT]
F%radius_y = z_radius_y
!! f_side.to_f2_trans[real, 0, NOT]
F%tilt = z_tilt
!! f_side.to_f2_trans[real, 0, NOT]
F%angle = z_angle
!! f_side.to_f2_trans[real, 0, NOT]
F%x0 = z_x0
!! f_side.to_f2_trans[real, 0, NOT]
F%y0 = z_y0
!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type

end subroutine wall3d_vertex_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_section_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wall3d_section_struct to a C++ CPP_wall3d_section structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wall3d_section_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wall3d_section struct.
!-

subroutine wall3d_section_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wall3d_section_to_c2 (C, z_name, z_material, z_v, n1_v, z_surface, n_surface, &
      z_type, z_n_vertex_input, z_ix_ele, z_ix_branch, z_vertices_state, z_patch_in_region, &
      z_thickness, z_s, z_r0, z_dx0_ds, z_dy0_ds, z_x0_coef, z_y0_coef, z_dr_ds, z_p1_coef, &
      z_p2_coef) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_name(*), z_material(*)
    type(c_ptr) :: z_v(*)
    integer(c_int), value :: n1_v, n_surface
    type(c_ptr), value :: z_surface
    integer(c_int) :: z_type, z_n_vertex_input, z_ix_ele, z_ix_branch, z_vertices_state
    logical(c_bool) :: z_patch_in_region
    real(c_double) :: z_thickness, z_s, z_r0(*), z_dx0_ds, z_dy0_ds, z_x0_coef(*), z_y0_coef(*)
    real(c_double) :: z_dr_ds, z_p1_coef(*), z_p2_coef(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wall3d_section_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_v(:)
integer(c_int) :: n1_v
integer(c_int) :: n_surface

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_v = 0
if (allocated(F%v)) then
  n1_v = size(F%v); lb1 = lbound(F%v, 1) - 1
  allocate (z_v(n1_v))
  do jd1 = 1, n1_v
    z_v(jd1) = c_loc(F%v(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 0, PTR]
n_surface = 0
if (associated(F%surface)) n_surface = 1

!! f_side.to_c2_call
call wall3d_section_to_c2 (C, trim(F%name) // c_null_char, trim(F%material) // c_null_char, &
    z_v, n1_v, c_loc(F%surface), n_surface, F%type, F%n_vertex_input, F%ix_ele, F%ix_branch, &
    F%vertices_state, c_logic(F%patch_in_region), F%thickness, F%s, fvec2vec(F%r0, 2), &
    F%dx0_ds, F%dy0_ds, fvec2vec(F%x0_coef, 4), fvec2vec(F%y0_coef, 4), F%dr_ds, &
    fvec2vec(F%p1_coef, 3), fvec2vec(F%p2_coef, 3))

end subroutine wall3d_section_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_section_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wall3d_section structure to a Bmad wall3d_section_struct structure.
! This routine is called by wall3d_section_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wall3d_section_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wall3d_section_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wall3d_section_to_f2 (Fp, z_name, z_material, z_v, n1_v, z_surface, n_surface, &
    z_type, z_n_vertex_input, z_ix_ele, z_ix_branch, z_vertices_state, z_patch_in_region, &
    z_thickness, z_s, z_r0, z_dx0_ds, z_dy0_ds, z_x0_coef, z_y0_coef, z_dr_ds, z_p1_coef, &
    z_p2_coef) bind(c)


implicit none

type(c_ptr), value :: Fp
type(wall3d_section_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_name(*), z_material(*)
type(c_ptr) :: z_v(*)
integer(c_int), value :: n1_v, n_surface
type(c_ptr), value :: z_surface
type(photon_reflect_surface_struct), pointer :: f_surface
integer(c_int) :: z_type, z_n_vertex_input, z_ix_ele, z_ix_branch, z_vertices_state
logical(c_bool) :: z_patch_in_region
real(c_double) :: z_thickness, z_s, z_r0(*), z_dx0_ds, z_dy0_ds, z_x0_coef(*), z_y0_coef(*)
real(c_double) :: z_dr_ds, z_p1_coef(*), z_p2_coef(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_material, F%material)
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_v == 0) then
  if (allocated(F%v)) deallocate(F%v)
else
  if (allocated(F%v)) then
    if (n1_v == 0 .or. any(shape(F%v) /= [n1_v])) deallocate(F%v)
    if (any(lbound(F%v) /= 1)) deallocate(F%v)
  endif
  if (.not. allocated(F%v)) allocate(F%v(1:n1_v+1-1))
  do jd1 = 1, n1_v
    call wall3d_vertex_to_f (z_v(jd1), c_loc(F%v(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_surface == 0) then
  if (associated(F%surface)) deallocate(F%surface)
else
  if (.not. associated(F%surface)) allocate(F%surface)
  call photon_reflect_surface_to_f (z_surface, c_loc(F%surface))
endif

!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_vertex_input = z_n_vertex_input
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%vertices_state = z_vertices_state
!! f_side.to_f2_trans[logical, 0, NOT]
F%patch_in_region = f_logic(z_patch_in_region)
!! f_side.to_f2_trans[real, 0, NOT]
F%thickness = z_thickness
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[real, 1, NOT]
F%r0 = z_r0(1:2)
!! f_side.to_f2_trans[real, 0, NOT]
F%dx0_ds = z_dx0_ds
!! f_side.to_f2_trans[real, 0, NOT]
F%dy0_ds = z_dy0_ds
!! f_side.to_f2_trans[real, 1, NOT]
F%x0_coef = z_x0_coef(1:4)
!! f_side.to_f2_trans[real, 1, NOT]
F%y0_coef = z_y0_coef(1:4)
!! f_side.to_f2_trans[real, 0, NOT]
F%dr_ds = z_dr_ds
!! f_side.to_f2_trans[real, 1, NOT]
F%p1_coef = z_p1_coef(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%p2_coef = z_p2_coef(1:3)

end subroutine wall3d_section_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad wall3d_struct to a C++ CPP_wall3d structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad wall3d_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_wall3d struct.
!-

subroutine wall3d_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine wall3d_to_c2 (C, z_name, z_type, z_ix_wall3d, z_n_link, z_thickness, &
      z_clear_material, z_opaque_material, z_superimpose, z_ele_anchor_pt, z_section, &
      n1_section) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_name(*), z_clear_material(*), z_opaque_material(*)
    integer(c_int) :: z_type, z_ix_wall3d, z_n_link, z_ele_anchor_pt
    real(c_double) :: z_thickness
    logical(c_bool) :: z_superimpose
    type(c_ptr) :: z_section(*)
    integer(c_int), value :: n1_section
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(wall3d_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_section(:)
integer(c_int) :: n1_section

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_section = 0
if (allocated(F%section)) then
  n1_section = size(F%section); lb1 = lbound(F%section, 1) - 1
  allocate (z_section(n1_section))
  do jd1 = 1, n1_section
    z_section(jd1) = c_loc(F%section(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call wall3d_to_c2 (C, trim(F%name) // c_null_char, F%type, F%ix_wall3d, F%n_link, F%thickness, &
    trim(F%clear_material) // c_null_char, trim(F%opaque_material) // c_null_char, &
    c_logic(F%superimpose), F%ele_anchor_pt, z_section, n1_section)

end subroutine wall3d_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine wall3d_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_wall3d structure to a Bmad wall3d_struct structure.
! This routine is called by wall3d_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the wall3d_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad wall3d_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine wall3d_to_f2 (Fp, z_name, z_type, z_ix_wall3d, z_n_link, z_thickness, &
    z_clear_material, z_opaque_material, z_superimpose, z_ele_anchor_pt, z_section, n1_section) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(wall3d_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_name(*), z_clear_material(*), z_opaque_material(*)
integer(c_int) :: z_type, z_ix_wall3d, z_n_link, z_ele_anchor_pt
real(c_double) :: z_thickness
logical(c_bool) :: z_superimpose
type(c_ptr) :: z_section(*)
integer(c_int), value :: n1_section

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[integer, 0, NOT]
F%type = z_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_wall3d = z_ix_wall3d
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_link = z_n_link
!! f_side.to_f2_trans[real, 0, NOT]
F%thickness = z_thickness
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_clear_material, F%clear_material)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_opaque_material, F%opaque_material)
!! f_side.to_f2_trans[logical, 0, NOT]
F%superimpose = f_logic(z_superimpose)
!! f_side.to_f2_trans[integer, 0, NOT]
F%ele_anchor_pt = z_ele_anchor_pt
!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_section == 0) then
  if (allocated(F%section)) deallocate(F%section)
else
  if (allocated(F%section)) then
    if (n1_section == 0 .or. any(shape(F%section) /= [n1_section])) deallocate(F%section)
    if (any(lbound(F%section) /= 1)) deallocate(F%section)
  endif
  if (.not. allocated(F%section)) allocate(F%section(1:n1_section+1-1))
  do jd1 = 1, n1_section
    call wall3d_section_to_f (z_section(jd1), c_loc(F%section(jd1+1-1)))
  enddo
endif


end subroutine wall3d_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ramper_lord_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad ramper_lord_struct to a C++ CPP_ramper_lord structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad ramper_lord_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_ramper_lord struct.
!-

subroutine ramper_lord_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine ramper_lord_to_c2 (C, z_ix_ele, z_ix_con, z_attrib_ptr, n_attrib_ptr) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_ix_ele, z_ix_con
    real(c_double) :: z_attrib_ptr
    integer(c_int), value :: n_attrib_ptr
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(ramper_lord_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n_attrib_ptr

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[real, 0, PTR]
n_attrib_ptr = 0
if (associated(F%attrib_ptr)) n_attrib_ptr = 1

!! f_side.to_c2_call
call ramper_lord_to_c2 (C, F%ix_ele, F%ix_con, F%attrib_ptr, n_attrib_ptr)

end subroutine ramper_lord_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ramper_lord_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_ramper_lord structure to a Bmad ramper_lord_struct structure.
! This routine is called by ramper_lord_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the ramper_lord_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad ramper_lord_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine ramper_lord_to_f2 (Fp, z_ix_ele, z_ix_con, z_attrib_ptr, n_attrib_ptr) bind(c)


implicit none

type(c_ptr), value :: Fp
type(ramper_lord_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_ix_ele, z_ix_con
type(c_ptr), value :: z_attrib_ptr
real(c_double), pointer :: f_attrib_ptr
integer(c_int), value :: n_attrib_ptr

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_con = z_ix_con
!! f_side.to_f2_trans[real, 0, PTR]
if (n_attrib_ptr == 0) then                                                                                  
  if (associated(F%attrib_ptr)) deallocate(F%attrib_ptr)                                                           
else                                                                                                   
  call c_f_pointer (z_attrib_ptr, f_attrib_ptr)                                                                    
  if (.not. associated(F%attrib_ptr)) allocate(F%attrib_ptr)                                                       
  F%attrib_ptr = f_attrib_ptr
endif                                                                                                  


end subroutine ramper_lord_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine control_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad control_struct to a C++ CPP_control structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad control_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_control struct.
!-

subroutine control_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine control_to_c2 (C, z_value, z_y_knot, n1_y_knot, z_stack, n1_stack, z_slave, &
      z_lord, z_slave_name, z_attribute, z_ix_attrib) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_value, z_y_knot(*)
    integer(c_int), value :: n1_y_knot, n1_stack
    type(c_ptr) :: z_stack(*)
    type(c_ptr), value :: z_slave, z_lord
    character(c_char) :: z_slave_name(*), z_attribute(*)
    integer(c_int) :: z_ix_attrib
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(control_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n1_y_knot
type(c_ptr), allocatable :: z_stack(:)
integer(c_int) :: n1_stack

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[real, 1, ALLOC]
n1_y_knot = 0
if (allocated(F%y_knot)) then
  n1_y_knot = size(F%y_knot, 1)
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_stack = 0
if (allocated(F%stack)) then
  n1_stack = size(F%stack); lb1 = lbound(F%stack, 1) - 1
  allocate (z_stack(n1_stack))
  do jd1 = 1, n1_stack
    z_stack(jd1) = c_loc(F%stack(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call control_to_c2 (C, F%value, fvec2vec(F%y_knot, n1_y_knot), n1_y_knot, z_stack, n1_stack, &
    c_loc(F%slave), c_loc(F%lord), trim(F%slave_name) // c_null_char, trim(F%attribute) // &
    c_null_char, F%ix_attrib)

end subroutine control_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine control_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_control structure to a Bmad control_struct structure.
! This routine is called by control_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the control_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad control_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine control_to_f2 (Fp, z_value, z_y_knot, n1_y_knot, z_stack, n1_stack, z_slave, z_lord, &
    z_slave_name, z_attribute, z_ix_attrib) bind(c)


implicit none

type(c_ptr), value :: Fp
type(control_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_value
type(c_ptr), value :: z_y_knot, z_slave, z_lord
real(c_double), pointer :: f_y_knot(:)
integer(c_int), value :: n1_y_knot, n1_stack
type(c_ptr) :: z_stack(*)
character(c_char) :: z_slave_name(*), z_attribute(*)
integer(c_int) :: z_ix_attrib

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%value = z_value
!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%y_knot)) then
  if (n1_y_knot == 0 .or. any(shape(F%y_knot) /= [n1_y_knot])) deallocate(F%y_knot)
  if (any(lbound(F%y_knot) /= 1)) deallocate(F%y_knot)
endif
if (n1_y_knot /= 0) then
  call c_f_pointer (z_y_knot, f_y_knot, [n1_y_knot])
  if (.not. allocated(F%y_knot)) allocate(F%y_knot(n1_y_knot))
  F%y_knot = f_y_knot(1:n1_y_knot)
else
  if (allocated(F%y_knot)) deallocate(F%y_knot)
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_stack == 0) then
  if (allocated(F%stack)) deallocate(F%stack)
else
  if (allocated(F%stack)) then
    if (n1_stack == 0 .or. any(shape(F%stack) /= [n1_stack])) deallocate(F%stack)
    if (any(lbound(F%stack) /= 1)) deallocate(F%stack)
  endif
  if (.not. allocated(F%stack)) allocate(F%stack(1:n1_stack+1-1))
  do jd1 = 1, n1_stack
    call expression_atom_to_f (z_stack(jd1), c_loc(F%stack(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, NOT]
call lat_ele_loc_to_f(z_slave, c_loc(F%slave))
!! f_side.to_f2_trans[type, 0, NOT]
call lat_ele_loc_to_f(z_lord, c_loc(F%lord))
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_slave_name, F%slave_name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_attribute, F%attribute)
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_attrib = z_ix_attrib

end subroutine control_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine control_var1_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad control_var1_struct to a C++ CPP_control_var1 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad control_var1_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_control_var1 struct.
!-

subroutine control_var1_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine control_var1_to_c2 (C, z_name, z_value, z_old_value) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_name(*)
    real(c_double) :: z_value, z_old_value
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(control_var1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call control_var1_to_c2 (C, trim(F%name) // c_null_char, F%value, F%old_value)

end subroutine control_var1_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine control_var1_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_control_var1 structure to a Bmad control_var1_struct structure.
! This routine is called by control_var1_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the control_var1_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad control_var1_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine control_var1_to_f2 (Fp, z_name, z_value, z_old_value) bind(c)


implicit none

type(c_ptr), value :: Fp
type(control_var1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_name(*)
real(c_double) :: z_value, z_old_value

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[real, 0, NOT]
F%value = z_value
!! f_side.to_f2_trans[real, 0, NOT]
F%old_value = z_old_value

end subroutine control_var1_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine control_ramp1_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad control_ramp1_struct to a C++ CPP_control_ramp1 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad control_ramp1_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_control_ramp1 struct.
!-

subroutine control_ramp1_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine control_ramp1_to_c2 (C, z_y_knot, n1_y_knot, z_stack, n1_stack, z_attribute, &
      z_slave_name, z_is_controller) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_y_knot(*)
    integer(c_int), value :: n1_y_knot, n1_stack
    type(c_ptr) :: z_stack(*)
    character(c_char) :: z_attribute(*), z_slave_name(*)
    logical(c_bool) :: z_is_controller
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(control_ramp1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
integer(c_int) :: n1_y_knot
type(c_ptr), allocatable :: z_stack(:)
integer(c_int) :: n1_stack

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[real, 1, ALLOC]
n1_y_knot = 0
if (allocated(F%y_knot)) then
  n1_y_knot = size(F%y_knot, 1)
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_stack = 0
if (allocated(F%stack)) then
  n1_stack = size(F%stack); lb1 = lbound(F%stack, 1) - 1
  allocate (z_stack(n1_stack))
  do jd1 = 1, n1_stack
    z_stack(jd1) = c_loc(F%stack(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call control_ramp1_to_c2 (C, fvec2vec(F%y_knot, n1_y_knot), n1_y_knot, z_stack, n1_stack, &
    trim(F%attribute) // c_null_char, trim(F%slave_name) // c_null_char, &
    c_logic(F%is_controller))

end subroutine control_ramp1_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine control_ramp1_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_control_ramp1 structure to a Bmad control_ramp1_struct structure.
! This routine is called by control_ramp1_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the control_ramp1_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad control_ramp1_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine control_ramp1_to_f2 (Fp, z_y_knot, n1_y_knot, z_stack, n1_stack, z_attribute, &
    z_slave_name, z_is_controller) bind(c)


implicit none

type(c_ptr), value :: Fp
type(control_ramp1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_y_knot
real(c_double), pointer :: f_y_knot(:)
integer(c_int), value :: n1_y_knot, n1_stack
type(c_ptr) :: z_stack(*)
character(c_char) :: z_attribute(*), z_slave_name(*)
logical(c_bool) :: z_is_controller

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%y_knot)) then
  if (n1_y_knot == 0 .or. any(shape(F%y_knot) /= [n1_y_knot])) deallocate(F%y_knot)
  if (any(lbound(F%y_knot) /= 1)) deallocate(F%y_knot)
endif
if (n1_y_knot /= 0) then
  call c_f_pointer (z_y_knot, f_y_knot, [n1_y_knot])
  if (.not. allocated(F%y_knot)) allocate(F%y_knot(n1_y_knot))
  F%y_knot = f_y_knot(1:n1_y_knot)
else
  if (allocated(F%y_knot)) deallocate(F%y_knot)
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_stack == 0) then
  if (allocated(F%stack)) deallocate(F%stack)
else
  if (allocated(F%stack)) then
    if (n1_stack == 0 .or. any(shape(F%stack) /= [n1_stack])) deallocate(F%stack)
    if (any(lbound(F%stack) /= 1)) deallocate(F%stack)
  endif
  if (.not. allocated(F%stack)) allocate(F%stack(1:n1_stack+1-1))
  do jd1 = 1, n1_stack
    call expression_atom_to_f (z_stack(jd1), c_loc(F%stack(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_attribute, F%attribute)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_slave_name, F%slave_name)
!! f_side.to_f2_trans[logical, 0, NOT]
F%is_controller = f_logic(z_is_controller)

end subroutine control_ramp1_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine controller_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad controller_struct to a C++ CPP_controller structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad controller_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_controller struct.
!-

subroutine controller_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine controller_to_c2 (C, z_var, n1_var, z_ramp, n1_ramp, z_ramper_lord, &
      n1_ramper_lord, z_x_knot, n1_x_knot) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_var(*), z_ramp(*), z_ramper_lord(*)
    integer(c_int), value :: n1_var, n1_ramp, n1_ramper_lord, n1_x_knot
    real(c_double) :: z_x_knot(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(controller_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_var(:)
integer(c_int) :: n1_var
type(c_ptr), allocatable :: z_ramp(:)
integer(c_int) :: n1_ramp
type(c_ptr), allocatable :: z_ramper_lord(:)
integer(c_int) :: n1_ramper_lord
integer(c_int) :: n1_x_knot

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_var = 0
if (allocated(F%var)) then
  n1_var = size(F%var); lb1 = lbound(F%var, 1) - 1
  allocate (z_var(n1_var))
  do jd1 = 1, n1_var
    z_var(jd1) = c_loc(F%var(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_ramp = 0
if (allocated(F%ramp)) then
  n1_ramp = size(F%ramp); lb1 = lbound(F%ramp, 1) - 1
  allocate (z_ramp(n1_ramp))
  do jd1 = 1, n1_ramp
    z_ramp(jd1) = c_loc(F%ramp(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_ramper_lord = 0
if (allocated(F%ramper_lord)) then
  n1_ramper_lord = size(F%ramper_lord); lb1 = lbound(F%ramper_lord, 1) - 1
  allocate (z_ramper_lord(n1_ramper_lord))
  do jd1 = 1, n1_ramper_lord
    z_ramper_lord(jd1) = c_loc(F%ramper_lord(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[real, 1, ALLOC]
n1_x_knot = 0
if (allocated(F%x_knot)) then
  n1_x_knot = size(F%x_knot, 1)
endif

!! f_side.to_c2_call
call controller_to_c2 (C, z_var, n1_var, z_ramp, n1_ramp, z_ramper_lord, n1_ramper_lord, &
    fvec2vec(F%x_knot, n1_x_knot), n1_x_knot)

end subroutine controller_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine controller_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_controller structure to a Bmad controller_struct structure.
! This routine is called by controller_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the controller_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad controller_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine controller_to_f2 (Fp, z_var, n1_var, z_ramp, n1_ramp, z_ramper_lord, n1_ramper_lord, &
    z_x_knot, n1_x_knot) bind(c)


implicit none

type(c_ptr), value :: Fp
type(controller_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr) :: z_var(*), z_ramp(*), z_ramper_lord(*)
integer(c_int), value :: n1_var, n1_ramp, n1_ramper_lord, n1_x_knot
type(c_ptr), value :: z_x_knot
real(c_double), pointer :: f_x_knot(:)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_var == 0) then
  if (allocated(F%var)) deallocate(F%var)
else
  if (allocated(F%var)) then
    if (n1_var == 0 .or. any(shape(F%var) /= [n1_var])) deallocate(F%var)
    if (any(lbound(F%var) /= 1)) deallocate(F%var)
  endif
  if (.not. allocated(F%var)) allocate(F%var(1:n1_var+1-1))
  do jd1 = 1, n1_var
    call control_var1_to_f (z_var(jd1), c_loc(F%var(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_ramp == 0) then
  if (allocated(F%ramp)) deallocate(F%ramp)
else
  if (allocated(F%ramp)) then
    if (n1_ramp == 0 .or. any(shape(F%ramp) /= [n1_ramp])) deallocate(F%ramp)
    if (any(lbound(F%ramp) /= 1)) deallocate(F%ramp)
  endif
  if (.not. allocated(F%ramp)) allocate(F%ramp(1:n1_ramp+1-1))
  do jd1 = 1, n1_ramp
    call control_ramp1_to_f (z_ramp(jd1), c_loc(F%ramp(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_ramper_lord == 0) then
  if (allocated(F%ramper_lord)) deallocate(F%ramper_lord)
else
  if (allocated(F%ramper_lord)) then
    if (n1_ramper_lord == 0 .or. any(shape(F%ramper_lord) /= [n1_ramper_lord])) deallocate(F%ramper_lord)
    if (any(lbound(F%ramper_lord) /= 1)) deallocate(F%ramper_lord)
  endif
  if (.not. allocated(F%ramper_lord)) allocate(F%ramper_lord(1:n1_ramper_lord+1-1))
  do jd1 = 1, n1_ramper_lord
    call ramper_lord_to_f (z_ramper_lord(jd1), c_loc(F%ramper_lord(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%x_knot)) then
  if (n1_x_knot == 0 .or. any(shape(F%x_knot) /= [n1_x_knot])) deallocate(F%x_knot)
  if (any(lbound(F%x_knot) /= 1)) deallocate(F%x_knot)
endif
if (n1_x_knot /= 0) then
  call c_f_pointer (z_x_knot, f_x_knot, [n1_x_knot])
  if (.not. allocated(F%x_knot)) allocate(F%x_knot(n1_x_knot))
  F%x_knot = f_x_knot(1:n1_x_knot)
else
  if (allocated(F%x_knot)) deallocate(F%x_knot)
endif


end subroutine controller_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ellipse_beam_init_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad ellipse_beam_init_struct to a C++ CPP_ellipse_beam_init structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad ellipse_beam_init_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_ellipse_beam_init struct.
!-

subroutine ellipse_beam_init_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine ellipse_beam_init_to_c2 (C, z_part_per_ellipse, z_n_ellipse, z_sigma_cutoff) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_part_per_ellipse, z_n_ellipse
    real(c_double) :: z_sigma_cutoff
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(ellipse_beam_init_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call ellipse_beam_init_to_c2 (C, F%part_per_ellipse, F%n_ellipse, F%sigma_cutoff)

end subroutine ellipse_beam_init_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ellipse_beam_init_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_ellipse_beam_init structure to a Bmad ellipse_beam_init_struct structure.
! This routine is called by ellipse_beam_init_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the ellipse_beam_init_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad ellipse_beam_init_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine ellipse_beam_init_to_f2 (Fp, z_part_per_ellipse, z_n_ellipse, z_sigma_cutoff) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(ellipse_beam_init_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_part_per_ellipse, z_n_ellipse
real(c_double) :: z_sigma_cutoff

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%part_per_ellipse = z_part_per_ellipse
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ellipse = z_n_ellipse
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma_cutoff = z_sigma_cutoff

end subroutine ellipse_beam_init_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine kv_beam_init_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad kv_beam_init_struct to a C++ CPP_kv_beam_init structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad kv_beam_init_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_kv_beam_init struct.
!-

subroutine kv_beam_init_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine kv_beam_init_to_c2 (C, z_part_per_phi, z_n_i2, z_a) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_part_per_phi(*), z_n_i2
    real(c_double) :: z_a
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(kv_beam_init_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call kv_beam_init_to_c2 (C, fvec2vec(F%part_per_phi, 2), F%n_i2, F%a)

end subroutine kv_beam_init_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine kv_beam_init_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_kv_beam_init structure to a Bmad kv_beam_init_struct structure.
! This routine is called by kv_beam_init_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the kv_beam_init_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad kv_beam_init_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine kv_beam_init_to_f2 (Fp, z_part_per_phi, z_n_i2, z_a) bind(c)


implicit none

type(c_ptr), value :: Fp
type(kv_beam_init_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_part_per_phi(*), z_n_i2
real(c_double) :: z_a

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 1, NOT]
F%part_per_phi = z_part_per_phi(1:2)
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_i2 = z_n_i2
!! f_side.to_f2_trans[real, 0, NOT]
F%a = z_a

end subroutine kv_beam_init_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine grid_beam_init_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad grid_beam_init_struct to a C++ CPP_grid_beam_init structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad grid_beam_init_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_grid_beam_init struct.
!-

subroutine grid_beam_init_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine grid_beam_init_to_c2 (C, z_n_x, z_n_px, z_x_min, z_x_max, z_px_min, z_px_max) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_n_x, z_n_px
    real(c_double) :: z_x_min, z_x_max, z_px_min, z_px_max
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(grid_beam_init_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call grid_beam_init_to_c2 (C, F%n_x, F%n_px, F%x_min, F%x_max, F%px_min, F%px_max)

end subroutine grid_beam_init_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine grid_beam_init_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_grid_beam_init structure to a Bmad grid_beam_init_struct structure.
! This routine is called by grid_beam_init_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the grid_beam_init_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad grid_beam_init_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine grid_beam_init_to_f2 (Fp, z_n_x, z_n_px, z_x_min, z_x_max, z_px_min, z_px_max) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(grid_beam_init_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_n_x, z_n_px
real(c_double) :: z_x_min, z_x_max, z_px_min, z_px_max

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%n_x = z_n_x
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_px = z_n_px
!! f_side.to_f2_trans[real, 0, NOT]
F%x_min = z_x_min
!! f_side.to_f2_trans[real, 0, NOT]
F%x_max = z_x_max
!! f_side.to_f2_trans[real, 0, NOT]
F%px_min = z_px_min
!! f_side.to_f2_trans[real, 0, NOT]
F%px_max = z_px_max

end subroutine grid_beam_init_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine beam_init_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad beam_init_struct to a C++ CPP_beam_init structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad beam_init_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_beam_init struct.
!-

subroutine beam_init_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine beam_init_to_c2 (C, z_position_file, z_distribution_type, z_spin, z_ellipse, z_kv, &
      z_grid, z_center_jitter, z_emit_jitter, z_sig_z_jitter, z_sig_pz_jitter, z_n_particle, &
      z_renorm_center, z_renorm_sigma, z_random_engine, z_random_gauss_converter, &
      z_random_sigma_cutoff, z_a_norm_emit, z_b_norm_emit, z_a_emit, z_b_emit, z_dpz_dz, &
      z_center, z_t_offset, z_dt_bunch, z_sig_z, z_sig_pz, z_bunch_charge, z_n_bunch, &
      z_ix_turn, z_species, z_full_6d_coupling_calc, z_use_particle_start, z_use_t_coords, &
      z_use_z_as_t, z_file_name) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_position_file(*), z_random_engine(*), z_random_gauss_converter(*), z_species(*), z_file_name(*)
    type(c_ptr) :: z_distribution_type(*), z_ellipse(*), z_grid(*)
    real(c_double) :: z_spin(*), z_center_jitter(*), z_emit_jitter(*), z_sig_z_jitter, z_sig_pz_jitter, z_random_sigma_cutoff, z_a_norm_emit
    real(c_double) :: z_b_norm_emit, z_a_emit, z_b_emit, z_dpz_dz, z_center(*), z_t_offset, z_dt_bunch
    real(c_double) :: z_sig_z, z_sig_pz, z_bunch_charge
    type(c_ptr), value :: z_kv
    integer(c_int) :: z_n_particle, z_n_bunch, z_ix_turn
    logical(c_bool) :: z_renorm_center, z_renorm_sigma, z_full_6d_coupling_calc, z_use_particle_start, z_use_t_coords, z_use_z_as_t
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(beam_init_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr) :: z_distribution_type(3)
character(16+1), target :: a_distribution_type(3)
type(c_ptr) :: z_ellipse(3)
type(c_ptr) :: z_grid(3)

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[character, 1, NOT]
do jd1 = 1, size(F%distribution_type,1); lb1 = lbound(F%distribution_type,1) - 1
  a_distribution_type(jd1) = trim(F%distribution_type(jd1+lb1)) // c_null_char
  z_distribution_type(jd1) = c_loc(a_distribution_type(jd1))
enddo
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%ellipse,1); lb1 = lbound(F%ellipse,1) - 1
  z_ellipse(jd1) = c_loc(F%ellipse(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%grid,1); lb1 = lbound(F%grid,1) - 1
  z_grid(jd1) = c_loc(F%grid(jd1+lb1))
enddo

!! f_side.to_c2_call
call beam_init_to_c2 (C, trim(F%position_file) // c_null_char, z_distribution_type, &
    fvec2vec(F%spin, 3), z_ellipse, c_loc(F%kv), z_grid, fvec2vec(F%center_jitter, 6), &
    fvec2vec(F%emit_jitter, 2), F%sig_z_jitter, F%sig_pz_jitter, F%n_particle, &
    c_logic(F%renorm_center), c_logic(F%renorm_sigma), trim(F%random_engine) // c_null_char, &
    trim(F%random_gauss_converter) // c_null_char, F%random_sigma_cutoff, F%a_norm_emit, &
    F%b_norm_emit, F%a_emit, F%b_emit, F%dpz_dz, fvec2vec(F%center, 6), F%t_offset, F%dt_bunch, &
    F%sig_z, F%sig_pz, F%bunch_charge, F%n_bunch, F%ix_turn, trim(F%species) // c_null_char, &
    c_logic(F%full_6d_coupling_calc), c_logic(F%use_particle_start), c_logic(F%use_t_coords), &
    c_logic(F%use_z_as_t), trim(F%file_name) // c_null_char)

end subroutine beam_init_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine beam_init_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_beam_init structure to a Bmad beam_init_struct structure.
! This routine is called by beam_init_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the beam_init_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad beam_init_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine beam_init_to_f2 (Fp, z_position_file, z_distribution_type, z_spin, z_ellipse, z_kv, &
    z_grid, z_center_jitter, z_emit_jitter, z_sig_z_jitter, z_sig_pz_jitter, z_n_particle, &
    z_renorm_center, z_renorm_sigma, z_random_engine, z_random_gauss_converter, &
    z_random_sigma_cutoff, z_a_norm_emit, z_b_norm_emit, z_a_emit, z_b_emit, z_dpz_dz, &
    z_center, z_t_offset, z_dt_bunch, z_sig_z, z_sig_pz, z_bunch_charge, z_n_bunch, z_ix_turn, &
    z_species, z_full_6d_coupling_calc, z_use_particle_start, z_use_t_coords, z_use_z_as_t, &
    z_file_name) bind(c)


implicit none

type(c_ptr), value :: Fp
type(beam_init_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_position_file(*), z_random_engine(*), z_random_gauss_converter(*), z_species(*), z_file_name(*)
type(c_ptr) :: z_distribution_type(*), z_ellipse(*), z_grid(*)
character(c_char), pointer :: f_distribution_type
real(c_double) :: z_spin(*), z_center_jitter(*), z_emit_jitter(*), z_sig_z_jitter, z_sig_pz_jitter, z_random_sigma_cutoff, z_a_norm_emit
real(c_double) :: z_b_norm_emit, z_a_emit, z_b_emit, z_dpz_dz, z_center(*), z_t_offset, z_dt_bunch
real(c_double) :: z_sig_z, z_sig_pz, z_bunch_charge
type(c_ptr), value :: z_kv
integer(c_int) :: z_n_particle, z_n_bunch, z_ix_turn
logical(c_bool) :: z_renorm_center, z_renorm_sigma, z_full_6d_coupling_calc, z_use_particle_start, z_use_t_coords, z_use_z_as_t

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_position_file, F%position_file)
!! f_side.to_f2_trans[character, 1, NOT]
do jd1 = 1, size(F%distribution_type,1); lb1 = lbound(F%distribution_type,1) - 1
  call c_f_pointer (z_distribution_type(jd1), f_distribution_type)
  call to_f_str(f_distribution_type, F%distribution_type(jd1+lb1))
enddo

!! f_side.to_f2_trans[real, 1, NOT]
F%spin = z_spin(1:3)
!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%ellipse,1); lb1 = lbound(F%ellipse,1) - 1
  call ellipse_beam_init_to_f(z_ellipse(jd1), c_loc(F%ellipse(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 0, NOT]
call kv_beam_init_to_f(z_kv, c_loc(F%kv))
!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%grid,1); lb1 = lbound(F%grid,1) - 1
  call grid_beam_init_to_f(z_grid(jd1), c_loc(F%grid(jd1+lb1)))
enddo
!! f_side.to_f2_trans[real, 1, NOT]
F%center_jitter = z_center_jitter(1:6)
!! f_side.to_f2_trans[real, 1, NOT]
F%emit_jitter = z_emit_jitter(1:2)
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_z_jitter = z_sig_z_jitter
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_pz_jitter = z_sig_pz_jitter
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_particle = z_n_particle
!! f_side.to_f2_trans[logical, 0, NOT]
F%renorm_center = f_logic(z_renorm_center)
!! f_side.to_f2_trans[logical, 0, NOT]
F%renorm_sigma = f_logic(z_renorm_sigma)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_random_engine, F%random_engine)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_random_gauss_converter, F%random_gauss_converter)
!! f_side.to_f2_trans[real, 0, NOT]
F%random_sigma_cutoff = z_random_sigma_cutoff
!! f_side.to_f2_trans[real, 0, NOT]
F%a_norm_emit = z_a_norm_emit
!! f_side.to_f2_trans[real, 0, NOT]
F%b_norm_emit = z_b_norm_emit
!! f_side.to_f2_trans[real, 0, NOT]
F%a_emit = z_a_emit
!! f_side.to_f2_trans[real, 0, NOT]
F%b_emit = z_b_emit
!! f_side.to_f2_trans[real, 0, NOT]
F%dpz_dz = z_dpz_dz
!! f_side.to_f2_trans[real, 1, NOT]
F%center = z_center(1:6)
!! f_side.to_f2_trans[real, 0, NOT]
F%t_offset = z_t_offset
!! f_side.to_f2_trans[real, 0, NOT]
F%dt_bunch = z_dt_bunch
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_z = z_sig_z
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_pz = z_sig_pz
!! f_side.to_f2_trans[real, 0, NOT]
F%bunch_charge = z_bunch_charge
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_bunch = z_n_bunch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_turn = z_ix_turn
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_species, F%species)
!! f_side.to_f2_trans[logical, 0, NOT]
F%full_6d_coupling_calc = f_logic(z_full_6d_coupling_calc)
!! f_side.to_f2_trans[logical, 0, NOT]
F%use_particle_start = f_logic(z_use_particle_start)
!! f_side.to_f2_trans[logical, 0, NOT]
F%use_t_coords = f_logic(z_use_t_coords)
!! f_side.to_f2_trans[logical, 0, NOT]
F%use_z_as_t = f_logic(z_use_z_as_t)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_file_name, F%file_name)

end subroutine beam_init_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_param_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad lat_param_struct to a C++ CPP_lat_param structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad lat_param_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_lat_param struct.
!-

subroutine lat_param_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine lat_param_to_c2 (C, z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf, &
      z_t1_no_rf, z_spin_tune, z_particle, z_default_tracking_species, z_geometry, z_ixx, &
      z_stable, z_live_branch, z_g1_integral, z_g2_integral, z_g3_integral, &
      z_bookkeeping_state, z_beam_init) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf(*), z_t1_no_rf(*), z_spin_tune, z_g1_integral
    real(c_double) :: z_g2_integral, z_g3_integral
    integer(c_int) :: z_particle, z_default_tracking_species, z_geometry, z_ixx
    logical(c_bool) :: z_stable, z_live_branch
    type(c_ptr), value :: z_bookkeeping_state, z_beam_init
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(lat_param_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call lat_param_to_c2 (C, F%n_part, F%total_length, F%unstable_factor, mat2vec(F%t1_with_rf, &
    6*6), mat2vec(F%t1_no_rf, 6*6), F%spin_tune, F%particle, F%default_tracking_species, &
    F%geometry, F%ixx, c_logic(F%stable), c_logic(F%live_branch), F%g1_integral, F%g2_integral, &
    F%g3_integral, c_loc(F%bookkeeping_state), c_loc(F%beam_init))

end subroutine lat_param_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_param_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_lat_param structure to a Bmad lat_param_struct structure.
! This routine is called by lat_param_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the lat_param_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad lat_param_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine lat_param_to_f2 (Fp, z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf, &
    z_t1_no_rf, z_spin_tune, z_particle, z_default_tracking_species, z_geometry, z_ixx, &
    z_stable, z_live_branch, z_g1_integral, z_g2_integral, z_g3_integral, z_bookkeeping_state, &
    z_beam_init) bind(c)


implicit none

type(c_ptr), value :: Fp
type(lat_param_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_n_part, z_total_length, z_unstable_factor, z_t1_with_rf(*), z_t1_no_rf(*), z_spin_tune, z_g1_integral
real(c_double) :: z_g2_integral, z_g3_integral
integer(c_int) :: z_particle, z_default_tracking_species, z_geometry, z_ixx
logical(c_bool) :: z_stable, z_live_branch
type(c_ptr), value :: z_bookkeeping_state, z_beam_init

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%n_part = z_n_part
!! f_side.to_f2_trans[real, 0, NOT]
F%total_length = z_total_length
!! f_side.to_f2_trans[real, 0, NOT]
F%unstable_factor = z_unstable_factor
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_t1_with_rf, F%t1_with_rf)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_t1_no_rf, F%t1_no_rf)
!! f_side.to_f2_trans[real, 0, NOT]
F%spin_tune = z_spin_tune
!! f_side.to_f2_trans[integer, 0, NOT]
F%particle = z_particle
!! f_side.to_f2_trans[integer, 0, NOT]
F%default_tracking_species = z_default_tracking_species
!! f_side.to_f2_trans[integer, 0, NOT]
F%geometry = z_geometry
!! f_side.to_f2_trans[integer, 0, NOT]
F%ixx = z_ixx
!! f_side.to_f2_trans[logical, 0, NOT]
F%stable = f_logic(z_stable)
!! f_side.to_f2_trans[logical, 0, NOT]
F%live_branch = f_logic(z_live_branch)
!! f_side.to_f2_trans[real, 0, NOT]
F%g1_integral = z_g1_integral
!! f_side.to_f2_trans[real, 0, NOT]
F%g2_integral = z_g2_integral
!! f_side.to_f2_trans[real, 0, NOT]
F%g3_integral = z_g3_integral
!! f_side.to_f2_trans[type, 0, NOT]
call bookkeeping_state_to_f(z_bookkeeping_state, c_loc(F%bookkeeping_state))
!! f_side.to_f2_trans[type, 0, NOT]
call beam_init_to_f(z_beam_init, c_loc(F%beam_init))

end subroutine lat_param_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode_info_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad mode_info_struct to a C++ CPP_mode_info structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad mode_info_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_mode_info struct.
!-

subroutine mode_info_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine mode_info_to_c2 (C, z_stable, z_tune, z_emit, z_chrom, z_sigma, z_sigmap) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    logical(c_bool) :: z_stable
    real(c_double) :: z_tune, z_emit, z_chrom, z_sigma, z_sigmap
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(mode_info_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call mode_info_to_c2 (C, c_logic(F%stable), F%tune, F%emit, F%chrom, F%sigma, F%sigmap)

end subroutine mode_info_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine mode_info_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_mode_info structure to a Bmad mode_info_struct structure.
! This routine is called by mode_info_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the mode_info_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad mode_info_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine mode_info_to_f2 (Fp, z_stable, z_tune, z_emit, z_chrom, z_sigma, z_sigmap) bind(c)


implicit none

type(c_ptr), value :: Fp
type(mode_info_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
logical(c_bool) :: z_stable
real(c_double) :: z_tune, z_emit, z_chrom, z_sigma, z_sigmap

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[logical, 0, NOT]
F%stable = f_logic(z_stable)
!! f_side.to_f2_trans[real, 0, NOT]
F%tune = z_tune
!! f_side.to_f2_trans[real, 0, NOT]
F%emit = z_emit
!! f_side.to_f2_trans[real, 0, NOT]
F%chrom = z_chrom
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma = z_sigma
!! f_side.to_f2_trans[real, 0, NOT]
F%sigmap = z_sigmap

end subroutine mode_info_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine pre_tracker_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad pre_tracker_struct to a C++ CPP_pre_tracker structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad pre_tracker_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_pre_tracker struct.
!-

subroutine pre_tracker_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine pre_tracker_to_c2 (C, z_who, z_ix_ele_start, z_ix_ele_end, z_input_file) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_who, z_ix_ele_start, z_ix_ele_end
    character(c_char) :: z_input_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(pre_tracker_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call pre_tracker_to_c2 (C, F%who, F%ix_ele_start, F%ix_ele_end, trim(F%input_file) // &
    c_null_char)

end subroutine pre_tracker_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine pre_tracker_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_pre_tracker structure to a Bmad pre_tracker_struct structure.
! This routine is called by pre_tracker_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the pre_tracker_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad pre_tracker_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine pre_tracker_to_f2 (Fp, z_who, z_ix_ele_start, z_ix_ele_end, z_input_file) bind(c)


implicit none

type(c_ptr), value :: Fp
type(pre_tracker_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_who, z_ix_ele_start, z_ix_ele_end
character(c_char) :: z_input_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%who = z_who
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele_start = z_ix_ele_start
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele_end = z_ix_ele_end
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_input_file, F%input_file)

end subroutine pre_tracker_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine anormal_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad anormal_mode_struct to a C++ CPP_anormal_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad anormal_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_anormal_mode struct.
!-

subroutine anormal_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine anormal_mode_to_c2 (C, z_emittance, z_emittance_no_vert, z_synch_int, z_j_damp, &
      z_alpha_damp, z_chrom, z_tune) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_emittance, z_emittance_no_vert, z_synch_int(*), z_j_damp, z_alpha_damp, z_chrom, z_tune
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(anormal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call anormal_mode_to_c2 (C, F%emittance, F%emittance_no_vert, fvec2vec(F%synch_int, 3), &
    F%j_damp, F%alpha_damp, F%chrom, F%tune)

end subroutine anormal_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine anormal_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_anormal_mode structure to a Bmad anormal_mode_struct structure.
! This routine is called by anormal_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the anormal_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad anormal_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine anormal_mode_to_f2 (Fp, z_emittance, z_emittance_no_vert, z_synch_int, z_j_damp, &
    z_alpha_damp, z_chrom, z_tune) bind(c)


implicit none

type(c_ptr), value :: Fp
type(anormal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_emittance, z_emittance_no_vert, z_synch_int(*), z_j_damp, z_alpha_damp, z_chrom, z_tune

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%emittance = z_emittance
!! f_side.to_f2_trans[real, 0, NOT]
F%emittance_no_vert = z_emittance_no_vert
!! f_side.to_f2_trans[real, 1, NOT]
F%synch_int = z_synch_int(1:3)
!! f_side.to_f2_trans[real, 0, NOT]
F%j_damp = z_j_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%alpha_damp = z_alpha_damp
!! f_side.to_f2_trans[real, 0, NOT]
F%chrom = z_chrom
!! f_side.to_f2_trans[real, 0, NOT]
F%tune = z_tune

end subroutine anormal_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine linac_normal_mode_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad linac_normal_mode_struct to a C++ CPP_linac_normal_mode structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad linac_normal_mode_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_linac_normal_mode struct.
!-

subroutine linac_normal_mode_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine linac_normal_mode_to_c2 (C, z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, &
      z_a_emittance_end, z_b_emittance_end) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, z_a_emittance_end, z_b_emittance_end
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(linac_normal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call linac_normal_mode_to_c2 (C, F%i2_e4, F%i3_e7, F%i5a_e6, F%i5b_e6, F%sig_e1, &
    F%a_emittance_end, F%b_emittance_end)

end subroutine linac_normal_mode_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine linac_normal_mode_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_linac_normal_mode structure to a Bmad linac_normal_mode_struct structure.
! This routine is called by linac_normal_mode_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the linac_normal_mode_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad linac_normal_mode_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine linac_normal_mode_to_f2 (Fp, z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, &
    z_a_emittance_end, z_b_emittance_end) bind(c)


implicit none

type(c_ptr), value :: Fp
type(linac_normal_mode_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_i2_e4, z_i3_e7, z_i5a_e6, z_i5b_e6, z_sig_e1, z_a_emittance_end, z_b_emittance_end

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%i2_e4 = z_i2_e4
!! f_side.to_f2_trans[real, 0, NOT]
F%i3_e7 = z_i3_e7
!! f_side.to_f2_trans[real, 0, NOT]
F%i5a_e6 = z_i5a_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%i5b_e6 = z_i5b_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_e1 = z_sig_e1
!! f_side.to_f2_trans[real, 0, NOT]
F%a_emittance_end = z_a_emittance_end
!! f_side.to_f2_trans[real, 0, NOT]
F%b_emittance_end = z_b_emittance_end

end subroutine linac_normal_mode_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine normal_modes_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad normal_modes_struct to a C++ CPP_normal_modes structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad normal_modes_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_normal_modes struct.
!-

subroutine normal_modes_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine normal_modes_to_c2 (C, z_synch_int, z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, &
      z_pz_aperture, z_pz_average, z_momentum_compaction, z_dpz_damp, z_a, z_b, z_z, z_lin) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_synch_int(*), z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, z_pz_aperture, z_pz_average
    real(c_double) :: z_momentum_compaction, z_dpz_damp
    type(c_ptr), value :: z_a, z_b, z_z, z_lin
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(normal_modes_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call normal_modes_to_c2 (C, fvec2vec(F%synch_int, 4), F%sige_e, F%sig_z, F%e_loss, &
    F%rf_voltage, F%pz_aperture, F%pz_average, F%momentum_compaction, F%dpz_damp, c_loc(F%a), &
    c_loc(F%b), c_loc(F%z), c_loc(F%lin))

end subroutine normal_modes_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine normal_modes_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_normal_modes structure to a Bmad normal_modes_struct structure.
! This routine is called by normal_modes_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the normal_modes_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad normal_modes_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine normal_modes_to_f2 (Fp, z_synch_int, z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, &
    z_pz_aperture, z_pz_average, z_momentum_compaction, z_dpz_damp, z_a, z_b, z_z, z_lin) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(normal_modes_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_synch_int(*), z_sige_e, z_sig_z, z_e_loss, z_rf_voltage, z_pz_aperture, z_pz_average
real(c_double) :: z_momentum_compaction, z_dpz_damp
type(c_ptr), value :: z_a, z_b, z_z, z_lin

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%synch_int = z_synch_int(1:4)
!! f_side.to_f2_trans[real, 0, NOT]
F%sige_e = z_sige_e
!! f_side.to_f2_trans[real, 0, NOT]
F%sig_z = z_sig_z
!! f_side.to_f2_trans[real, 0, NOT]
F%e_loss = z_e_loss
!! f_side.to_f2_trans[real, 0, NOT]
F%rf_voltage = z_rf_voltage
!! f_side.to_f2_trans[real, 0, NOT]
F%pz_aperture = z_pz_aperture
!! f_side.to_f2_trans[real, 0, NOT]
F%pz_average = z_pz_average
!! f_side.to_f2_trans[real, 0, NOT]
F%momentum_compaction = z_momentum_compaction
!! f_side.to_f2_trans[real, 0, NOT]
F%dpz_damp = z_dpz_damp
!! f_side.to_f2_trans[type, 0, NOT]
call anormal_mode_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call anormal_mode_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call anormal_mode_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 0, NOT]
call linac_normal_mode_to_f(z_lin, c_loc(F%lin))

end subroutine normal_modes_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad em_field_struct to a C++ CPP_em_field structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad em_field_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_em_field struct.
!-

subroutine em_field_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine em_field_to_c2 (C, z_e, z_b, z_de, z_db, z_phi, z_phi_b, z_a) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_e(*), z_b(*), z_de(*), z_db(*), z_phi, z_phi_b, z_a(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(em_field_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call em_field_to_c2 (C, fvec2vec(F%e, 3), fvec2vec(F%b, 3), mat2vec(F%de, 3*3), mat2vec(F%db, &
    3*3), F%phi, F%phi_b, fvec2vec(F%a, 3))

end subroutine em_field_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine em_field_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_em_field structure to a Bmad em_field_struct structure.
! This routine is called by em_field_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the em_field_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad em_field_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine em_field_to_f2 (Fp, z_e, z_b, z_de, z_db, z_phi, z_phi_b, z_a) bind(c)


implicit none

type(c_ptr), value :: Fp
type(em_field_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_e(*), z_b(*), z_de(*), z_db(*), z_phi, z_phi_b, z_a(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 1, NOT]
F%e = z_e(1:3)
!! f_side.to_f2_trans[real, 1, NOT]
F%b = z_b(1:3)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_de, F%de)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_db, F%db)
!! f_side.to_f2_trans[real, 0, NOT]
F%phi = z_phi
!! f_side.to_f2_trans[real, 0, NOT]
F%phi_b = z_phi_b
!! f_side.to_f2_trans[real, 1, NOT]
F%a = z_a(1:3)

end subroutine em_field_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine strong_beam_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad strong_beam_struct to a C++ CPP_strong_beam structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad strong_beam_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_strong_beam struct.
!-

subroutine strong_beam_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine strong_beam_to_c2 (C, z_ix_slice, z_x_center, z_y_center, z_x_sigma, z_y_sigma, &
      z_dx, z_dy) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    integer(c_int) :: z_ix_slice
    real(c_double) :: z_x_center, z_y_center, z_x_sigma, z_y_sigma, z_dx, z_dy
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(strong_beam_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call strong_beam_to_c2 (C, F%ix_slice, F%x_center, F%y_center, F%x_sigma, F%y_sigma, F%dx, &
    F%dy)

end subroutine strong_beam_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine strong_beam_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_strong_beam structure to a Bmad strong_beam_struct structure.
! This routine is called by strong_beam_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the strong_beam_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad strong_beam_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine strong_beam_to_f2 (Fp, z_ix_slice, z_x_center, z_y_center, z_x_sigma, z_y_sigma, &
    z_dx, z_dy) bind(c)


implicit none

type(c_ptr), value :: Fp
type(strong_beam_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
integer(c_int) :: z_ix_slice
real(c_double) :: z_x_center, z_y_center, z_x_sigma, z_y_sigma, z_dx, z_dy

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_slice = z_ix_slice
!! f_side.to_f2_trans[real, 0, NOT]
F%x_center = z_x_center
!! f_side.to_f2_trans[real, 0, NOT]
F%y_center = z_y_center
!! f_side.to_f2_trans[real, 0, NOT]
F%x_sigma = z_x_sigma
!! f_side.to_f2_trans[real, 0, NOT]
F%y_sigma = z_y_sigma
!! f_side.to_f2_trans[real, 0, NOT]
F%dx = z_dx
!! f_side.to_f2_trans[real, 0, NOT]
F%dy = z_dy

end subroutine strong_beam_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_point_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad track_point_struct to a C++ CPP_track_point structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad track_point_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_track_point struct.
!-

subroutine track_point_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine track_point_to_c2 (C, z_s_body, z_orb, z_field, z_strong_beam, z_vec0, z_mat6) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_s_body, z_vec0(*), z_mat6(*)
    type(c_ptr), value :: z_orb, z_field, z_strong_beam
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(track_point_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call track_point_to_c2 (C, F%s_body, c_loc(F%orb), c_loc(F%field), c_loc(F%strong_beam), &
    fvec2vec(F%vec0, 6), mat2vec(F%mat6, 6*6))

end subroutine track_point_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_point_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_track_point structure to a Bmad track_point_struct structure.
! This routine is called by track_point_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the track_point_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad track_point_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine track_point_to_f2 (Fp, z_s_body, z_orb, z_field, z_strong_beam, z_vec0, z_mat6) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(track_point_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_s_body, z_vec0(*), z_mat6(*)
type(c_ptr), value :: z_orb, z_field, z_strong_beam

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%s_body = z_s_body
!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_orb, c_loc(F%orb))
!! f_side.to_f2_trans[type, 0, NOT]
call em_field_to_f(z_field, c_loc(F%field))
!! f_side.to_f2_trans[type, 0, NOT]
call strong_beam_to_f(z_strong_beam, c_loc(F%strong_beam))
!! f_side.to_f2_trans[real, 1, NOT]
F%vec0 = z_vec0(1:6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_mat6, F%mat6)

end subroutine track_point_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad track_struct to a C++ CPP_track structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad track_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_track struct.
!-

subroutine track_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine track_to_c2 (C, z_pt, n1_pt, z_ds_save, z_n_pt, z_n_bad, z_n_ok) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_pt(*)
    integer(c_int), value :: n1_pt
    real(c_double) :: z_ds_save
    integer(c_int) :: z_n_pt, z_n_bad, z_n_ok
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(track_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_pt(:)
integer(c_int) :: n1_pt

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_pt = 0
if (allocated(F%pt)) then
  n1_pt = size(F%pt); lb1 = lbound(F%pt, 1) - 1
  allocate (z_pt(n1_pt))
  do jd1 = 1, n1_pt
    z_pt(jd1) = c_loc(F%pt(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call track_to_c2 (C, z_pt, n1_pt, F%ds_save, F%n_pt, F%n_bad, F%n_ok)

end subroutine track_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine track_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_track structure to a Bmad track_struct structure.
! This routine is called by track_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the track_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad track_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine track_to_f2 (Fp, z_pt, n1_pt, z_ds_save, z_n_pt, z_n_bad, z_n_ok) bind(c)


implicit none

type(c_ptr), value :: Fp
type(track_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr) :: z_pt(*)
integer(c_int), value :: n1_pt
real(c_double) :: z_ds_save
integer(c_int) :: z_n_pt, z_n_bad, z_n_ok

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_pt == 0) then
  if (allocated(F%pt)) deallocate(F%pt)
else
  if (allocated(F%pt)) then
    if (n1_pt == 0 .or. any(shape(F%pt) /= [n1_pt])) deallocate(F%pt)
    if (any(lbound(F%pt) /= 1)) deallocate(F%pt)
  endif
  if (.not. allocated(F%pt)) allocate(F%pt(1:n1_pt+1-1))
  do jd1 = 1, n1_pt
    call track_point_to_f (z_pt(jd1), c_loc(F%pt(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%ds_save = z_ds_save
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_pt = z_n_pt
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_bad = z_n_bad
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ok = z_n_ok

end subroutine track_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine space_charge_common_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad space_charge_common_struct to a C++ CPP_space_charge_common structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad space_charge_common_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_space_charge_common struct.
!-

subroutine space_charge_common_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine space_charge_common_to_c2 (C, z_ds_track_step, z_dt_track_step, &
      z_cathode_strength_cutoff, z_rel_tol_tracking, z_abs_tol_tracking, z_beam_chamber_height, &
      z_lsc_sigma_cutoff, z_particle_sigma_cutoff, z_space_charge_mesh_size, z_csr3d_mesh_size, &
      z_n_bin, z_particle_bin_span, z_n_shield_images, z_sc_min_in_bin, &
      z_lsc_kick_transverse_dependence, z_debug, z_diagnostic_output_file) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_ds_track_step, z_dt_track_step, z_cathode_strength_cutoff, z_rel_tol_tracking, z_abs_tol_tracking, z_beam_chamber_height, z_lsc_sigma_cutoff
    real(c_double) :: z_particle_sigma_cutoff
    integer(c_int) :: z_space_charge_mesh_size(*), z_csr3d_mesh_size(*), z_n_bin, z_particle_bin_span, z_n_shield_images, z_sc_min_in_bin
    logical(c_bool) :: z_lsc_kick_transverse_dependence, z_debug
    character(c_char) :: z_diagnostic_output_file(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(space_charge_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call space_charge_common_to_c2 (C, F%ds_track_step, F%dt_track_step, F%cathode_strength_cutoff, &
    F%rel_tol_tracking, F%abs_tol_tracking, F%beam_chamber_height, F%lsc_sigma_cutoff, &
    F%particle_sigma_cutoff, fvec2vec(F%space_charge_mesh_size, 3), fvec2vec(F%csr3d_mesh_size, &
    3), F%n_bin, F%particle_bin_span, F%n_shield_images, F%sc_min_in_bin, &
    c_logic(F%lsc_kick_transverse_dependence), c_logic(F%debug), trim(F%diagnostic_output_file) &
    // c_null_char)

end subroutine space_charge_common_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine space_charge_common_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_space_charge_common structure to a Bmad space_charge_common_struct structure.
! This routine is called by space_charge_common_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the space_charge_common_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad space_charge_common_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine space_charge_common_to_f2 (Fp, z_ds_track_step, z_dt_track_step, &
    z_cathode_strength_cutoff, z_rel_tol_tracking, z_abs_tol_tracking, z_beam_chamber_height, &
    z_lsc_sigma_cutoff, z_particle_sigma_cutoff, z_space_charge_mesh_size, z_csr3d_mesh_size, &
    z_n_bin, z_particle_bin_span, z_n_shield_images, z_sc_min_in_bin, &
    z_lsc_kick_transverse_dependence, z_debug, z_diagnostic_output_file) bind(c)


implicit none

type(c_ptr), value :: Fp
type(space_charge_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_ds_track_step, z_dt_track_step, z_cathode_strength_cutoff, z_rel_tol_tracking, z_abs_tol_tracking, z_beam_chamber_height, z_lsc_sigma_cutoff
real(c_double) :: z_particle_sigma_cutoff
integer(c_int) :: z_space_charge_mesh_size(*), z_csr3d_mesh_size(*), z_n_bin, z_particle_bin_span, z_n_shield_images, z_sc_min_in_bin
logical(c_bool) :: z_lsc_kick_transverse_dependence, z_debug
character(c_char) :: z_diagnostic_output_file(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%ds_track_step = z_ds_track_step
!! f_side.to_f2_trans[real, 0, NOT]
F%dt_track_step = z_dt_track_step
!! f_side.to_f2_trans[real, 0, NOT]
F%cathode_strength_cutoff = z_cathode_strength_cutoff
!! f_side.to_f2_trans[real, 0, NOT]
F%rel_tol_tracking = z_rel_tol_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%abs_tol_tracking = z_abs_tol_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%beam_chamber_height = z_beam_chamber_height
!! f_side.to_f2_trans[real, 0, NOT]
F%lsc_sigma_cutoff = z_lsc_sigma_cutoff
!! f_side.to_f2_trans[real, 0, NOT]
F%particle_sigma_cutoff = z_particle_sigma_cutoff
!! f_side.to_f2_trans[integer, 1, NOT]
F%space_charge_mesh_size = z_space_charge_mesh_size(1:3)
!! f_side.to_f2_trans[integer, 1, NOT]
F%csr3d_mesh_size = z_csr3d_mesh_size(1:3)
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_bin = z_n_bin
!! f_side.to_f2_trans[integer, 0, NOT]
F%particle_bin_span = z_particle_bin_span
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_shield_images = z_n_shield_images
!! f_side.to_f2_trans[integer, 0, NOT]
F%sc_min_in_bin = z_sc_min_in_bin
!! f_side.to_f2_trans[logical, 0, NOT]
F%lsc_kick_transverse_dependence = f_logic(z_lsc_kick_transverse_dependence)
!! f_side.to_f2_trans[logical, 0, NOT]
F%debug = f_logic(z_debug)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_diagnostic_output_file, F%diagnostic_output_file)

end subroutine space_charge_common_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bmad_common_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bmad_common_struct to a C++ CPP_bmad_common structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bmad_common_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bmad_common struct.
!-

subroutine bmad_common_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bmad_common_to_c2 (C, z_max_aperture_limit, z_d_orb, z_default_ds_step, &
      z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, &
      z_rel_tol_adaptive_tracking, z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, &
      z_min_ds_adaptive_tracking, z_fatal_ds_adaptive_tracking, z_autoscale_amp_abs_tol, &
      z_autoscale_amp_rel_tol, z_autoscale_phase_tol, z_electric_dipole_moment, &
      z_synch_rad_scale, z_sad_eps_scale, z_sad_amp_max, z_sad_n_div_max, z_taylor_order, &
      z_runge_kutta_order, z_default_integ_order, z_max_num_runge_kutta_step, &
      z_rf_phase_below_transition_ref, z_sr_wakes_on, z_lr_wakes_on, z_auto_bookkeeper, &
      z_high_energy_space_charge_on, z_csr_and_space_charge_on, z_spin_tracking_on, &
      z_spin_sokolov_ternov_flipping_on, z_radiation_damping_on, z_radiation_zero_average, &
      z_radiation_fluctuations_on, z_conserve_taylor_maps, z_absolute_time_tracking, &
      z_absolute_time_ref_shift, z_convert_to_kinetic_momentum, z_aperture_limit_on, z_debug) &
      bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_max_aperture_limit, z_d_orb(*), z_default_ds_step, z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, z_rel_tol_adaptive_tracking
    real(c_double) :: z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, z_min_ds_adaptive_tracking, z_fatal_ds_adaptive_tracking, z_autoscale_amp_abs_tol, z_autoscale_amp_rel_tol, z_autoscale_phase_tol
    real(c_double) :: z_electric_dipole_moment, z_synch_rad_scale, z_sad_eps_scale, z_sad_amp_max
    integer(c_int) :: z_sad_n_div_max, z_taylor_order, z_runge_kutta_order, z_default_integ_order, z_max_num_runge_kutta_step
    logical(c_bool) :: z_rf_phase_below_transition_ref, z_sr_wakes_on, z_lr_wakes_on, z_auto_bookkeeper, z_high_energy_space_charge_on, z_csr_and_space_charge_on, z_spin_tracking_on
    logical(c_bool) :: z_spin_sokolov_ternov_flipping_on, z_radiation_damping_on, z_radiation_zero_average, z_radiation_fluctuations_on, z_conserve_taylor_maps, z_absolute_time_tracking, z_absolute_time_ref_shift
    logical(c_bool) :: z_convert_to_kinetic_momentum, z_aperture_limit_on, z_debug
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bmad_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bmad_common_to_c2 (C, F%max_aperture_limit, fvec2vec(F%d_orb, 6), F%default_ds_step, &
    F%significant_length, F%rel_tol_tracking, F%abs_tol_tracking, F%rel_tol_adaptive_tracking, &
    F%abs_tol_adaptive_tracking, F%init_ds_adaptive_tracking, F%min_ds_adaptive_tracking, &
    F%fatal_ds_adaptive_tracking, F%autoscale_amp_abs_tol, F%autoscale_amp_rel_tol, &
    F%autoscale_phase_tol, F%electric_dipole_moment, F%synch_rad_scale, F%sad_eps_scale, &
    F%sad_amp_max, F%sad_n_div_max, F%taylor_order, F%runge_kutta_order, F%default_integ_order, &
    F%max_num_runge_kutta_step, c_logic(F%rf_phase_below_transition_ref), &
    c_logic(F%sr_wakes_on), c_logic(F%lr_wakes_on), c_logic(F%auto_bookkeeper), &
    c_logic(F%high_energy_space_charge_on), c_logic(F%csr_and_space_charge_on), &
    c_logic(F%spin_tracking_on), c_logic(F%spin_sokolov_ternov_flipping_on), &
    c_logic(F%radiation_damping_on), c_logic(F%radiation_zero_average), &
    c_logic(F%radiation_fluctuations_on), c_logic(F%conserve_taylor_maps), &
    c_logic(F%absolute_time_tracking), c_logic(F%absolute_time_ref_shift), &
    c_logic(F%convert_to_kinetic_momentum), c_logic(F%aperture_limit_on), c_logic(F%debug))

end subroutine bmad_common_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bmad_common_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bmad_common structure to a Bmad bmad_common_struct structure.
! This routine is called by bmad_common_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bmad_common_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bmad_common_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bmad_common_to_f2 (Fp, z_max_aperture_limit, z_d_orb, z_default_ds_step, &
    z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, z_rel_tol_adaptive_tracking, &
    z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, z_min_ds_adaptive_tracking, &
    z_fatal_ds_adaptive_tracking, z_autoscale_amp_abs_tol, z_autoscale_amp_rel_tol, &
    z_autoscale_phase_tol, z_electric_dipole_moment, z_synch_rad_scale, z_sad_eps_scale, &
    z_sad_amp_max, z_sad_n_div_max, z_taylor_order, z_runge_kutta_order, z_default_integ_order, &
    z_max_num_runge_kutta_step, z_rf_phase_below_transition_ref, z_sr_wakes_on, z_lr_wakes_on, &
    z_auto_bookkeeper, z_high_energy_space_charge_on, z_csr_and_space_charge_on, &
    z_spin_tracking_on, z_spin_sokolov_ternov_flipping_on, z_radiation_damping_on, &
    z_radiation_zero_average, z_radiation_fluctuations_on, z_conserve_taylor_maps, &
    z_absolute_time_tracking, z_absolute_time_ref_shift, z_convert_to_kinetic_momentum, &
    z_aperture_limit_on, z_debug) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bmad_common_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_max_aperture_limit, z_d_orb(*), z_default_ds_step, z_significant_length, z_rel_tol_tracking, z_abs_tol_tracking, z_rel_tol_adaptive_tracking
real(c_double) :: z_abs_tol_adaptive_tracking, z_init_ds_adaptive_tracking, z_min_ds_adaptive_tracking, z_fatal_ds_adaptive_tracking, z_autoscale_amp_abs_tol, z_autoscale_amp_rel_tol, z_autoscale_phase_tol
real(c_double) :: z_electric_dipole_moment, z_synch_rad_scale, z_sad_eps_scale, z_sad_amp_max
integer(c_int) :: z_sad_n_div_max, z_taylor_order, z_runge_kutta_order, z_default_integ_order, z_max_num_runge_kutta_step
logical(c_bool) :: z_rf_phase_below_transition_ref, z_sr_wakes_on, z_lr_wakes_on, z_auto_bookkeeper, z_high_energy_space_charge_on, z_csr_and_space_charge_on, z_spin_tracking_on
logical(c_bool) :: z_spin_sokolov_ternov_flipping_on, z_radiation_damping_on, z_radiation_zero_average, z_radiation_fluctuations_on, z_conserve_taylor_maps, z_absolute_time_tracking, z_absolute_time_ref_shift
logical(c_bool) :: z_convert_to_kinetic_momentum, z_aperture_limit_on, z_debug

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%max_aperture_limit = z_max_aperture_limit
!! f_side.to_f2_trans[real, 1, NOT]
F%d_orb = z_d_orb(1:6)
!! f_side.to_f2_trans[real, 0, NOT]
F%default_ds_step = z_default_ds_step
!! f_side.to_f2_trans[real, 0, NOT]
F%significant_length = z_significant_length
!! f_side.to_f2_trans[real, 0, NOT]
F%rel_tol_tracking = z_rel_tol_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%abs_tol_tracking = z_abs_tol_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%rel_tol_adaptive_tracking = z_rel_tol_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%abs_tol_adaptive_tracking = z_abs_tol_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%init_ds_adaptive_tracking = z_init_ds_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%min_ds_adaptive_tracking = z_min_ds_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%fatal_ds_adaptive_tracking = z_fatal_ds_adaptive_tracking
!! f_side.to_f2_trans[real, 0, NOT]
F%autoscale_amp_abs_tol = z_autoscale_amp_abs_tol
!! f_side.to_f2_trans[real, 0, NOT]
F%autoscale_amp_rel_tol = z_autoscale_amp_rel_tol
!! f_side.to_f2_trans[real, 0, NOT]
F%autoscale_phase_tol = z_autoscale_phase_tol
!! f_side.to_f2_trans[real, 0, NOT]
F%electric_dipole_moment = z_electric_dipole_moment
!! f_side.to_f2_trans[real, 0, NOT]
F%synch_rad_scale = z_synch_rad_scale
!! f_side.to_f2_trans[real, 0, NOT]
F%sad_eps_scale = z_sad_eps_scale
!! f_side.to_f2_trans[real, 0, NOT]
F%sad_amp_max = z_sad_amp_max
!! f_side.to_f2_trans[integer, 0, NOT]
F%sad_n_div_max = z_sad_n_div_max
!! f_side.to_f2_trans[integer, 0, NOT]
F%taylor_order = z_taylor_order
!! f_side.to_f2_trans[integer, 0, NOT]
F%runge_kutta_order = z_runge_kutta_order
!! f_side.to_f2_trans[integer, 0, NOT]
F%default_integ_order = z_default_integ_order
!! f_side.to_f2_trans[integer, 0, NOT]
F%max_num_runge_kutta_step = z_max_num_runge_kutta_step
!! f_side.to_f2_trans[logical, 0, NOT]
F%rf_phase_below_transition_ref = f_logic(z_rf_phase_below_transition_ref)
!! f_side.to_f2_trans[logical, 0, NOT]
F%sr_wakes_on = f_logic(z_sr_wakes_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%lr_wakes_on = f_logic(z_lr_wakes_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%auto_bookkeeper = f_logic(z_auto_bookkeeper)
!! f_side.to_f2_trans[logical, 0, NOT]
F%high_energy_space_charge_on = f_logic(z_high_energy_space_charge_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%csr_and_space_charge_on = f_logic(z_csr_and_space_charge_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%spin_tracking_on = f_logic(z_spin_tracking_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%spin_sokolov_ternov_flipping_on = f_logic(z_spin_sokolov_ternov_flipping_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%radiation_damping_on = f_logic(z_radiation_damping_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%radiation_zero_average = f_logic(z_radiation_zero_average)
!! f_side.to_f2_trans[logical, 0, NOT]
F%radiation_fluctuations_on = f_logic(z_radiation_fluctuations_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%conserve_taylor_maps = f_logic(z_conserve_taylor_maps)
!! f_side.to_f2_trans[logical, 0, NOT]
F%absolute_time_tracking = f_logic(z_absolute_time_tracking)
!! f_side.to_f2_trans[logical, 0, NOT]
F%absolute_time_ref_shift = f_logic(z_absolute_time_ref_shift)
!! f_side.to_f2_trans[logical, 0, NOT]
F%convert_to_kinetic_momentum = f_logic(z_convert_to_kinetic_momentum)
!! f_side.to_f2_trans[logical, 0, NOT]
F%aperture_limit_on = f_logic(z_aperture_limit_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%debug = f_logic(z_debug)

end subroutine bmad_common_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int1_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_int1_struct to a C++ CPP_rad_int1 structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_int1_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_int1 struct.
!-

subroutine rad_int1_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_int1_to_c2 (C, z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z, z_i5a, z_i5b, &
      z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6, z_lin_norm_emit_a, &
      z_lin_norm_emit_b, z_lin_sig_e, z_n_steps) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z
    real(c_double) :: z_i5a, z_i5b, z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6
    real(c_double) :: z_lin_norm_emit_a, z_lin_norm_emit_b, z_lin_sig_e, z_n_steps
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_int1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call rad_int1_to_c2 (C, F%i0, F%i1, F%i2, F%i3, F%i4a, F%i4b, F%i4z, F%i5a, F%i5b, F%i6b, &
    F%lin_i2_e4, F%lin_i3_e7, F%lin_i5a_e6, F%lin_i5b_e6, F%lin_norm_emit_a, F%lin_norm_emit_b, &
    F%lin_sig_e, F%n_steps)

end subroutine rad_int1_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int1_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_int1 structure to a Bmad rad_int1_struct structure.
! This routine is called by rad_int1_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_int1_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_int1_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_int1_to_f2 (Fp, z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z, z_i5a, z_i5b, &
    z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6, z_lin_norm_emit_a, &
    z_lin_norm_emit_b, z_lin_sig_e, z_n_steps) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_int1_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_i0, z_i1, z_i2, z_i3, z_i4a, z_i4b, z_i4z
real(c_double) :: z_i5a, z_i5b, z_i6b, z_lin_i2_e4, z_lin_i3_e7, z_lin_i5a_e6, z_lin_i5b_e6
real(c_double) :: z_lin_norm_emit_a, z_lin_norm_emit_b, z_lin_sig_e, z_n_steps

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%i0 = z_i0
!! f_side.to_f2_trans[real, 0, NOT]
F%i1 = z_i1
!! f_side.to_f2_trans[real, 0, NOT]
F%i2 = z_i2
!! f_side.to_f2_trans[real, 0, NOT]
F%i3 = z_i3
!! f_side.to_f2_trans[real, 0, NOT]
F%i4a = z_i4a
!! f_side.to_f2_trans[real, 0, NOT]
F%i4b = z_i4b
!! f_side.to_f2_trans[real, 0, NOT]
F%i4z = z_i4z
!! f_side.to_f2_trans[real, 0, NOT]
F%i5a = z_i5a
!! f_side.to_f2_trans[real, 0, NOT]
F%i5b = z_i5b
!! f_side.to_f2_trans[real, 0, NOT]
F%i6b = z_i6b
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i2_e4 = z_lin_i2_e4
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i3_e7 = z_lin_i3_e7
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i5a_e6 = z_lin_i5a_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_i5b_e6 = z_lin_i5b_e6
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_norm_emit_a = z_lin_norm_emit_a
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_norm_emit_b = z_lin_norm_emit_b
!! f_side.to_f2_trans[real, 0, NOT]
F%lin_sig_e = z_lin_sig_e
!! f_side.to_f2_trans[real, 0, NOT]
F%n_steps = z_n_steps

end subroutine rad_int1_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_branch_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_int_branch_struct to a C++ CPP_rad_int_branch structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_int_branch_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_int_branch struct.
!-

subroutine rad_int_branch_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_int_branch_to_c2 (C, z_ele, n1_ele) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_ele(*)
    integer(c_int), value :: n1_ele
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_int_branch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_ele(:)
integer(c_int) :: n1_ele

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_ele = 0
if (allocated(F%ele)) then
  n1_ele = size(F%ele); lb1 = lbound(F%ele, 1) - 1
  allocate (z_ele(n1_ele))
  do jd1 = 1, n1_ele
    z_ele(jd1) = c_loc(F%ele(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call rad_int_branch_to_c2 (C, z_ele, n1_ele)

end subroutine rad_int_branch_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_branch_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_int_branch structure to a Bmad rad_int_branch_struct structure.
! This routine is called by rad_int_branch_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_int_branch_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_int_branch_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_int_branch_to_f2 (Fp, z_ele, n1_ele) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_int_branch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr) :: z_ele(*)
integer(c_int), value :: n1_ele

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_ele == 0) then
  if (allocated(F%ele)) deallocate(F%ele)
else
  if (allocated(F%ele)) then
    if (n1_ele == 0 .or. any(shape(F%ele) /= [n1_ele])) deallocate(F%ele)
    if (any(lbound(F%ele) /= 1)) deallocate(F%ele)
  endif
  if (.not. allocated(F%ele)) allocate(F%ele(1:n1_ele+1-1))
  do jd1 = 1, n1_ele
    call rad_int1_to_f (z_ele(jd1), c_loc(F%ele(jd1+1-1)))
  enddo
endif


end subroutine rad_int_branch_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_all_ele_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad rad_int_all_ele_struct to a C++ CPP_rad_int_all_ele structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad rad_int_all_ele_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_rad_int_all_ele struct.
!-

subroutine rad_int_all_ele_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine rad_int_all_ele_to_c2 (C, z_branch, n1_branch) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_branch(*)
    integer(c_int), value :: n1_branch
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(rad_int_all_ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_branch(:)
integer(c_int) :: n1_branch

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_branch = 0
if (allocated(F%branch)) then
  n1_branch = size(F%branch); lb1 = lbound(F%branch, 1) - 1
  allocate (z_branch(n1_branch))
  do jd1 = 1, n1_branch
    z_branch(jd1) = c_loc(F%branch(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call rad_int_all_ele_to_c2 (C, z_branch, n1_branch)

end subroutine rad_int_all_ele_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine rad_int_all_ele_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_rad_int_all_ele structure to a Bmad rad_int_all_ele_struct structure.
! This routine is called by rad_int_all_ele_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the rad_int_all_ele_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad rad_int_all_ele_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine rad_int_all_ele_to_f2 (Fp, z_branch, n1_branch) bind(c)


implicit none

type(c_ptr), value :: Fp
type(rad_int_all_ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr) :: z_branch(*)
integer(c_int), value :: n1_branch

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_branch == 0) then
  if (allocated(F%branch)) deallocate(F%branch)
else
  if (allocated(F%branch)) then
    if (n1_branch == 0 .or. any(shape(F%branch) /= [n1_branch])) deallocate(F%branch)
    if (any(lbound(F%branch) /= 1)) deallocate(F%branch)
  endif
  if (.not. allocated(F%branch)) allocate(F%branch(1:n1_branch+1-1))
  do jd1 = 1, n1_branch
    call rad_int_branch_to_f (z_branch(jd1), c_loc(F%branch(jd1+1-1)))
  enddo
endif


end subroutine rad_int_all_ele_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ele_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad ele_struct to a C++ CPP_ele structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad ele_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_ele struct.
!-

subroutine ele_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine ele_to_c2 (C, z_name, z_type, z_alias, z_component_name, z_descrip, n_descrip, &
      z_a, z_b, z_z, z_x, z_y, z_ac_kick, n_ac_kick, z_bookkeeping_state, z_control, n_control, &
      z_floor, z_high_energy_space_charge, n_high_energy_space_charge, z_mode3, n_mode3, &
      z_photon, n_photon, z_rad_map, n_rad_map, z_taylor, z_spin_taylor_ref_orb_in, &
      z_spin_taylor, z_wake, n_wake, z_wall3d, n1_wall3d, z_cartesian_map, n1_cartesian_map, &
      z_cylindrical_map, n1_cylindrical_map, z_gen_grad_map, n1_gen_grad_map, z_grid_field, &
      n1_grid_field, z_map_ref_orb_in, z_map_ref_orb_out, z_time_ref_orb_in, &
      z_time_ref_orb_out, z_value, z_old_value, z_spin_q, z_vec0, z_mat6, z_c_mat, z_gamma_c, &
      z_s_start, z_s, z_ref_time, z_a_pole, n1_a_pole, z_b_pole, n1_b_pole, z_a_pole_elec, &
      n1_a_pole_elec, z_b_pole_elec, n1_b_pole_elec, z_custom, n1_custom, z_r, n1_r, n2_r, &
      n3_r, z_key, z_sub_key, z_ix_ele, z_ix_branch, z_lord_status, z_n_slave, z_n_slave_field, &
      z_ix1_slave, z_slave_status, z_n_lord, z_n_lord_field, z_n_lord_ramper, z_ic1_lord, &
      z_ix_pointer, z_ixx, z_iyy, z_izz, z_mat6_calc_method, z_tracking_method, &
      z_spin_tracking_method, z_csr_method, z_space_charge_method, z_ptc_integration_type, &
      z_field_calc, z_aperture_at, z_aperture_type, z_ref_species, z_orientation, &
      z_symplectify, z_mode_flip, z_multipoles_on, z_scale_multipoles, &
      z_taylor_map_includes_offsets, z_field_master, z_is_on, z_logic, z_bmad_logic, z_select, &
      z_offset_moves_aperture) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_name(*), z_type(*), z_alias(*), z_component_name(*), z_descrip(*)
    integer(c_int), value :: n_descrip, n_ac_kick, n_control, n_high_energy_space_charge, n_mode3, n_photon, n_rad_map
    integer(c_int), value :: n_wake, n1_wall3d, n1_cartesian_map, n1_cylindrical_map, n1_gen_grad_map, n1_grid_field, n1_a_pole
    integer(c_int), value :: n1_b_pole, n1_a_pole_elec, n1_b_pole_elec, n1_custom, n1_r, n2_r, n3_r
    type(c_ptr), value :: z_a, z_b, z_z, z_x, z_y, z_ac_kick, z_bookkeeping_state
    type(c_ptr), value :: z_control, z_floor, z_high_energy_space_charge, z_mode3, z_photon, z_rad_map, z_wake
    type(c_ptr), value :: z_map_ref_orb_in, z_map_ref_orb_out, z_time_ref_orb_in, z_time_ref_orb_out
    type(c_ptr) :: z_taylor(*), z_spin_taylor(*), z_wall3d(*), z_cartesian_map(*), z_cylindrical_map(*), z_gen_grad_map(*), z_grid_field(*)
    real(c_double) :: z_spin_taylor_ref_orb_in(*), z_value(*), z_old_value(*), z_spin_q(*), z_vec0(*), z_mat6(*), z_c_mat(*)
    real(c_double) :: z_gamma_c, z_s_start, z_s, z_ref_time, z_a_pole(*), z_b_pole(*), z_a_pole_elec(*)
    real(c_double) :: z_b_pole_elec(*), z_custom(*), z_r(*)
    integer(c_int) :: z_key, z_sub_key, z_ix_ele, z_ix_branch, z_lord_status, z_n_slave, z_n_slave_field
    integer(c_int) :: z_ix1_slave, z_slave_status, z_n_lord, z_n_lord_field, z_n_lord_ramper, z_ic1_lord, z_ix_pointer
    integer(c_int) :: z_ixx, z_iyy, z_izz, z_mat6_calc_method, z_tracking_method, z_spin_tracking_method, z_csr_method
    integer(c_int) :: z_space_charge_method, z_ptc_integration_type, z_field_calc, z_aperture_at, z_aperture_type, z_ref_species, z_orientation
    logical(c_bool) :: z_symplectify, z_mode_flip, z_multipoles_on, z_scale_multipoles, z_taylor_map_includes_offsets, z_field_master, z_is_on
    logical(c_bool) :: z_logic, z_bmad_logic, z_select, z_offset_moves_aperture
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
character(200+1), target :: f_descrip
integer(c_int) :: n_descrip
integer(c_int) :: n_ac_kick
integer(c_int) :: n_control
integer(c_int) :: n_high_energy_space_charge
integer(c_int) :: n_mode3
integer(c_int) :: n_photon
integer(c_int) :: n_rad_map
type(c_ptr) :: z_taylor(6)
type(c_ptr) :: z_spin_taylor(4)
integer(c_int) :: n_wake
type(c_ptr), allocatable :: z_wall3d(:)
integer(c_int) :: n1_wall3d
type(c_ptr), allocatable :: z_cartesian_map(:)
integer(c_int) :: n1_cartesian_map
type(c_ptr), allocatable :: z_cylindrical_map(:)
integer(c_int) :: n1_cylindrical_map
type(c_ptr), allocatable :: z_gen_grad_map(:)
integer(c_int) :: n1_gen_grad_map
type(c_ptr), allocatable :: z_grid_field(:)
integer(c_int) :: n1_grid_field
integer(c_int) :: n1_a_pole
integer(c_int) :: n1_b_pole
integer(c_int) :: n1_a_pole_elec
integer(c_int) :: n1_b_pole_elec
integer(c_int) :: n1_custom
integer(c_int) :: n1_r
integer(c_int) :: n2_r
integer(c_int) :: n3_r

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[character, 0, PTR]
n_descrip = 0
if (associated(F%descrip)) then
  n_descrip = 1
  f_descrip = trim(F%descrip) // c_null_char 
endif
!! f_side.to_c_trans[type, 0, PTR]
n_ac_kick = 0
if (associated(F%ac_kick)) n_ac_kick = 1
!! f_side.to_c_trans[type, 0, PTR]
n_control = 0
if (associated(F%control)) n_control = 1
!! f_side.to_c_trans[type, 0, PTR]
n_high_energy_space_charge = 0
if (associated(F%high_energy_space_charge)) n_high_energy_space_charge = 1
!! f_side.to_c_trans[type, 0, PTR]
n_mode3 = 0
if (associated(F%mode3)) n_mode3 = 1
!! f_side.to_c_trans[type, 0, PTR]
n_photon = 0
if (associated(F%photon)) n_photon = 1
!! f_side.to_c_trans[type, 0, PTR]
n_rad_map = 0
if (associated(F%rad_map)) n_rad_map = 1
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%taylor,1); lb1 = lbound(F%taylor,1) - 1
  z_taylor(jd1) = c_loc(F%taylor(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 1, NOT]
do jd1 = 1, size(F%spin_taylor,1); lb1 = lbound(F%spin_taylor,1) - 1
  z_spin_taylor(jd1) = c_loc(F%spin_taylor(jd1+lb1))
enddo
!! f_side.to_c_trans[type, 0, PTR]
n_wake = 0
if (associated(F%wake)) n_wake = 1
!! f_side.to_c_trans[type, 1, PTR]
 n1_wall3d = 0
if (associated(F%wall3d)) then
  n1_wall3d = size(F%wall3d); lb1 = lbound(F%wall3d, 1) - 1
  allocate (z_wall3d(n1_wall3d))
  do jd1 = 1, n1_wall3d
    z_wall3d(jd1) = c_loc(F%wall3d(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_cartesian_map = 0
if (associated(F%cartesian_map)) then
  n1_cartesian_map = size(F%cartesian_map); lb1 = lbound(F%cartesian_map, 1) - 1
  allocate (z_cartesian_map(n1_cartesian_map))
  do jd1 = 1, n1_cartesian_map
    z_cartesian_map(jd1) = c_loc(F%cartesian_map(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_cylindrical_map = 0
if (associated(F%cylindrical_map)) then
  n1_cylindrical_map = size(F%cylindrical_map); lb1 = lbound(F%cylindrical_map, 1) - 1
  allocate (z_cylindrical_map(n1_cylindrical_map))
  do jd1 = 1, n1_cylindrical_map
    z_cylindrical_map(jd1) = c_loc(F%cylindrical_map(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_gen_grad_map = 0
if (associated(F%gen_grad_map)) then
  n1_gen_grad_map = size(F%gen_grad_map); lb1 = lbound(F%gen_grad_map, 1) - 1
  allocate (z_gen_grad_map(n1_gen_grad_map))
  do jd1 = 1, n1_gen_grad_map
    z_gen_grad_map(jd1) = c_loc(F%gen_grad_map(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_grid_field = 0
if (associated(F%grid_field)) then
  n1_grid_field = size(F%grid_field); lb1 = lbound(F%grid_field, 1) - 1
  allocate (z_grid_field(n1_grid_field))
  do jd1 = 1, n1_grid_field
    z_grid_field(jd1) = c_loc(F%grid_field(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[real, 1, PTR]
n1_a_pole = 0
if (associated(F%a_pole)) then
  n1_a_pole = size(F%a_pole, 1)
endif
!! f_side.to_c_trans[real, 1, PTR]
n1_b_pole = 0
if (associated(F%b_pole)) then
  n1_b_pole = size(F%b_pole, 1)
endif
!! f_side.to_c_trans[real, 1, PTR]
n1_a_pole_elec = 0
if (associated(F%a_pole_elec)) then
  n1_a_pole_elec = size(F%a_pole_elec, 1)
endif
!! f_side.to_c_trans[real, 1, PTR]
n1_b_pole_elec = 0
if (associated(F%b_pole_elec)) then
  n1_b_pole_elec = size(F%b_pole_elec, 1)
endif
!! f_side.to_c_trans[real, 1, PTR]
n1_custom = 0
if (associated(F%custom)) then
  n1_custom = size(F%custom, 1)
endif
!! f_side.to_c_trans[real, 3, PTR]
if (associated(F%r)) then
  n1_r = size(F%r, 1)
  n2_r = size(F%r, 2)
  n3_r = size(F%r, 3)
else
  n1_r = 0; n2_r = 0; n3_r = 0
endif

!! f_side.to_c2_call
call ele_to_c2 (C, trim(F%name) // c_null_char, trim(F%type) // c_null_char, trim(F%alias) // &
    c_null_char, trim(F%component_name) // c_null_char, f_descrip, n_descrip, c_loc(F%a), &
    c_loc(F%b), c_loc(F%z), c_loc(F%x), c_loc(F%y), c_loc(F%ac_kick), n_ac_kick, &
    c_loc(F%bookkeeping_state), c_loc(F%control), n_control, c_loc(F%floor), &
    c_loc(F%high_energy_space_charge), n_high_energy_space_charge, c_loc(F%mode3), n_mode3, &
    c_loc(F%photon), n_photon, c_loc(F%rad_map), n_rad_map, z_taylor, &
    fvec2vec(F%spin_taylor_ref_orb_in, 6), z_spin_taylor, c_loc(F%wake), n_wake, z_wall3d, &
    n1_wall3d, z_cartesian_map, n1_cartesian_map, z_cylindrical_map, n1_cylindrical_map, &
    z_gen_grad_map, n1_gen_grad_map, z_grid_field, n1_grid_field, c_loc(F%map_ref_orb_in), &
    c_loc(F%map_ref_orb_out), c_loc(F%time_ref_orb_in), c_loc(F%time_ref_orb_out), &
    fvec2vec(F%value, num_ele_attrib$), fvec2vec(F%old_value, num_ele_attrib$), &
    mat2vec(F%spin_q, 4*7), fvec2vec(F%vec0, 6), mat2vec(F%mat6, 6*6), mat2vec(F%c_mat, 2*2), &
    F%gamma_c, F%s_start, F%s, F%ref_time, fvec2vec(F%a_pole, n1_a_pole), n1_a_pole, &
    fvec2vec(F%b_pole, n1_b_pole), n1_b_pole, fvec2vec(F%a_pole_elec, n1_a_pole_elec), &
    n1_a_pole_elec, fvec2vec(F%b_pole_elec, n1_b_pole_elec), n1_b_pole_elec, fvec2vec(F%custom, &
    n1_custom), n1_custom, tensor2vec(F%r, n1_r*n2_r*n3_r), n1_r, n2_r, n3_r, F%key, F%sub_key, &
    F%ix_ele, F%ix_branch, F%lord_status, F%n_slave, F%n_slave_field, F%ix1_slave, &
    F%slave_status, F%n_lord, F%n_lord_field, F%n_lord_ramper, F%ic1_lord, F%ix_pointer, F%ixx, &
    F%iyy, F%izz, F%mat6_calc_method, F%tracking_method, F%spin_tracking_method, F%csr_method, &
    F%space_charge_method, F%ptc_integration_type, F%field_calc, F%aperture_at, &
    F%aperture_type, F%ref_species, F%orientation, c_logic(F%symplectify), &
    c_logic(F%mode_flip), c_logic(F%multipoles_on), c_logic(F%scale_multipoles), &
    c_logic(F%taylor_map_includes_offsets), c_logic(F%field_master), c_logic(F%is_on), &
    c_logic(F%logic), c_logic(F%bmad_logic), c_logic(F%select), &
    c_logic(F%offset_moves_aperture))

end subroutine ele_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine ele_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_ele structure to a Bmad ele_struct structure.
! This routine is called by ele_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the ele_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad ele_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine ele_to_f2 (Fp, z_name, z_type, z_alias, z_component_name, z_descrip, n_descrip, z_a, &
    z_b, z_z, z_x, z_y, z_ac_kick, n_ac_kick, z_bookkeeping_state, z_control, n_control, &
    z_floor, z_high_energy_space_charge, n_high_energy_space_charge, z_mode3, n_mode3, &
    z_photon, n_photon, z_rad_map, n_rad_map, z_taylor, z_spin_taylor_ref_orb_in, &
    z_spin_taylor, z_wake, n_wake, z_wall3d, n1_wall3d, z_cartesian_map, n1_cartesian_map, &
    z_cylindrical_map, n1_cylindrical_map, z_gen_grad_map, n1_gen_grad_map, z_grid_field, &
    n1_grid_field, z_map_ref_orb_in, z_map_ref_orb_out, z_time_ref_orb_in, z_time_ref_orb_out, &
    z_value, z_old_value, z_spin_q, z_vec0, z_mat6, z_c_mat, z_gamma_c, z_s_start, z_s, &
    z_ref_time, z_a_pole, n1_a_pole, z_b_pole, n1_b_pole, z_a_pole_elec, n1_a_pole_elec, &
    z_b_pole_elec, n1_b_pole_elec, z_custom, n1_custom, z_r, n1_r, n2_r, n3_r, z_key, &
    z_sub_key, z_ix_ele, z_ix_branch, z_lord_status, z_n_slave, z_n_slave_field, z_ix1_slave, &
    z_slave_status, z_n_lord, z_n_lord_field, z_n_lord_ramper, z_ic1_lord, z_ix_pointer, z_ixx, &
    z_iyy, z_izz, z_mat6_calc_method, z_tracking_method, z_spin_tracking_method, z_csr_method, &
    z_space_charge_method, z_ptc_integration_type, z_field_calc, z_aperture_at, &
    z_aperture_type, z_ref_species, z_orientation, z_symplectify, z_mode_flip, z_multipoles_on, &
    z_scale_multipoles, z_taylor_map_includes_offsets, z_field_master, z_is_on, z_logic, &
    z_bmad_logic, z_select, z_offset_moves_aperture) bind(c)


implicit none

type(c_ptr), value :: Fp
type(ele_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_name(*), z_type(*), z_alias(*), z_component_name(*), z_descrip(*)
integer(c_int), pointer :: f_descrip
integer(c_int), value :: n_descrip, n_ac_kick, n_control, n_high_energy_space_charge, n_mode3, n_photon, n_rad_map
integer(c_int), value :: n_wake, n1_wall3d, n1_cartesian_map, n1_cylindrical_map, n1_gen_grad_map, n1_grid_field, n1_a_pole
integer(c_int), value :: n1_b_pole, n1_a_pole_elec, n1_b_pole_elec, n1_custom, n1_r, n2_r, n3_r
type(c_ptr), value :: z_a, z_b, z_z, z_x, z_y, z_ac_kick, z_bookkeeping_state
type(c_ptr), value :: z_control, z_floor, z_high_energy_space_charge, z_mode3, z_photon, z_rad_map, z_wake
type(c_ptr), value :: z_map_ref_orb_in, z_map_ref_orb_out, z_time_ref_orb_in, z_time_ref_orb_out, z_a_pole, z_b_pole, z_a_pole_elec
type(c_ptr), value :: z_b_pole_elec, z_custom, z_r
type(ac_kicker_struct), pointer :: f_ac_kick
type(controller_struct), pointer :: f_control
type(high_energy_space_charge_struct), pointer :: f_high_energy_space_charge
type(mode3_struct), pointer :: f_mode3
type(photon_element_struct), pointer :: f_photon
type(rad_map_ele_struct), pointer :: f_rad_map
type(c_ptr) :: z_taylor(*), z_spin_taylor(*), z_wall3d(*), z_cartesian_map(*), z_cylindrical_map(*), z_gen_grad_map(*), z_grid_field(*)
real(c_double) :: z_spin_taylor_ref_orb_in(*), z_value(*), z_old_value(*), z_spin_q(*), z_vec0(*), z_mat6(*), z_c_mat(*)
real(c_double) :: z_gamma_c, z_s_start, z_s, z_ref_time
type(wake_struct), pointer :: f_wake
real(c_double), pointer :: f_a_pole(:), f_b_pole(:), f_a_pole_elec(:), f_b_pole_elec(:), f_custom(:), f_r(:)
integer(c_int) :: z_key, z_sub_key, z_ix_ele, z_ix_branch, z_lord_status, z_n_slave, z_n_slave_field
integer(c_int) :: z_ix1_slave, z_slave_status, z_n_lord, z_n_lord_field, z_n_lord_ramper, z_ic1_lord, z_ix_pointer
integer(c_int) :: z_ixx, z_iyy, z_izz, z_mat6_calc_method, z_tracking_method, z_spin_tracking_method, z_csr_method
integer(c_int) :: z_space_charge_method, z_ptc_integration_type, z_field_calc, z_aperture_at, z_aperture_type, z_ref_species, z_orientation
logical(c_bool) :: z_symplectify, z_mode_flip, z_multipoles_on, z_scale_multipoles, z_taylor_map_includes_offsets, z_field_master, z_is_on
logical(c_bool) :: z_logic, z_bmad_logic, z_select, z_offset_moves_aperture

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_type, F%type)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_alias, F%alias)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_component_name, F%component_name)
!! f_side.to_f2_trans[character, 0, PTR]
if (n_descrip == 0) then
  if (associated(F%descrip)) deallocate(F%descrip)
else
  if (.not. associated(F%descrip)) allocate(F%descrip)
  call to_f_str(z_descrip, F%descrip)
endif

!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 0, NOT]
call xy_disp_to_f(z_x, c_loc(F%x))
!! f_side.to_f2_trans[type, 0, NOT]
call xy_disp_to_f(z_y, c_loc(F%y))
!! f_side.to_f2_trans[type, 0, PTR]
if (n_ac_kick == 0) then
  if (associated(F%ac_kick)) deallocate(F%ac_kick)
else
  if (.not. associated(F%ac_kick)) allocate(F%ac_kick)
  call ac_kicker_to_f (z_ac_kick, c_loc(F%ac_kick))
endif

!! f_side.to_f2_trans[type, 0, NOT]
call bookkeeping_state_to_f(z_bookkeeping_state, c_loc(F%bookkeeping_state))
!! f_side.to_f2_trans[type, 0, PTR]
if (n_control == 0) then
  if (associated(F%control)) deallocate(F%control)
else
  if (.not. associated(F%control)) allocate(F%control)
  call controller_to_f (z_control, c_loc(F%control))
endif

!! f_side.to_f2_trans[type, 0, NOT]
call floor_position_to_f(z_floor, c_loc(F%floor))
!! f_side.to_f2_trans[type, 0, PTR]
if (n_high_energy_space_charge == 0) then
  if (associated(F%high_energy_space_charge)) deallocate(F%high_energy_space_charge)
else
  if (.not. associated(F%high_energy_space_charge)) allocate(F%high_energy_space_charge)
  call high_energy_space_charge_to_f (z_high_energy_space_charge, c_loc(F%high_energy_space_charge))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_mode3 == 0) then
  if (associated(F%mode3)) deallocate(F%mode3)
else
  if (.not. associated(F%mode3)) allocate(F%mode3)
  call mode3_to_f (z_mode3, c_loc(F%mode3))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_photon == 0) then
  if (associated(F%photon)) deallocate(F%photon)
else
  if (.not. associated(F%photon)) allocate(F%photon)
  call photon_element_to_f (z_photon, c_loc(F%photon))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_rad_map == 0) then
  if (associated(F%rad_map)) deallocate(F%rad_map)
else
  if (.not. associated(F%rad_map)) allocate(F%rad_map)
  call rad_map_ele_to_f (z_rad_map, c_loc(F%rad_map))
endif

!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%taylor,1); lb1 = lbound(F%taylor,1) - 1
  call taylor_to_f(z_taylor(jd1), c_loc(F%taylor(jd1+lb1)))
enddo
!! f_side.to_f2_trans[real, 1, NOT]
F%spin_taylor_ref_orb_in = z_spin_taylor_ref_orb_in(1:6)
!! f_side.to_f2_trans[type, 1, NOT]
do jd1 = 1, size(F%spin_taylor,1); lb1 = lbound(F%spin_taylor,1) - 1
  call taylor_to_f(z_spin_taylor(jd1), c_loc(F%spin_taylor(jd1+lb1)))
enddo
!! f_side.to_f2_trans[type, 0, PTR]
if (n_wake == 0) then
  if (associated(F%wake)) deallocate(F%wake)
else
  if (.not. associated(F%wake)) allocate(F%wake)
  call wake_to_f (z_wake, c_loc(F%wake))
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_wall3d == 0) then
  if (associated(F%wall3d)) deallocate(F%wall3d)
else
  if (associated(F%wall3d)) then
    if (n1_wall3d == 0 .or. any(shape(F%wall3d) /= [n1_wall3d])) deallocate(F%wall3d)
    if (any(lbound(F%wall3d) /= 1)) deallocate(F%wall3d)
  endif
  if (.not. associated(F%wall3d)) allocate(F%wall3d(1:n1_wall3d+1-1))
  do jd1 = 1, n1_wall3d
    call wall3d_to_f (z_wall3d(jd1), c_loc(F%wall3d(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_cartesian_map == 0) then
  if (associated(F%cartesian_map)) deallocate(F%cartesian_map)
else
  if (associated(F%cartesian_map)) then
    if (n1_cartesian_map == 0 .or. any(shape(F%cartesian_map) /= [n1_cartesian_map])) deallocate(F%cartesian_map)
    if (any(lbound(F%cartesian_map) /= 1)) deallocate(F%cartesian_map)
  endif
  if (.not. associated(F%cartesian_map)) allocate(F%cartesian_map(1:n1_cartesian_map+1-1))
  do jd1 = 1, n1_cartesian_map
    call cartesian_map_to_f (z_cartesian_map(jd1), c_loc(F%cartesian_map(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_cylindrical_map == 0) then
  if (associated(F%cylindrical_map)) deallocate(F%cylindrical_map)
else
  if (associated(F%cylindrical_map)) then
    if (n1_cylindrical_map == 0 .or. any(shape(F%cylindrical_map) /= [n1_cylindrical_map])) deallocate(F%cylindrical_map)
    if (any(lbound(F%cylindrical_map) /= 1)) deallocate(F%cylindrical_map)
  endif
  if (.not. associated(F%cylindrical_map)) allocate(F%cylindrical_map(1:n1_cylindrical_map+1-1))
  do jd1 = 1, n1_cylindrical_map
    call cylindrical_map_to_f (z_cylindrical_map(jd1), c_loc(F%cylindrical_map(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_gen_grad_map == 0) then
  if (associated(F%gen_grad_map)) deallocate(F%gen_grad_map)
else
  if (associated(F%gen_grad_map)) then
    if (n1_gen_grad_map == 0 .or. any(shape(F%gen_grad_map) /= [n1_gen_grad_map])) deallocate(F%gen_grad_map)
    if (any(lbound(F%gen_grad_map) /= 1)) deallocate(F%gen_grad_map)
  endif
  if (.not. associated(F%gen_grad_map)) allocate(F%gen_grad_map(1:n1_gen_grad_map+1-1))
  do jd1 = 1, n1_gen_grad_map
    call gen_grad_map_to_f (z_gen_grad_map(jd1), c_loc(F%gen_grad_map(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, PTR]
if (n1_grid_field == 0) then
  if (associated(F%grid_field)) deallocate(F%grid_field)
else
  if (associated(F%grid_field)) then
    if (n1_grid_field == 0 .or. any(shape(F%grid_field) /= [n1_grid_field])) deallocate(F%grid_field)
    if (any(lbound(F%grid_field) /= 1)) deallocate(F%grid_field)
  endif
  if (.not. associated(F%grid_field)) allocate(F%grid_field(1:n1_grid_field+1-1))
  do jd1 = 1, n1_grid_field
    call grid_field_to_f (z_grid_field(jd1), c_loc(F%grid_field(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_map_ref_orb_in, c_loc(F%map_ref_orb_in))
!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_map_ref_orb_out, c_loc(F%map_ref_orb_out))
!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_time_ref_orb_in, c_loc(F%time_ref_orb_in))
!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_time_ref_orb_out, c_loc(F%time_ref_orb_out))
!! f_side.to_f2_trans[real, 1, NOT]
F%value = z_value(2:num_ele_attrib$+1)
!! f_side.to_f2_trans[real, 1, NOT]
F%old_value = z_old_value(2:num_ele_attrib$+1)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_spin_q, F%spin_q)
!! f_side.to_f2_trans[real, 1, NOT]
F%vec0 = z_vec0(1:6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_mat6, F%mat6)
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_c_mat, F%c_mat)
!! f_side.to_f2_trans[real, 0, NOT]
F%gamma_c = z_gamma_c
!! f_side.to_f2_trans[real, 0, NOT]
F%s_start = z_s_start
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[real, 0, NOT]
F%ref_time = z_ref_time
!! f_side.to_f2_trans[real, 1, PTR]
if (associated(F%a_pole)) then
  if (n1_a_pole == 0 .or. any(shape(F%a_pole) /= [n1_a_pole])) deallocate(F%a_pole)
  if (any(lbound(F%a_pole) /= 1)) deallocate(F%a_pole)
endif
if (n1_a_pole /= 0) then
  call c_f_pointer (z_a_pole, f_a_pole, [n1_a_pole])
  if (.not. associated(F%a_pole)) allocate(F%a_pole(n1_a_pole))
  F%a_pole = f_a_pole(1:n1_a_pole)
else
  if (associated(F%a_pole)) deallocate(F%a_pole)
endif

!! f_side.to_f2_trans[real, 1, PTR]
if (associated(F%b_pole)) then
  if (n1_b_pole == 0 .or. any(shape(F%b_pole) /= [n1_b_pole])) deallocate(F%b_pole)
  if (any(lbound(F%b_pole) /= 1)) deallocate(F%b_pole)
endif
if (n1_b_pole /= 0) then
  call c_f_pointer (z_b_pole, f_b_pole, [n1_b_pole])
  if (.not. associated(F%b_pole)) allocate(F%b_pole(n1_b_pole))
  F%b_pole = f_b_pole(1:n1_b_pole)
else
  if (associated(F%b_pole)) deallocate(F%b_pole)
endif

!! f_side.to_f2_trans[real, 1, PTR]
if (associated(F%a_pole_elec)) then
  if (n1_a_pole_elec == 0 .or. any(shape(F%a_pole_elec) /= [n1_a_pole_elec])) deallocate(F%a_pole_elec)
  if (any(lbound(F%a_pole_elec) /= 1)) deallocate(F%a_pole_elec)
endif
if (n1_a_pole_elec /= 0) then
  call c_f_pointer (z_a_pole_elec, f_a_pole_elec, [n1_a_pole_elec])
  if (.not. associated(F%a_pole_elec)) allocate(F%a_pole_elec(n1_a_pole_elec))
  F%a_pole_elec = f_a_pole_elec(1:n1_a_pole_elec)
else
  if (associated(F%a_pole_elec)) deallocate(F%a_pole_elec)
endif

!! f_side.to_f2_trans[real, 1, PTR]
if (associated(F%b_pole_elec)) then
  if (n1_b_pole_elec == 0 .or. any(shape(F%b_pole_elec) /= [n1_b_pole_elec])) deallocate(F%b_pole_elec)
  if (any(lbound(F%b_pole_elec) /= 1)) deallocate(F%b_pole_elec)
endif
if (n1_b_pole_elec /= 0) then
  call c_f_pointer (z_b_pole_elec, f_b_pole_elec, [n1_b_pole_elec])
  if (.not. associated(F%b_pole_elec)) allocate(F%b_pole_elec(n1_b_pole_elec))
  F%b_pole_elec = f_b_pole_elec(1:n1_b_pole_elec)
else
  if (associated(F%b_pole_elec)) deallocate(F%b_pole_elec)
endif

!! f_side.to_f2_trans[real, 1, PTR]
if (associated(F%custom)) then
  if (n1_custom == 0 .or. any(shape(F%custom) /= [n1_custom])) deallocate(F%custom)
  if (any(lbound(F%custom) /= 1)) deallocate(F%custom)
endif
if (n1_custom /= 0) then
  call c_f_pointer (z_custom, f_custom, [n1_custom])
  if (.not. associated(F%custom)) allocate(F%custom(n1_custom))
  F%custom = f_custom(1:n1_custom)
else
  if (associated(F%custom)) deallocate(F%custom)
endif

!! f_side.to_f2_trans[real, 3, PTR]
if (associated(F%r)) then
  if (n1_r == 0 .or. any(shape(F%r) /= [n1_r, n2_r, n3_r])) deallocate(F%r)
  if (any(lbound(F%r) /= 1)) deallocate(F%r)
endif
if (n1_r /= 0) then
  call c_f_pointer (z_r, f_r, [n1_r*n2_r*n3_r])
  if (.not. associated(F%r)) allocate(F%r(n1_r, n2_r, n3_r))
  call vec2tensor(f_r, F%r)
else
  if (associated(F%r)) deallocate(F%r)
endif

!! f_side.to_f2_trans[integer, 0, NOT]
F%key = z_key
!! f_side.to_f2_trans[integer, 0, NOT]
F%sub_key = z_sub_key
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%lord_status = z_lord_status
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_slave = z_n_slave
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_slave_field = z_n_slave_field
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix1_slave = z_ix1_slave
!! f_side.to_f2_trans[integer, 0, NOT]
F%slave_status = z_slave_status
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_lord = z_n_lord
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_lord_field = z_n_lord_field
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_lord_ramper = z_n_lord_ramper
!! f_side.to_f2_trans[integer, 0, NOT]
F%ic1_lord = z_ic1_lord
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_pointer = z_ix_pointer
!! f_side.to_f2_trans[integer, 0, NOT]
F%ixx = z_ixx
!! f_side.to_f2_trans[integer, 0, NOT]
F%iyy = z_iyy
!! f_side.to_f2_trans[integer, 0, NOT]
F%izz = z_izz
!! f_side.to_f2_trans[integer, 0, NOT]
F%mat6_calc_method = z_mat6_calc_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%tracking_method = z_tracking_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%spin_tracking_method = z_spin_tracking_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%csr_method = z_csr_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%space_charge_method = z_space_charge_method
!! f_side.to_f2_trans[integer, 0, NOT]
F%ptc_integration_type = z_ptc_integration_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%field_calc = z_field_calc
!! f_side.to_f2_trans[integer, 0, NOT]
F%aperture_at = z_aperture_at
!! f_side.to_f2_trans[integer, 0, NOT]
F%aperture_type = z_aperture_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%ref_species = z_ref_species
!! f_side.to_f2_trans[integer, 0, NOT]
F%orientation = z_orientation
!! f_side.to_f2_trans[logical, 0, NOT]
F%symplectify = f_logic(z_symplectify)
!! f_side.to_f2_trans[logical, 0, NOT]
F%mode_flip = f_logic(z_mode_flip)
!! f_side.to_f2_trans[logical, 0, NOT]
F%multipoles_on = f_logic(z_multipoles_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%scale_multipoles = f_logic(z_scale_multipoles)
!! f_side.to_f2_trans[logical, 0, NOT]
F%taylor_map_includes_offsets = f_logic(z_taylor_map_includes_offsets)
!! f_side.to_f2_trans[logical, 0, NOT]
F%field_master = f_logic(z_field_master)
!! f_side.to_f2_trans[logical, 0, NOT]
F%is_on = f_logic(z_is_on)
!! f_side.to_f2_trans[logical, 0, NOT]
F%logic = f_logic(z_logic)
!! f_side.to_f2_trans[logical, 0, NOT]
F%bmad_logic = f_logic(z_bmad_logic)
!! f_side.to_f2_trans[logical, 0, NOT]
F%select = f_logic(z_select)
!! f_side.to_f2_trans[logical, 0, NOT]
F%offset_moves_aperture = f_logic(z_offset_moves_aperture)

end subroutine ele_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine complex_taylor_term_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad complex_taylor_term_struct to a C++ CPP_complex_taylor_term structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad complex_taylor_term_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_complex_taylor_term struct.
!-

subroutine complex_taylor_term_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine complex_taylor_term_to_c2 (C, z_coef, z_expn) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_coef
    integer(c_int) :: z_expn(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(complex_taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call complex_taylor_term_to_c2 (C, F%coef, fvec2vec(F%expn, 6))

end subroutine complex_taylor_term_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine complex_taylor_term_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_complex_taylor_term structure to a Bmad complex_taylor_term_struct structure.
! This routine is called by complex_taylor_term_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the complex_taylor_term_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad complex_taylor_term_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine complex_taylor_term_to_f2 (Fp, z_coef, z_expn) bind(c)


implicit none

type(c_ptr), value :: Fp
type(complex_taylor_term_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_coef
integer(c_int) :: z_expn(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 0, NOT]
F%coef = z_coef
!! f_side.to_f2_trans[integer, 1, NOT]
F%expn = z_expn(1:6)

end subroutine complex_taylor_term_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine complex_taylor_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad complex_taylor_struct to a C++ CPP_complex_taylor structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad complex_taylor_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_complex_taylor struct.
!-

subroutine complex_taylor_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine complex_taylor_to_c2 (C, z_ref, z_term, n1_term) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    complex(c_double_complex) :: z_ref
    type(c_ptr) :: z_term(*)
    integer(c_int), value :: n1_term
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(complex_taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_term(:)
integer(c_int) :: n1_term

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, PTR]
 n1_term = 0
if (associated(F%term)) then
  n1_term = size(F%term); lb1 = lbound(F%term, 1) - 1
  allocate (z_term(n1_term))
  do jd1 = 1, n1_term
    z_term(jd1) = c_loc(F%term(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call complex_taylor_to_c2 (C, F%ref, z_term, n1_term)

end subroutine complex_taylor_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine complex_taylor_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_complex_taylor structure to a Bmad complex_taylor_struct structure.
! This routine is called by complex_taylor_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the complex_taylor_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad complex_taylor_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine complex_taylor_to_f2 (Fp, z_ref, z_term, n1_term) bind(c)


implicit none

type(c_ptr), value :: Fp
type(complex_taylor_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
complex(c_double_complex) :: z_ref
type(c_ptr) :: z_term(*)
integer(c_int), value :: n1_term

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[complex, 0, NOT]
F%ref = z_ref
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_term == 0) then
  if (associated(F%term)) deallocate(F%term)
else
  if (associated(F%term)) then
    if (n1_term == 0 .or. any(shape(F%term) /= [n1_term])) deallocate(F%term)
    if (any(lbound(F%term) /= 1)) deallocate(F%term)
  endif
  if (.not. associated(F%term)) allocate(F%term(1:n1_term+1-1))
  do jd1 = 1, n1_term
    call complex_taylor_term_to_f (z_term(jd1), c_loc(F%term(jd1+1-1)))
  enddo
endif


end subroutine complex_taylor_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine branch_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad branch_struct to a C++ CPP_branch structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad branch_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_branch struct.
!-

subroutine branch_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine branch_to_c2 (C, z_name, z_ix_branch, z_ix_from_branch, z_ix_from_ele, &
      z_ix_to_ele, z_n_ele_track, z_n_ele_max, z_a, z_b, z_z, z_ele, n1_ele, z_param, z_wall3d, &
      n1_wall3d) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_name(*)
    integer(c_int) :: z_ix_branch, z_ix_from_branch, z_ix_from_ele, z_ix_to_ele, z_n_ele_track, z_n_ele_max
    type(c_ptr), value :: z_a, z_b, z_z, z_param
    type(c_ptr) :: z_ele(*), z_wall3d(*)
    integer(c_int), value :: n1_ele, n1_wall3d
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(branch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_ele(:)
integer(c_int) :: n1_ele
type(c_ptr), allocatable :: z_wall3d(:)
integer(c_int) :: n1_wall3d

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, PTR]
 n1_ele = 0
if (associated(F%ele)) then
  n1_ele = size(F%ele); lb1 = lbound(F%ele, 1) - 1
  allocate (z_ele(n1_ele))
  do jd1 = 1, n1_ele
    z_ele(jd1) = c_loc(F%ele(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, PTR]
 n1_wall3d = 0
if (associated(F%wall3d)) then
  n1_wall3d = size(F%wall3d); lb1 = lbound(F%wall3d, 1) - 1
  allocate (z_wall3d(n1_wall3d))
  do jd1 = 1, n1_wall3d
    z_wall3d(jd1) = c_loc(F%wall3d(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call branch_to_c2 (C, trim(F%name) // c_null_char, F%ix_branch, F%ix_from_branch, &
    F%ix_from_ele, F%ix_to_ele, F%n_ele_track, F%n_ele_max, c_loc(F%a), c_loc(F%b), c_loc(F%z), &
    z_ele, n1_ele, c_loc(F%param), z_wall3d, n1_wall3d)

end subroutine branch_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine branch_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_branch structure to a Bmad branch_struct structure.
! This routine is called by branch_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the branch_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad branch_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine branch_to_f2 (Fp, z_name, z_ix_branch, z_ix_from_branch, z_ix_from_ele, z_ix_to_ele, &
    z_n_ele_track, z_n_ele_max, z_a, z_b, z_z, z_ele, n1_ele, z_param, z_wall3d, n1_wall3d) &
    bind(c)


implicit none

type(c_ptr), value :: Fp
type(branch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_name(*)
integer(c_int) :: z_ix_branch, z_ix_from_branch, z_ix_from_ele, z_ix_to_ele, z_n_ele_track, z_n_ele_max
type(c_ptr), value :: z_a, z_b, z_z, z_param
type(c_ptr) :: z_ele(*), z_wall3d(*)
integer(c_int), value :: n1_ele, n1_wall3d

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_name, F%name)
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_branch = z_ix_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_from_branch = z_ix_from_branch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_from_ele = z_ix_from_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_to_ele = z_ix_to_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ele_track = z_n_ele_track
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ele_max = z_n_ele_max
!! f_side.to_f2_trans[type, 0, NOT]
call mode_info_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call mode_info_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call mode_info_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_ele == 0) then
  if (associated(F%ele)) deallocate(F%ele)
else
  if (associated(F%ele)) then
    if (n1_ele == 0 .or. any(shape(F%ele) /= [n1_ele])) deallocate(F%ele)
    if (any(lbound(F%ele) /= 0)) deallocate(F%ele)
  endif
  if (.not. associated(F%ele)) allocate(F%ele(0:n1_ele+0-1))
  do jd1 = 1, n1_ele
    call ele_to_f (z_ele(jd1), c_loc(F%ele(jd1+0-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, NOT]
call lat_param_to_f(z_param, c_loc(F%param))
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_wall3d == 0) then
  if (associated(F%wall3d)) deallocate(F%wall3d)
else
  if (associated(F%wall3d)) then
    if (n1_wall3d == 0 .or. any(shape(F%wall3d) /= [n1_wall3d])) deallocate(F%wall3d)
    if (any(lbound(F%wall3d) /= 1)) deallocate(F%wall3d)
  endif
  if (.not. associated(F%wall3d)) allocate(F%wall3d(1:n1_wall3d+1-1))
  do jd1 = 1, n1_wall3d
    call wall3d_to_f (z_wall3d(jd1), c_loc(F%wall3d(jd1+1-1)))
  enddo
endif


end subroutine branch_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad lat_struct to a C++ CPP_lat structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad lat_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_lat struct.
!-

subroutine lat_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine lat_to_c2 (C, z_use_name, z_lattice, z_machine, z_input_file_name, z_title, &
      z_print_str, n1_print_str, z_constant, n1_constant, z_a, n_a, z_b, n_b, z_z, n_z, &
      z_param, n_param, z_lord_state, z_ele_init, z_ele, n1_ele, z_branch, n1_branch, &
      z_control, n1_control, z_particle_start, z_beam_init, z_pre_tracker, z_custom, n1_custom, &
      z_version, z_n_ele_track, n_n_ele_track, z_n_ele_max, n_n_ele_max, z_n_control_max, &
      z_n_ic_max, z_input_taylor_order, z_ic, n1_ic, z_photon_type, z_creation_hash, &
      z_ramper_slave_bookkeeping) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    character(c_char) :: z_use_name(*), z_lattice(*), z_machine(*), z_input_file_name(*), z_title(*)
    type(c_ptr) :: z_print_str(*), z_constant(*), z_ele(*), z_branch(*), z_control(*)
    integer(c_int), value :: n1_print_str, n1_constant, n_a, n_b, n_z, n_param, n1_ele
    integer(c_int), value :: n1_branch, n1_control, n1_custom, n_n_ele_track, n_n_ele_max, n1_ic
    type(c_ptr), value :: z_a, z_b, z_z, z_param, z_lord_state, z_ele_init, z_particle_start
    type(c_ptr), value :: z_beam_init, z_pre_tracker
    real(c_double) :: z_custom(*)
    integer(c_int) :: z_version, z_n_ele_track, z_n_ele_max, z_n_control_max, z_n_ic_max, z_input_taylor_order, z_ic(*)
    integer(c_int) :: z_photon_type, z_creation_hash, z_ramper_slave_bookkeeping
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(lat_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_print_str(:)
character(100+1), allocatable, target :: a_print_str(:)
integer(c_int) :: n1_print_str
type(c_ptr), allocatable :: z_constant(:)
integer(c_int) :: n1_constant
integer(c_int) :: n_a
integer(c_int) :: n_b
integer(c_int) :: n_z
integer(c_int) :: n_param
type(c_ptr), allocatable :: z_ele(:)
integer(c_int) :: n1_ele
type(c_ptr), allocatable :: z_branch(:)
integer(c_int) :: n1_branch
type(c_ptr), allocatable :: z_control(:)
integer(c_int) :: n1_control
integer(c_int) :: n1_custom
integer(c_int) :: n_n_ele_track
integer(c_int) :: n_n_ele_max
integer(c_int) :: n1_ic

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[character, 1, ALLOC]
n1_print_str = 0
if (allocated(F%print_str)) then
  n1_print_str = size(F%print_str); lb1 = lbound(F%print_str, 1) - 1
  allocate (a_print_str(n1_print_str))
  allocate (z_print_str(n1_print_str))
  do jd1 = 1, n1_print_str
    a_print_str(jd1) = trim(F%print_str(jd1+lb1)) // c_null_char
    z_print_str(jd1) = c_loc(a_print_str(jd1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_constant = 0
if (allocated(F%constant)) then
  n1_constant = size(F%constant); lb1 = lbound(F%constant, 1) - 1
  allocate (z_constant(n1_constant))
  do jd1 = 1, n1_constant
    z_constant(jd1) = c_loc(F%constant(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 0, PTR]
n_a = 0
if (associated(F%a)) n_a = 1
!! f_side.to_c_trans[type, 0, PTR]
n_b = 0
if (associated(F%b)) n_b = 1
!! f_side.to_c_trans[type, 0, PTR]
n_z = 0
if (associated(F%z)) n_z = 1
!! f_side.to_c_trans[type, 0, PTR]
n_param = 0
if (associated(F%param)) n_param = 1
!! f_side.to_c_trans[type, 1, PTR]
 n1_ele = 0
if (associated(F%ele)) then
  n1_ele = size(F%ele); lb1 = lbound(F%ele, 1) - 1
  allocate (z_ele(n1_ele))
  do jd1 = 1, n1_ele
    z_ele(jd1) = c_loc(F%ele(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_branch = 0
if (allocated(F%branch)) then
  n1_branch = size(F%branch); lb1 = lbound(F%branch, 1) - 1
  allocate (z_branch(n1_branch))
  do jd1 = 1, n1_branch
    z_branch(jd1) = c_loc(F%branch(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[type, 1, ALLOC]
 n1_control = 0
if (allocated(F%control)) then
  n1_control = size(F%control); lb1 = lbound(F%control, 1) - 1
  allocate (z_control(n1_control))
  do jd1 = 1, n1_control
    z_control(jd1) = c_loc(F%control(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[real, 1, ALLOC]
n1_custom = 0
if (allocated(F%custom)) then
  n1_custom = size(F%custom, 1)
endif
!! f_side.to_c_trans[integer, 0, PTR]
n_n_ele_track = 0
if (associated(F%n_ele_track)) n_n_ele_track = 1
!! f_side.to_c_trans[integer, 0, PTR]
n_n_ele_max = 0
if (associated(F%n_ele_max)) n_n_ele_max = 1
!! f_side.to_c_trans[integer, 1, ALLOC]
n1_ic = 0
if (allocated(F%ic)) then
  n1_ic = size(F%ic, 1)
endif

!! f_side.to_c2_call
call lat_to_c2 (C, trim(F%use_name) // c_null_char, trim(F%lattice) // c_null_char, &
    trim(F%machine) // c_null_char, trim(F%input_file_name) // c_null_char, trim(F%title) // &
    c_null_char, z_print_str, n1_print_str, z_constant, n1_constant, c_loc(F%a), n_a, &
    c_loc(F%b), n_b, c_loc(F%z), n_z, c_loc(F%param), n_param, c_loc(F%lord_state), &
    c_loc(F%ele_init), z_ele, n1_ele, z_branch, n1_branch, z_control, n1_control, &
    c_loc(F%particle_start), c_loc(F%beam_init), c_loc(F%pre_tracker), fvec2vec(F%custom, &
    n1_custom), n1_custom, F%version, F%n_ele_track, n_n_ele_track, F%n_ele_max, n_n_ele_max, &
    F%n_control_max, F%n_ic_max, F%input_taylor_order, fvec2vec(F%ic, n1_ic), n1_ic, &
    F%photon_type, F%creation_hash, F%ramper_slave_bookkeeping)

end subroutine lat_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine lat_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_lat structure to a Bmad lat_struct structure.
! This routine is called by lat_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the lat_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad lat_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine lat_to_f2 (Fp, z_use_name, z_lattice, z_machine, z_input_file_name, z_title, &
    z_print_str, n1_print_str, z_constant, n1_constant, z_a, n_a, z_b, n_b, z_z, n_z, z_param, &
    n_param, z_lord_state, z_ele_init, z_ele, n1_ele, z_branch, n1_branch, z_control, &
    n1_control, z_particle_start, z_beam_init, z_pre_tracker, z_custom, n1_custom, z_version, &
    z_n_ele_track, n_n_ele_track, z_n_ele_max, n_n_ele_max, z_n_control_max, z_n_ic_max, &
    z_input_taylor_order, z_ic, n1_ic, z_photon_type, z_creation_hash, &
    z_ramper_slave_bookkeeping) bind(c)


implicit none

type(c_ptr), value :: Fp
type(lat_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
character(c_char) :: z_use_name(*), z_lattice(*), z_machine(*), z_input_file_name(*), z_title(*)
type(c_ptr) :: z_print_str(*), z_constant(*), z_ele(*), z_branch(*), z_control(*)
character(c_char), pointer :: f_print_str
integer(c_int), value :: n1_print_str, n1_constant, n_a, n_b, n_z, n_param, n1_ele
integer(c_int), value :: n1_branch, n1_control, n1_custom, n_n_ele_track, n_n_ele_max, n1_ic
type(c_ptr), value :: z_a, z_b, z_z, z_param, z_lord_state, z_ele_init, z_particle_start
type(c_ptr), value :: z_beam_init, z_pre_tracker, z_custom, z_n_ele_track, z_n_ele_max, z_ic
type(mode_info_struct), pointer :: f_a, f_b, f_z
type(lat_param_struct), pointer :: f_param
real(c_double), pointer :: f_custom(:)
integer(c_int) :: z_version, z_n_control_max, z_n_ic_max, z_input_taylor_order, z_photon_type, z_creation_hash, z_ramper_slave_bookkeeping
integer(c_int), pointer :: f_n_ele_track, f_n_ele_max, f_ic(:)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_use_name, F%use_name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_lattice, F%lattice)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_machine, F%machine)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_input_file_name, F%input_file_name)
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_title, F%title)
!! f_side.to_f2_trans[character, 1, ALLOC]
if (n1_print_str == 0) then
  if (allocated(F%print_str)) deallocate(F%print_str)
else
  if (allocated(F%print_str)) then
    if (n1_print_str == 0 .or. any(shape(F%print_str) /= [n1_print_str])) deallocate(F%print_str)
    if (any(lbound(F%print_str) /= 1)) deallocate(F%print_str)
  endif
  if (.not. allocated(F%print_str)) allocate(F%print_str(1:n1_print_str+1-1))
  do jd1 = 1, n1_print_str
    call c_f_pointer (z_print_str(jd1), f_print_str)
    call to_f_str(f_print_str, F%print_str(jd1+1-1))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_constant == 0) then
  if (allocated(F%constant)) deallocate(F%constant)
else
  if (allocated(F%constant)) then
    if (n1_constant == 0 .or. any(shape(F%constant) /= [n1_constant])) deallocate(F%constant)
    if (any(lbound(F%constant) /= 1)) deallocate(F%constant)
  endif
  if (.not. allocated(F%constant)) allocate(F%constant(1:n1_constant+1-1))
  do jd1 = 1, n1_constant
    call expression_atom_to_f (z_constant(jd1), c_loc(F%constant(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_a == 0) then
  if (associated(F%a)) deallocate(F%a)
else
  if (.not. associated(F%a)) allocate(F%a)
  call mode_info_to_f (z_a, c_loc(F%a))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_b == 0) then
  if (associated(F%b)) deallocate(F%b)
else
  if (.not. associated(F%b)) allocate(F%b)
  call mode_info_to_f (z_b, c_loc(F%b))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_z == 0) then
  if (associated(F%z)) deallocate(F%z)
else
  if (.not. associated(F%z)) allocate(F%z)
  call mode_info_to_f (z_z, c_loc(F%z))
endif

!! f_side.to_f2_trans[type, 0, PTR]
if (n_param == 0) then
  if (associated(F%param)) deallocate(F%param)
else
  if (.not. associated(F%param)) allocate(F%param)
  call lat_param_to_f (z_param, c_loc(F%param))
endif

!! f_side.to_f2_trans[type, 0, NOT]
call bookkeeping_state_to_f(z_lord_state, c_loc(F%lord_state))
!! f_side.to_f2_trans[type, 0, NOT]
call ele_to_f(z_ele_init, c_loc(F%ele_init))
!! f_side.to_f2_trans[type, 1, PTR]
if (n1_ele == 0) then
  if (associated(F%ele)) deallocate(F%ele)
else
  if (associated(F%ele)) then
    if (n1_ele == 0 .or. any(shape(F%ele) /= [n1_ele])) deallocate(F%ele)
    if (any(lbound(F%ele) /= 1)) deallocate(F%ele)
  endif
  if (.not. associated(F%ele)) allocate(F%ele(1:n1_ele+1-1))
  do jd1 = 1, n1_ele
    call ele_to_f (z_ele(jd1), c_loc(F%ele(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_branch == 0) then
  if (allocated(F%branch)) deallocate(F%branch)
else
  if (allocated(F%branch)) then
    if (n1_branch == 0 .or. any(shape(F%branch) /= [n1_branch])) deallocate(F%branch)
    if (any(lbound(F%branch) /= 1)) deallocate(F%branch)
  endif
  if (.not. allocated(F%branch)) allocate(F%branch(1:n1_branch+1-1))
  do jd1 = 1, n1_branch
    call branch_to_f (z_branch(jd1), c_loc(F%branch(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_control == 0) then
  if (allocated(F%control)) deallocate(F%control)
else
  if (allocated(F%control)) then
    if (n1_control == 0 .or. any(shape(F%control) /= [n1_control])) deallocate(F%control)
    if (any(lbound(F%control) /= 1)) deallocate(F%control)
  endif
  if (.not. allocated(F%control)) allocate(F%control(1:n1_control+1-1))
  do jd1 = 1, n1_control
    call control_to_f (z_control(jd1), c_loc(F%control(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_particle_start, c_loc(F%particle_start))
!! f_side.to_f2_trans[type, 0, NOT]
call beam_init_to_f(z_beam_init, c_loc(F%beam_init))
!! f_side.to_f2_trans[type, 0, NOT]
call pre_tracker_to_f(z_pre_tracker, c_loc(F%pre_tracker))
!! f_side.to_f2_trans[real, 1, ALLOC]
if (allocated(F%custom)) then
  if (n1_custom == 0 .or. any(shape(F%custom) /= [n1_custom])) deallocate(F%custom)
  if (any(lbound(F%custom) /= 1)) deallocate(F%custom)
endif
if (n1_custom /= 0) then
  call c_f_pointer (z_custom, f_custom, [n1_custom])
  if (.not. allocated(F%custom)) allocate(F%custom(n1_custom))
  F%custom = f_custom(1:n1_custom)
else
  if (allocated(F%custom)) deallocate(F%custom)
endif

!! f_side.to_f2_trans[integer, 0, NOT]
F%version = z_version
!! f_side.to_f2_trans[integer, 0, PTR]
if (n_n_ele_track == 0) then                                                                                  
  if (associated(F%n_ele_track)) deallocate(F%n_ele_track)                                                           
else                                                                                                   
  call c_f_pointer (z_n_ele_track, f_n_ele_track)                                                                    
  if (.not. associated(F%n_ele_track)) allocate(F%n_ele_track)                                                       
  F%n_ele_track = f_n_ele_track
endif                                                                                                  

!! f_side.to_f2_trans[integer, 0, PTR]
if (n_n_ele_max == 0) then                                                                                  
  if (associated(F%n_ele_max)) deallocate(F%n_ele_max)                                                           
else                                                                                                   
  call c_f_pointer (z_n_ele_max, f_n_ele_max)                                                                    
  if (.not. associated(F%n_ele_max)) allocate(F%n_ele_max)                                                       
  F%n_ele_max = f_n_ele_max
endif                                                                                                  

!! f_side.to_f2_trans[integer, 0, NOT]
F%n_control_max = z_n_control_max
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_ic_max = z_n_ic_max
!! f_side.to_f2_trans[integer, 0, NOT]
F%input_taylor_order = z_input_taylor_order
!! f_side.to_f2_trans[integer, 1, ALLOC]
if (allocated(F%ic)) then
  if (n1_ic == 0 .or. any(shape(F%ic) /= [n1_ic])) deallocate(F%ic)
  if (any(lbound(F%ic) /= 1)) deallocate(F%ic)
endif
if (n1_ic /= 0) then
  call c_f_pointer (z_ic, f_ic, [n1_ic])
  if (.not. allocated(F%ic)) allocate(F%ic(n1_ic))
  F%ic = f_ic(1:n1_ic)
else
  if (allocated(F%ic)) deallocate(F%ic)
endif

!! f_side.to_f2_trans[integer, 0, NOT]
F%photon_type = z_photon_type
!! f_side.to_f2_trans[integer, 0, NOT]
F%creation_hash = z_creation_hash
!! f_side.to_f2_trans[integer, 0, NOT]
F%ramper_slave_bookkeeping = z_ramper_slave_bookkeeping

end subroutine lat_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bunch_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bunch_struct to a C++ CPP_bunch structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bunch_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bunch struct.
!-

subroutine bunch_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bunch_to_c2 (C, z_particle, n1_particle, z_ix_z, n1_ix_z, z_charge_tot, &
      z_charge_live, z_z_center, z_t_center, z_t0, z_drift_between_t_and_s, z_ix_ele, &
      z_ix_bunch, z_ix_turn, z_n_live, z_n_good, z_n_bad) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_particle(*)
    integer(c_int), value :: n1_particle, n1_ix_z
    integer(c_int) :: z_ix_z(*), z_ix_ele, z_ix_bunch, z_ix_turn, z_n_live, z_n_good, z_n_bad
    real(c_double) :: z_charge_tot, z_charge_live, z_z_center, z_t_center, z_t0
    logical(c_bool) :: z_drift_between_t_and_s
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bunch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_particle(:)
integer(c_int) :: n1_particle
integer(c_int) :: n1_ix_z

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_particle = 0
if (allocated(F%particle)) then
  n1_particle = size(F%particle); lb1 = lbound(F%particle, 1) - 1
  allocate (z_particle(n1_particle))
  do jd1 = 1, n1_particle
    z_particle(jd1) = c_loc(F%particle(jd1+lb1))
  enddo
endif
!! f_side.to_c_trans[integer, 1, ALLOC]
n1_ix_z = 0
if (allocated(F%ix_z)) then
  n1_ix_z = size(F%ix_z, 1)
endif

!! f_side.to_c2_call
call bunch_to_c2 (C, z_particle, n1_particle, fvec2vec(F%ix_z, n1_ix_z), n1_ix_z, F%charge_tot, &
    F%charge_live, F%z_center, F%t_center, F%t0, c_logic(F%drift_between_t_and_s), F%ix_ele, &
    F%ix_bunch, F%ix_turn, F%n_live, F%n_good, F%n_bad)

end subroutine bunch_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bunch_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bunch structure to a Bmad bunch_struct structure.
! This routine is called by bunch_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bunch_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bunch_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bunch_to_f2 (Fp, z_particle, n1_particle, z_ix_z, n1_ix_z, z_charge_tot, &
    z_charge_live, z_z_center, z_t_center, z_t0, z_drift_between_t_and_s, z_ix_ele, z_ix_bunch, &
    z_ix_turn, z_n_live, z_n_good, z_n_bad) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bunch_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr) :: z_particle(*)
integer(c_int), value :: n1_particle, n1_ix_z
type(c_ptr), value :: z_ix_z
integer(c_int), pointer :: f_ix_z(:)
real(c_double) :: z_charge_tot, z_charge_live, z_z_center, z_t_center, z_t0
logical(c_bool) :: z_drift_between_t_and_s
integer(c_int) :: z_ix_ele, z_ix_bunch, z_ix_turn, z_n_live, z_n_good, z_n_bad

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_particle == 0) then
  if (allocated(F%particle)) deallocate(F%particle)
else
  if (allocated(F%particle)) then
    if (n1_particle == 0 .or. any(shape(F%particle) /= [n1_particle])) deallocate(F%particle)
    if (any(lbound(F%particle) /= 1)) deallocate(F%particle)
  endif
  if (.not. allocated(F%particle)) allocate(F%particle(1:n1_particle+1-1))
  do jd1 = 1, n1_particle
    call coord_to_f (z_particle(jd1), c_loc(F%particle(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[integer, 1, ALLOC]
if (allocated(F%ix_z)) then
  if (n1_ix_z == 0 .or. any(shape(F%ix_z) /= [n1_ix_z])) deallocate(F%ix_z)
  if (any(lbound(F%ix_z) /= 1)) deallocate(F%ix_z)
endif
if (n1_ix_z /= 0) then
  call c_f_pointer (z_ix_z, f_ix_z, [n1_ix_z])
  if (.not. allocated(F%ix_z)) allocate(F%ix_z(n1_ix_z))
  F%ix_z = f_ix_z(1:n1_ix_z)
else
  if (allocated(F%ix_z)) deallocate(F%ix_z)
endif

!! f_side.to_f2_trans[real, 0, NOT]
F%charge_tot = z_charge_tot
!! f_side.to_f2_trans[real, 0, NOT]
F%charge_live = z_charge_live
!! f_side.to_f2_trans[real, 0, NOT]
F%z_center = z_z_center
!! f_side.to_f2_trans[real, 0, NOT]
F%t_center = z_t_center
!! f_side.to_f2_trans[real, 0, NOT]
F%t0 = z_t0
!! f_side.to_f2_trans[logical, 0, NOT]
F%drift_between_t_and_s = f_logic(z_drift_between_t_and_s)
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_bunch = z_ix_bunch
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_turn = z_ix_turn
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_live = z_n_live
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_good = z_n_good
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_bad = z_n_bad

end subroutine bunch_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bunch_params_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad bunch_params_struct to a C++ CPP_bunch_params structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad bunch_params_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_bunch_params struct.
!-

subroutine bunch_params_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine bunch_params_to_c2 (C, z_centroid, z_x, z_y, z_z, z_a, z_b, z_c, z_sigma, &
      z_rel_max, z_rel_min, z_s, z_t, z_sigma_t, z_charge_live, z_charge_tot, z_n_particle_tot, &
      z_n_particle_live, z_n_particle_lost_in_ele, z_n_good_steps, z_n_bad_steps, z_ix_ele, &
      z_location, z_twiss_valid) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr), value :: z_centroid, z_x, z_y, z_z, z_a, z_b, z_c
    real(c_double) :: z_sigma(*), z_rel_max(*), z_rel_min(*), z_s, z_t, z_sigma_t, z_charge_live
    real(c_double) :: z_charge_tot
    integer(c_int) :: z_n_particle_tot, z_n_particle_live, z_n_particle_lost_in_ele, z_n_good_steps, z_n_bad_steps, z_ix_ele, z_location
    logical(c_bool) :: z_twiss_valid
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(bunch_params_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call bunch_params_to_c2 (C, c_loc(F%centroid), c_loc(F%x), c_loc(F%y), c_loc(F%z), c_loc(F%a), &
    c_loc(F%b), c_loc(F%c), mat2vec(F%sigma, 6*6), fvec2vec(F%rel_max, 7), fvec2vec(F%rel_min, &
    7), F%s, F%t, F%sigma_t, F%charge_live, F%charge_tot, F%n_particle_tot, F%n_particle_live, &
    F%n_particle_lost_in_ele, F%n_good_steps, F%n_bad_steps, F%ix_ele, F%location, &
    c_logic(F%twiss_valid))

end subroutine bunch_params_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine bunch_params_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_bunch_params structure to a Bmad bunch_params_struct structure.
! This routine is called by bunch_params_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the bunch_params_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad bunch_params_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine bunch_params_to_f2 (Fp, z_centroid, z_x, z_y, z_z, z_a, z_b, z_c, z_sigma, &
    z_rel_max, z_rel_min, z_s, z_t, z_sigma_t, z_charge_live, z_charge_tot, z_n_particle_tot, &
    z_n_particle_live, z_n_particle_lost_in_ele, z_n_good_steps, z_n_bad_steps, z_ix_ele, &
    z_location, z_twiss_valid) bind(c)


implicit none

type(c_ptr), value :: Fp
type(bunch_params_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr), value :: z_centroid, z_x, z_y, z_z, z_a, z_b, z_c
real(c_double) :: z_sigma(*), z_rel_max(*), z_rel_min(*), z_s, z_t, z_sigma_t, z_charge_live
real(c_double) :: z_charge_tot
integer(c_int) :: z_n_particle_tot, z_n_particle_live, z_n_particle_lost_in_ele, z_n_good_steps, z_n_bad_steps, z_ix_ele, z_location
logical(c_bool) :: z_twiss_valid

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_centroid, c_loc(F%centroid))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_x, c_loc(F%x))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_y, c_loc(F%y))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_z, c_loc(F%z))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_a, c_loc(F%a))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_b, c_loc(F%b))
!! f_side.to_f2_trans[type, 0, NOT]
call twiss_to_f(z_c, c_loc(F%c))
!! f_side.to_f2_trans[real, 2, NOT]
call vec2mat(z_sigma, F%sigma)
!! f_side.to_f2_trans[real, 1, NOT]
F%rel_max = z_rel_max(1:7)
!! f_side.to_f2_trans[real, 1, NOT]
F%rel_min = z_rel_min(1:7)
!! f_side.to_f2_trans[real, 0, NOT]
F%s = z_s
!! f_side.to_f2_trans[real, 0, NOT]
F%t = z_t
!! f_side.to_f2_trans[real, 0, NOT]
F%sigma_t = z_sigma_t
!! f_side.to_f2_trans[real, 0, NOT]
F%charge_live = z_charge_live
!! f_side.to_f2_trans[real, 0, NOT]
F%charge_tot = z_charge_tot
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_particle_tot = z_n_particle_tot
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_particle_live = z_n_particle_live
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_particle_lost_in_ele = z_n_particle_lost_in_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_good_steps = z_n_good_steps
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_bad_steps = z_n_bad_steps
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%location = z_location
!! f_side.to_f2_trans[logical, 0, NOT]
F%twiss_valid = f_logic(z_twiss_valid)

end subroutine bunch_params_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine beam_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad beam_struct to a C++ CPP_beam structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad beam_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_beam struct.
!-

subroutine beam_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine beam_to_c2 (C, z_bunch, n1_bunch) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_bunch(*)
    integer(c_int), value :: n1_bunch
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(beam_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_bunch(:)
integer(c_int) :: n1_bunch

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_bunch = 0
if (allocated(F%bunch)) then
  n1_bunch = size(F%bunch); lb1 = lbound(F%bunch, 1) - 1
  allocate (z_bunch(n1_bunch))
  do jd1 = 1, n1_bunch
    z_bunch(jd1) = c_loc(F%bunch(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call beam_to_c2 (C, z_bunch, n1_bunch)

end subroutine beam_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine beam_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_beam structure to a Bmad beam_struct structure.
! This routine is called by beam_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the beam_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad beam_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine beam_to_f2 (Fp, z_bunch, n1_bunch) bind(c)


implicit none

type(c_ptr), value :: Fp
type(beam_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr) :: z_bunch(*)
integer(c_int), value :: n1_bunch

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_bunch == 0) then
  if (allocated(F%bunch)) deallocate(F%bunch)
else
  if (allocated(F%bunch)) then
    if (n1_bunch == 0 .or. any(shape(F%bunch) /= [n1_bunch])) deallocate(F%bunch)
    if (any(lbound(F%bunch) /= 1)) deallocate(F%bunch)
  endif
  if (.not. allocated(F%bunch)) allocate(F%bunch(1:n1_bunch+1-1))
  do jd1 = 1, n1_bunch
    call bunch_to_f (z_bunch(jd1), c_loc(F%bunch(jd1+1-1)))
  enddo
endif


end subroutine beam_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine aperture_point_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad aperture_point_struct to a C++ CPP_aperture_point structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad aperture_point_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_aperture_point struct.
!-

subroutine aperture_point_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine aperture_point_to_c2 (C, z_x, z_y, z_plane, z_ix_ele, z_i_turn) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_x, z_y
    integer(c_int) :: z_plane, z_ix_ele, z_i_turn
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(aperture_point_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call aperture_point_to_c2 (C, F%x, F%y, F%plane, F%ix_ele, F%i_turn)

end subroutine aperture_point_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine aperture_point_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_aperture_point structure to a Bmad aperture_point_struct structure.
! This routine is called by aperture_point_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the aperture_point_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad aperture_point_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine aperture_point_to_f2 (Fp, z_x, z_y, z_plane, z_ix_ele, z_i_turn) bind(c)


implicit none

type(c_ptr), value :: Fp
type(aperture_point_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_x, z_y
integer(c_int) :: z_plane, z_ix_ele, z_i_turn

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%x = z_x
!! f_side.to_f2_trans[real, 0, NOT]
F%y = z_y
!! f_side.to_f2_trans[integer, 0, NOT]
F%plane = z_plane
!! f_side.to_f2_trans[integer, 0, NOT]
F%ix_ele = z_ix_ele
!! f_side.to_f2_trans[integer, 0, NOT]
F%i_turn = z_i_turn

end subroutine aperture_point_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine aperture_param_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad aperture_param_struct to a C++ CPP_aperture_param structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad aperture_param_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_aperture_param struct.
!-

subroutine aperture_param_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine aperture_param_to_c2 (C, z_min_angle, z_max_angle, z_n_angle, z_n_turn, z_x_init, &
      z_y_init, z_rel_accuracy, z_abs_accuracy, z_start_ele) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    real(c_double) :: z_min_angle, z_max_angle, z_x_init, z_y_init, z_rel_accuracy, z_abs_accuracy
    integer(c_int) :: z_n_angle, z_n_turn
    character(c_char) :: z_start_ele(*)
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(aperture_param_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var

!

call c_f_pointer (Fp, F)


!! f_side.to_c2_call
call aperture_param_to_c2 (C, F%min_angle, F%max_angle, F%n_angle, F%n_turn, F%x_init, &
    F%y_init, F%rel_accuracy, F%abs_accuracy, trim(F%start_ele) // c_null_char)

end subroutine aperture_param_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine aperture_param_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_aperture_param structure to a Bmad aperture_param_struct structure.
! This routine is called by aperture_param_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the aperture_param_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad aperture_param_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine aperture_param_to_f2 (Fp, z_min_angle, z_max_angle, z_n_angle, z_n_turn, z_x_init, &
    z_y_init, z_rel_accuracy, z_abs_accuracy, z_start_ele) bind(c)


implicit none

type(c_ptr), value :: Fp
type(aperture_param_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
real(c_double) :: z_min_angle, z_max_angle, z_x_init, z_y_init, z_rel_accuracy, z_abs_accuracy
integer(c_int) :: z_n_angle, z_n_turn
character(c_char) :: z_start_ele(*)

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[real, 0, NOT]
F%min_angle = z_min_angle
!! f_side.to_f2_trans[real, 0, NOT]
F%max_angle = z_max_angle
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_angle = z_n_angle
!! f_side.to_f2_trans[integer, 0, NOT]
F%n_turn = z_n_turn
!! f_side.to_f2_trans[real, 0, NOT]
F%x_init = z_x_init
!! f_side.to_f2_trans[real, 0, NOT]
F%y_init = z_y_init
!! f_side.to_f2_trans[real, 0, NOT]
F%rel_accuracy = z_rel_accuracy
!! f_side.to_f2_trans[real, 0, NOT]
F%abs_accuracy = z_abs_accuracy
!! f_side.to_f2_trans[character, 0, NOT]
call to_f_str(z_start_ele, F%start_ele)

end subroutine aperture_param_to_f2

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine aperture_scan_to_c (Fp, C) bind(c)
!
! Routine to convert a Bmad aperture_scan_struct to a C++ CPP_aperture_scan structure
!
! Input:
!   Fp -- type(c_ptr), value :: Input Bmad aperture_scan_struct structure.
!
! Output:
!   C -- type(c_ptr), value :: Output C++ CPP_aperture_scan struct.
!-

subroutine aperture_scan_to_c (Fp, C) bind(c)

implicit none

interface
  !! f_side.to_c2_f2_sub_arg
  subroutine aperture_scan_to_c2 (C, z_point, n1_point, z_ref_orb, z_pz_start) bind(c)
    import c_bool, c_double, c_ptr, c_char, c_int, c_long, c_double_complex
    !! f_side.to_c2_type :: f_side.to_c2_name
    type(c_ptr), value :: C
    type(c_ptr) :: z_point(*)
    integer(c_int), value :: n1_point
    type(c_ptr), value :: z_ref_orb
    real(c_double) :: z_pz_start
  end subroutine
end interface

type(c_ptr), value :: Fp
type(c_ptr), value :: C
type(aperture_scan_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_c_var
type(c_ptr), allocatable :: z_point(:)
integer(c_int) :: n1_point

!

call c_f_pointer (Fp, F)

!! f_side.to_c_trans[type, 1, ALLOC]
 n1_point = 0
if (allocated(F%point)) then
  n1_point = size(F%point); lb1 = lbound(F%point, 1) - 1
  allocate (z_point(n1_point))
  do jd1 = 1, n1_point
    z_point(jd1) = c_loc(F%point(jd1+lb1))
  enddo
endif

!! f_side.to_c2_call
call aperture_scan_to_c2 (C, z_point, n1_point, c_loc(F%ref_orb), F%pz_start)

end subroutine aperture_scan_to_c

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!+
! Subroutine aperture_scan_to_f2 (Fp, ...etc...) bind(c)
!
! Routine used in converting a C++ CPP_aperture_scan structure to a Bmad aperture_scan_struct structure.
! This routine is called by aperture_scan_to_c and is not meant to be called directly.
!
! Input:
!   ...etc... -- Components of the structure. See the aperture_scan_to_f2 code for more details.
!
! Output:
!   Fp -- type(c_ptr), value :: Bmad aperture_scan_struct structure.
!-

!! f_side.to_c2_f2_sub_arg
subroutine aperture_scan_to_f2 (Fp, z_point, n1_point, z_ref_orb, z_pz_start) bind(c)


implicit none

type(c_ptr), value :: Fp
type(aperture_scan_struct), pointer :: F
integer jd, jd1, jd2, jd3, lb1, lb2, lb3
!! f_side.to_f2_var && f_side.to_f2_type :: f_side.to_f2_name
type(c_ptr) :: z_point(*)
integer(c_int), value :: n1_point
type(c_ptr), value :: z_ref_orb
real(c_double) :: z_pz_start

call c_f_pointer (Fp, F)

!! f_side.to_f2_trans[type, 1, ALLOC]
if (n1_point == 0) then
  if (allocated(F%point)) deallocate(F%point)
else
  if (allocated(F%point)) then
    if (n1_point == 0 .or. any(shape(F%point) /= [n1_point])) deallocate(F%point)
    if (any(lbound(F%point) /= 1)) deallocate(F%point)
  endif
  if (.not. allocated(F%point)) allocate(F%point(1:n1_point+1-1))
  do jd1 = 1, n1_point
    call aperture_point_to_f (z_point(jd1), c_loc(F%point(jd1+1-1)))
  enddo
endif

!! f_side.to_f2_trans[type, 0, NOT]
call coord_to_f(z_ref_orb, c_loc(F%ref_orb))
!! f_side.to_f2_trans[real, 0, NOT]
F%pz_start = z_pz_start

end subroutine aperture_scan_to_f2
end module
