
//+
// C++ classes definitions for Bmad / C++ structure interface.
//
// This file is generated as part of the Bmad/C++ interface code generation.
// The code generation files can be found in cpp_bmad_interface.
//
// DO NOT EDIT THIS FILE DIRECTLY! 
//-

#ifndef CPP_BMAD_CLASSES

#include <string>
#include <valarray>
#include <complex>
#include "bmad_enums.h"
#include "bmad_std_typedef.h"

class CPP_spline;
typedef valarray<CPP_spline>          CPP_spline_ARRAY;
typedef valarray<CPP_spline_ARRAY>    CPP_spline_MATRIX;
typedef valarray<CPP_spline_MATRIX>   CPP_spline_TENSOR;

class CPP_spin_polar;
typedef valarray<CPP_spin_polar>          CPP_spin_polar_ARRAY;
typedef valarray<CPP_spin_polar_ARRAY>    CPP_spin_polar_MATRIX;
typedef valarray<CPP_spin_polar_MATRIX>   CPP_spin_polar_TENSOR;

class CPP_surface_orientation;
typedef valarray<CPP_surface_orientation>          CPP_surface_orientation_ARRAY;
typedef valarray<CPP_surface_orientation_ARRAY>    CPP_surface_orientation_MATRIX;
typedef valarray<CPP_surface_orientation_MATRIX>   CPP_surface_orientation_TENSOR;

class CPP_ac_kicker_time;
typedef valarray<CPP_ac_kicker_time>          CPP_ac_kicker_time_ARRAY;
typedef valarray<CPP_ac_kicker_time_ARRAY>    CPP_ac_kicker_time_MATRIX;
typedef valarray<CPP_ac_kicker_time_MATRIX>   CPP_ac_kicker_time_TENSOR;

class CPP_ac_kicker_freq;
typedef valarray<CPP_ac_kicker_freq>          CPP_ac_kicker_freq_ARRAY;
typedef valarray<CPP_ac_kicker_freq_ARRAY>    CPP_ac_kicker_freq_MATRIX;
typedef valarray<CPP_ac_kicker_freq_MATRIX>   CPP_ac_kicker_freq_TENSOR;

class CPP_ac_kicker;
typedef valarray<CPP_ac_kicker>          CPP_ac_kicker_ARRAY;
typedef valarray<CPP_ac_kicker_ARRAY>    CPP_ac_kicker_MATRIX;
typedef valarray<CPP_ac_kicker_MATRIX>   CPP_ac_kicker_TENSOR;

class CPP_interval1_coef;
typedef valarray<CPP_interval1_coef>          CPP_interval1_coef_ARRAY;
typedef valarray<CPP_interval1_coef_ARRAY>    CPP_interval1_coef_MATRIX;
typedef valarray<CPP_interval1_coef_MATRIX>   CPP_interval1_coef_TENSOR;

class CPP_photon_reflect_table;
typedef valarray<CPP_photon_reflect_table>          CPP_photon_reflect_table_ARRAY;
typedef valarray<CPP_photon_reflect_table_ARRAY>    CPP_photon_reflect_table_MATRIX;
typedef valarray<CPP_photon_reflect_table_MATRIX>   CPP_photon_reflect_table_TENSOR;

class CPP_photon_reflect_surface;
typedef valarray<CPP_photon_reflect_surface>          CPP_photon_reflect_surface_ARRAY;
typedef valarray<CPP_photon_reflect_surface_ARRAY>    CPP_photon_reflect_surface_MATRIX;
typedef valarray<CPP_photon_reflect_surface_MATRIX>   CPP_photon_reflect_surface_TENSOR;

class CPP_coord;
typedef valarray<CPP_coord>          CPP_coord_ARRAY;
typedef valarray<CPP_coord_ARRAY>    CPP_coord_MATRIX;
typedef valarray<CPP_coord_MATRIX>   CPP_coord_TENSOR;

class CPP_coord_array;
typedef valarray<CPP_coord_array>          CPP_coord_array_ARRAY;
typedef valarray<CPP_coord_array_ARRAY>    CPP_coord_array_MATRIX;
typedef valarray<CPP_coord_array_MATRIX>   CPP_coord_array_TENSOR;

class CPP_bpm_phase_coupling;
typedef valarray<CPP_bpm_phase_coupling>          CPP_bpm_phase_coupling_ARRAY;
typedef valarray<CPP_bpm_phase_coupling_ARRAY>    CPP_bpm_phase_coupling_MATRIX;
typedef valarray<CPP_bpm_phase_coupling_MATRIX>   CPP_bpm_phase_coupling_TENSOR;

class CPP_expression_atom;
typedef valarray<CPP_expression_atom>          CPP_expression_atom_ARRAY;
typedef valarray<CPP_expression_atom_ARRAY>    CPP_expression_atom_MATRIX;
typedef valarray<CPP_expression_atom_MATRIX>   CPP_expression_atom_TENSOR;

class CPP_wake_sr_mode;
typedef valarray<CPP_wake_sr_mode>          CPP_wake_sr_mode_ARRAY;
typedef valarray<CPP_wake_sr_mode_ARRAY>    CPP_wake_sr_mode_MATRIX;
typedef valarray<CPP_wake_sr_mode_MATRIX>   CPP_wake_sr_mode_TENSOR;

class CPP_wake_sr;
typedef valarray<CPP_wake_sr>          CPP_wake_sr_ARRAY;
typedef valarray<CPP_wake_sr_ARRAY>    CPP_wake_sr_MATRIX;
typedef valarray<CPP_wake_sr_MATRIX>   CPP_wake_sr_TENSOR;

class CPP_wake_lr_mode;
typedef valarray<CPP_wake_lr_mode>          CPP_wake_lr_mode_ARRAY;
typedef valarray<CPP_wake_lr_mode_ARRAY>    CPP_wake_lr_mode_MATRIX;
typedef valarray<CPP_wake_lr_mode_MATRIX>   CPP_wake_lr_mode_TENSOR;

class CPP_wake_lr;
typedef valarray<CPP_wake_lr>          CPP_wake_lr_ARRAY;
typedef valarray<CPP_wake_lr_ARRAY>    CPP_wake_lr_MATRIX;
typedef valarray<CPP_wake_lr_MATRIX>   CPP_wake_lr_TENSOR;

class CPP_lat_ele_loc;
typedef valarray<CPP_lat_ele_loc>          CPP_lat_ele_loc_ARRAY;
typedef valarray<CPP_lat_ele_loc_ARRAY>    CPP_lat_ele_loc_MATRIX;
typedef valarray<CPP_lat_ele_loc_MATRIX>   CPP_lat_ele_loc_TENSOR;

class CPP_wake;
typedef valarray<CPP_wake>          CPP_wake_ARRAY;
typedef valarray<CPP_wake_ARRAY>    CPP_wake_MATRIX;
typedef valarray<CPP_wake_MATRIX>   CPP_wake_TENSOR;

class CPP_taylor_term;
typedef valarray<CPP_taylor_term>          CPP_taylor_term_ARRAY;
typedef valarray<CPP_taylor_term_ARRAY>    CPP_taylor_term_MATRIX;
typedef valarray<CPP_taylor_term_MATRIX>   CPP_taylor_term_TENSOR;

class CPP_taylor;
typedef valarray<CPP_taylor>          CPP_taylor_ARRAY;
typedef valarray<CPP_taylor_ARRAY>    CPP_taylor_MATRIX;
typedef valarray<CPP_taylor_MATRIX>   CPP_taylor_TENSOR;

class CPP_em_taylor_term;
typedef valarray<CPP_em_taylor_term>          CPP_em_taylor_term_ARRAY;
typedef valarray<CPP_em_taylor_term_ARRAY>    CPP_em_taylor_term_MATRIX;
typedef valarray<CPP_em_taylor_term_MATRIX>   CPP_em_taylor_term_TENSOR;

class CPP_em_taylor;
typedef valarray<CPP_em_taylor>          CPP_em_taylor_ARRAY;
typedef valarray<CPP_em_taylor_ARRAY>    CPP_em_taylor_MATRIX;
typedef valarray<CPP_em_taylor_MATRIX>   CPP_em_taylor_TENSOR;

class CPP_cartesian_map_term1;
typedef valarray<CPP_cartesian_map_term1>          CPP_cartesian_map_term1_ARRAY;
typedef valarray<CPP_cartesian_map_term1_ARRAY>    CPP_cartesian_map_term1_MATRIX;
typedef valarray<CPP_cartesian_map_term1_MATRIX>   CPP_cartesian_map_term1_TENSOR;

class CPP_cartesian_map_term;
typedef valarray<CPP_cartesian_map_term>          CPP_cartesian_map_term_ARRAY;
typedef valarray<CPP_cartesian_map_term_ARRAY>    CPP_cartesian_map_term_MATRIX;
typedef valarray<CPP_cartesian_map_term_MATRIX>   CPP_cartesian_map_term_TENSOR;

class CPP_cartesian_map;
typedef valarray<CPP_cartesian_map>          CPP_cartesian_map_ARRAY;
typedef valarray<CPP_cartesian_map_ARRAY>    CPP_cartesian_map_MATRIX;
typedef valarray<CPP_cartesian_map_MATRIX>   CPP_cartesian_map_TENSOR;

class CPP_cylindrical_map_term1;
typedef valarray<CPP_cylindrical_map_term1>          CPP_cylindrical_map_term1_ARRAY;
typedef valarray<CPP_cylindrical_map_term1_ARRAY>    CPP_cylindrical_map_term1_MATRIX;
typedef valarray<CPP_cylindrical_map_term1_MATRIX>   CPP_cylindrical_map_term1_TENSOR;

class CPP_cylindrical_map_term;
typedef valarray<CPP_cylindrical_map_term>          CPP_cylindrical_map_term_ARRAY;
typedef valarray<CPP_cylindrical_map_term_ARRAY>    CPP_cylindrical_map_term_MATRIX;
typedef valarray<CPP_cylindrical_map_term_MATRIX>   CPP_cylindrical_map_term_TENSOR;

class CPP_cylindrical_map;
typedef valarray<CPP_cylindrical_map>          CPP_cylindrical_map_ARRAY;
typedef valarray<CPP_cylindrical_map_ARRAY>    CPP_cylindrical_map_MATRIX;
typedef valarray<CPP_cylindrical_map_MATRIX>   CPP_cylindrical_map_TENSOR;

class CPP_grid_field_pt1;
typedef valarray<CPP_grid_field_pt1>          CPP_grid_field_pt1_ARRAY;
typedef valarray<CPP_grid_field_pt1_ARRAY>    CPP_grid_field_pt1_MATRIX;
typedef valarray<CPP_grid_field_pt1_MATRIX>   CPP_grid_field_pt1_TENSOR;

class CPP_grid_field_pt;
typedef valarray<CPP_grid_field_pt>          CPP_grid_field_pt_ARRAY;
typedef valarray<CPP_grid_field_pt_ARRAY>    CPP_grid_field_pt_MATRIX;
typedef valarray<CPP_grid_field_pt_MATRIX>   CPP_grid_field_pt_TENSOR;

class CPP_grid_field;
typedef valarray<CPP_grid_field>          CPP_grid_field_ARRAY;
typedef valarray<CPP_grid_field_ARRAY>    CPP_grid_field_MATRIX;
typedef valarray<CPP_grid_field_MATRIX>   CPP_grid_field_TENSOR;

class CPP_floor_position;
typedef valarray<CPP_floor_position>          CPP_floor_position_ARRAY;
typedef valarray<CPP_floor_position_ARRAY>    CPP_floor_position_MATRIX;
typedef valarray<CPP_floor_position_MATRIX>   CPP_floor_position_TENSOR;

class CPP_high_energy_space_charge;
typedef valarray<CPP_high_energy_space_charge>          CPP_high_energy_space_charge_ARRAY;
typedef valarray<CPP_high_energy_space_charge_ARRAY>    CPP_high_energy_space_charge_MATRIX;
typedef valarray<CPP_high_energy_space_charge_MATRIX>   CPP_high_energy_space_charge_TENSOR;

class CPP_xy_disp;
typedef valarray<CPP_xy_disp>          CPP_xy_disp_ARRAY;
typedef valarray<CPP_xy_disp_ARRAY>    CPP_xy_disp_MATRIX;
typedef valarray<CPP_xy_disp_MATRIX>   CPP_xy_disp_TENSOR;

class CPP_twiss;
typedef valarray<CPP_twiss>          CPP_twiss_ARRAY;
typedef valarray<CPP_twiss_ARRAY>    CPP_twiss_MATRIX;
typedef valarray<CPP_twiss_MATRIX>   CPP_twiss_TENSOR;

class CPP_mode3;
typedef valarray<CPP_mode3>          CPP_mode3_ARRAY;
typedef valarray<CPP_mode3_ARRAY>    CPP_mode3_MATRIX;
typedef valarray<CPP_mode3_MATRIX>   CPP_mode3_TENSOR;

class CPP_bookkeeping_state;
typedef valarray<CPP_bookkeeping_state>          CPP_bookkeeping_state_ARRAY;
typedef valarray<CPP_bookkeeping_state_ARRAY>    CPP_bookkeeping_state_MATRIX;
typedef valarray<CPP_bookkeeping_state_MATRIX>   CPP_bookkeeping_state_TENSOR;

class CPP_rad_map;
typedef valarray<CPP_rad_map>          CPP_rad_map_ARRAY;
typedef valarray<CPP_rad_map_ARRAY>    CPP_rad_map_MATRIX;
typedef valarray<CPP_rad_map_MATRIX>   CPP_rad_map_TENSOR;

class CPP_rad_map_ele;
typedef valarray<CPP_rad_map_ele>          CPP_rad_map_ele_ARRAY;
typedef valarray<CPP_rad_map_ele_ARRAY>    CPP_rad_map_ele_MATRIX;
typedef valarray<CPP_rad_map_ele_MATRIX>   CPP_rad_map_ele_TENSOR;

class CPP_gen_grad1;
typedef valarray<CPP_gen_grad1>          CPP_gen_grad1_ARRAY;
typedef valarray<CPP_gen_grad1_ARRAY>    CPP_gen_grad1_MATRIX;
typedef valarray<CPP_gen_grad1_MATRIX>   CPP_gen_grad1_TENSOR;

class CPP_gen_grad_map;
typedef valarray<CPP_gen_grad_map>          CPP_gen_grad_map_ARRAY;
typedef valarray<CPP_gen_grad_map_ARRAY>    CPP_gen_grad_map_MATRIX;
typedef valarray<CPP_gen_grad_map_MATRIX>   CPP_gen_grad_map_TENSOR;

class CPP_surface_grid_pt;
typedef valarray<CPP_surface_grid_pt>          CPP_surface_grid_pt_ARRAY;
typedef valarray<CPP_surface_grid_pt_ARRAY>    CPP_surface_grid_pt_MATRIX;
typedef valarray<CPP_surface_grid_pt_MATRIX>   CPP_surface_grid_pt_TENSOR;

class CPP_surface_grid;
typedef valarray<CPP_surface_grid>          CPP_surface_grid_ARRAY;
typedef valarray<CPP_surface_grid_ARRAY>    CPP_surface_grid_MATRIX;
typedef valarray<CPP_surface_grid_MATRIX>   CPP_surface_grid_TENSOR;

class CPP_target_point;
typedef valarray<CPP_target_point>          CPP_target_point_ARRAY;
typedef valarray<CPP_target_point_ARRAY>    CPP_target_point_MATRIX;
typedef valarray<CPP_target_point_MATRIX>   CPP_target_point_TENSOR;

class CPP_surface_curvature;
typedef valarray<CPP_surface_curvature>          CPP_surface_curvature_ARRAY;
typedef valarray<CPP_surface_curvature_ARRAY>    CPP_surface_curvature_MATRIX;
typedef valarray<CPP_surface_curvature_MATRIX>   CPP_surface_curvature_TENSOR;

class CPP_photon_target;
typedef valarray<CPP_photon_target>          CPP_photon_target_ARRAY;
typedef valarray<CPP_photon_target_ARRAY>    CPP_photon_target_MATRIX;
typedef valarray<CPP_photon_target_MATRIX>   CPP_photon_target_TENSOR;

class CPP_photon_material;
typedef valarray<CPP_photon_material>          CPP_photon_material_ARRAY;
typedef valarray<CPP_photon_material_ARRAY>    CPP_photon_material_MATRIX;
typedef valarray<CPP_photon_material_MATRIX>   CPP_photon_material_TENSOR;

class CPP_pixel_pt;
typedef valarray<CPP_pixel_pt>          CPP_pixel_pt_ARRAY;
typedef valarray<CPP_pixel_pt_ARRAY>    CPP_pixel_pt_MATRIX;
typedef valarray<CPP_pixel_pt_MATRIX>   CPP_pixel_pt_TENSOR;

class CPP_pixel_detec;
typedef valarray<CPP_pixel_detec>          CPP_pixel_detec_ARRAY;
typedef valarray<CPP_pixel_detec_ARRAY>    CPP_pixel_detec_MATRIX;
typedef valarray<CPP_pixel_detec_MATRIX>   CPP_pixel_detec_TENSOR;

class CPP_photon_element;
typedef valarray<CPP_photon_element>          CPP_photon_element_ARRAY;
typedef valarray<CPP_photon_element_ARRAY>    CPP_photon_element_MATRIX;
typedef valarray<CPP_photon_element_MATRIX>   CPP_photon_element_TENSOR;

class CPP_wall3d_vertex;
typedef valarray<CPP_wall3d_vertex>          CPP_wall3d_vertex_ARRAY;
typedef valarray<CPP_wall3d_vertex_ARRAY>    CPP_wall3d_vertex_MATRIX;
typedef valarray<CPP_wall3d_vertex_MATRIX>   CPP_wall3d_vertex_TENSOR;

class CPP_wall3d_section;
typedef valarray<CPP_wall3d_section>          CPP_wall3d_section_ARRAY;
typedef valarray<CPP_wall3d_section_ARRAY>    CPP_wall3d_section_MATRIX;
typedef valarray<CPP_wall3d_section_MATRIX>   CPP_wall3d_section_TENSOR;

class CPP_wall3d;
typedef valarray<CPP_wall3d>          CPP_wall3d_ARRAY;
typedef valarray<CPP_wall3d_ARRAY>    CPP_wall3d_MATRIX;
typedef valarray<CPP_wall3d_MATRIX>   CPP_wall3d_TENSOR;

class CPP_control;
typedef valarray<CPP_control>          CPP_control_ARRAY;
typedef valarray<CPP_control_ARRAY>    CPP_control_MATRIX;
typedef valarray<CPP_control_MATRIX>   CPP_control_TENSOR;

class CPP_control_var1;
typedef valarray<CPP_control_var1>          CPP_control_var1_ARRAY;
typedef valarray<CPP_control_var1_ARRAY>    CPP_control_var1_MATRIX;
typedef valarray<CPP_control_var1_MATRIX>   CPP_control_var1_TENSOR;

class CPP_control_ramp1;
typedef valarray<CPP_control_ramp1>          CPP_control_ramp1_ARRAY;
typedef valarray<CPP_control_ramp1_ARRAY>    CPP_control_ramp1_MATRIX;
typedef valarray<CPP_control_ramp1_MATRIX>   CPP_control_ramp1_TENSOR;

class CPP_controller;
typedef valarray<CPP_controller>          CPP_controller_ARRAY;
typedef valarray<CPP_controller_ARRAY>    CPP_controller_MATRIX;
typedef valarray<CPP_controller_MATRIX>   CPP_controller_TENSOR;

class CPP_ellipse_beam_init;
typedef valarray<CPP_ellipse_beam_init>          CPP_ellipse_beam_init_ARRAY;
typedef valarray<CPP_ellipse_beam_init_ARRAY>    CPP_ellipse_beam_init_MATRIX;
typedef valarray<CPP_ellipse_beam_init_MATRIX>   CPP_ellipse_beam_init_TENSOR;

class CPP_kv_beam_init;
typedef valarray<CPP_kv_beam_init>          CPP_kv_beam_init_ARRAY;
typedef valarray<CPP_kv_beam_init_ARRAY>    CPP_kv_beam_init_MATRIX;
typedef valarray<CPP_kv_beam_init_MATRIX>   CPP_kv_beam_init_TENSOR;

class CPP_grid_beam_init;
typedef valarray<CPP_grid_beam_init>          CPP_grid_beam_init_ARRAY;
typedef valarray<CPP_grid_beam_init_ARRAY>    CPP_grid_beam_init_MATRIX;
typedef valarray<CPP_grid_beam_init_MATRIX>   CPP_grid_beam_init_TENSOR;

class CPP_beam_init;
typedef valarray<CPP_beam_init>          CPP_beam_init_ARRAY;
typedef valarray<CPP_beam_init_ARRAY>    CPP_beam_init_MATRIX;
typedef valarray<CPP_beam_init_MATRIX>   CPP_beam_init_TENSOR;

class CPP_lat_param;
typedef valarray<CPP_lat_param>          CPP_lat_param_ARRAY;
typedef valarray<CPP_lat_param_ARRAY>    CPP_lat_param_MATRIX;
typedef valarray<CPP_lat_param_MATRIX>   CPP_lat_param_TENSOR;

class CPP_mode_info;
typedef valarray<CPP_mode_info>          CPP_mode_info_ARRAY;
typedef valarray<CPP_mode_info_ARRAY>    CPP_mode_info_MATRIX;
typedef valarray<CPP_mode_info_MATRIX>   CPP_mode_info_TENSOR;

class CPP_pre_tracker;
typedef valarray<CPP_pre_tracker>          CPP_pre_tracker_ARRAY;
typedef valarray<CPP_pre_tracker_ARRAY>    CPP_pre_tracker_MATRIX;
typedef valarray<CPP_pre_tracker_MATRIX>   CPP_pre_tracker_TENSOR;

class CPP_anormal_mode;
typedef valarray<CPP_anormal_mode>          CPP_anormal_mode_ARRAY;
typedef valarray<CPP_anormal_mode_ARRAY>    CPP_anormal_mode_MATRIX;
typedef valarray<CPP_anormal_mode_MATRIX>   CPP_anormal_mode_TENSOR;

class CPP_linac_normal_mode;
typedef valarray<CPP_linac_normal_mode>          CPP_linac_normal_mode_ARRAY;
typedef valarray<CPP_linac_normal_mode_ARRAY>    CPP_linac_normal_mode_MATRIX;
typedef valarray<CPP_linac_normal_mode_MATRIX>   CPP_linac_normal_mode_TENSOR;

class CPP_normal_modes;
typedef valarray<CPP_normal_modes>          CPP_normal_modes_ARRAY;
typedef valarray<CPP_normal_modes_ARRAY>    CPP_normal_modes_MATRIX;
typedef valarray<CPP_normal_modes_MATRIX>   CPP_normal_modes_TENSOR;

class CPP_em_field;
typedef valarray<CPP_em_field>          CPP_em_field_ARRAY;
typedef valarray<CPP_em_field_ARRAY>    CPP_em_field_MATRIX;
typedef valarray<CPP_em_field_MATRIX>   CPP_em_field_TENSOR;

class CPP_strong_beam;
typedef valarray<CPP_strong_beam>          CPP_strong_beam_ARRAY;
typedef valarray<CPP_strong_beam_ARRAY>    CPP_strong_beam_MATRIX;
typedef valarray<CPP_strong_beam_MATRIX>   CPP_strong_beam_TENSOR;

class CPP_track_point;
typedef valarray<CPP_track_point>          CPP_track_point_ARRAY;
typedef valarray<CPP_track_point_ARRAY>    CPP_track_point_MATRIX;
typedef valarray<CPP_track_point_MATRIX>   CPP_track_point_TENSOR;

class CPP_track;
typedef valarray<CPP_track>          CPP_track_ARRAY;
typedef valarray<CPP_track_ARRAY>    CPP_track_MATRIX;
typedef valarray<CPP_track_MATRIX>   CPP_track_TENSOR;

class CPP_space_charge_common;
typedef valarray<CPP_space_charge_common>          CPP_space_charge_common_ARRAY;
typedef valarray<CPP_space_charge_common_ARRAY>    CPP_space_charge_common_MATRIX;
typedef valarray<CPP_space_charge_common_MATRIX>   CPP_space_charge_common_TENSOR;

class CPP_bmad_common;
typedef valarray<CPP_bmad_common>          CPP_bmad_common_ARRAY;
typedef valarray<CPP_bmad_common_ARRAY>    CPP_bmad_common_MATRIX;
typedef valarray<CPP_bmad_common_MATRIX>   CPP_bmad_common_TENSOR;

class CPP_rad_int1;
typedef valarray<CPP_rad_int1>          CPP_rad_int1_ARRAY;
typedef valarray<CPP_rad_int1_ARRAY>    CPP_rad_int1_MATRIX;
typedef valarray<CPP_rad_int1_MATRIX>   CPP_rad_int1_TENSOR;

class CPP_rad_int_branch;
typedef valarray<CPP_rad_int_branch>          CPP_rad_int_branch_ARRAY;
typedef valarray<CPP_rad_int_branch_ARRAY>    CPP_rad_int_branch_MATRIX;
typedef valarray<CPP_rad_int_branch_MATRIX>   CPP_rad_int_branch_TENSOR;

class CPP_rad_int_all_ele;
typedef valarray<CPP_rad_int_all_ele>          CPP_rad_int_all_ele_ARRAY;
typedef valarray<CPP_rad_int_all_ele_ARRAY>    CPP_rad_int_all_ele_MATRIX;
typedef valarray<CPP_rad_int_all_ele_MATRIX>   CPP_rad_int_all_ele_TENSOR;

class CPP_ele;
typedef valarray<CPP_ele>          CPP_ele_ARRAY;
typedef valarray<CPP_ele_ARRAY>    CPP_ele_MATRIX;
typedef valarray<CPP_ele_MATRIX>   CPP_ele_TENSOR;

class CPP_complex_taylor_term;
typedef valarray<CPP_complex_taylor_term>          CPP_complex_taylor_term_ARRAY;
typedef valarray<CPP_complex_taylor_term_ARRAY>    CPP_complex_taylor_term_MATRIX;
typedef valarray<CPP_complex_taylor_term_MATRIX>   CPP_complex_taylor_term_TENSOR;

class CPP_complex_taylor;
typedef valarray<CPP_complex_taylor>          CPP_complex_taylor_ARRAY;
typedef valarray<CPP_complex_taylor_ARRAY>    CPP_complex_taylor_MATRIX;
typedef valarray<CPP_complex_taylor_MATRIX>   CPP_complex_taylor_TENSOR;

class CPP_branch;
typedef valarray<CPP_branch>          CPP_branch_ARRAY;
typedef valarray<CPP_branch_ARRAY>    CPP_branch_MATRIX;
typedef valarray<CPP_branch_MATRIX>   CPP_branch_TENSOR;

class CPP_lat;
typedef valarray<CPP_lat>          CPP_lat_ARRAY;
typedef valarray<CPP_lat_ARRAY>    CPP_lat_MATRIX;
typedef valarray<CPP_lat_MATRIX>   CPP_lat_TENSOR;

class CPP_bunch;
typedef valarray<CPP_bunch>          CPP_bunch_ARRAY;
typedef valarray<CPP_bunch_ARRAY>    CPP_bunch_MATRIX;
typedef valarray<CPP_bunch_MATRIX>   CPP_bunch_TENSOR;

class CPP_bunch_params;
typedef valarray<CPP_bunch_params>          CPP_bunch_params_ARRAY;
typedef valarray<CPP_bunch_params_ARRAY>    CPP_bunch_params_MATRIX;
typedef valarray<CPP_bunch_params_MATRIX>   CPP_bunch_params_TENSOR;

class CPP_beam;
typedef valarray<CPP_beam>          CPP_beam_ARRAY;
typedef valarray<CPP_beam_ARRAY>    CPP_beam_MATRIX;
typedef valarray<CPP_beam_MATRIX>   CPP_beam_TENSOR;

class CPP_aperture_point;
typedef valarray<CPP_aperture_point>          CPP_aperture_point_ARRAY;
typedef valarray<CPP_aperture_point_ARRAY>    CPP_aperture_point_MATRIX;
typedef valarray<CPP_aperture_point_MATRIX>   CPP_aperture_point_TENSOR;

class CPP_aperture_param;
typedef valarray<CPP_aperture_param>          CPP_aperture_param_ARRAY;
typedef valarray<CPP_aperture_param_ARRAY>    CPP_aperture_param_MATRIX;
typedef valarray<CPP_aperture_param_MATRIX>   CPP_aperture_param_TENSOR;

class CPP_aperture_scan;
typedef valarray<CPP_aperture_scan>          CPP_aperture_scan_ARRAY;
typedef valarray<CPP_aperture_scan_ARRAY>    CPP_aperture_scan_MATRIX;
typedef valarray<CPP_aperture_scan_MATRIX>   CPP_aperture_scan_TENSOR;

//--------------------------------------------------------------------
// CPP_spline

class Opaque_spline_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_spline {
public:
  Real x0;
  Real y0;
  Real x1;
  Real_ARRAY coef;

  CPP_spline() :
    x0(0.0),
    y0(0.0),
    x1(0.0),
    coef(0.0, 4)
    {}

  ~CPP_spline() {
  }

};   // End Class

extern "C" void spline_to_c (const Opaque_spline_class*, CPP_spline&);
extern "C" void spline_to_f (const CPP_spline&, Opaque_spline_class*);

bool operator== (const CPP_spline&, const CPP_spline&);


//--------------------------------------------------------------------
// CPP_spin_polar

class Opaque_spin_polar_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_spin_polar {
public:
  Real polarization;
  Real theta;
  Real phi;
  Real xi;

  CPP_spin_polar() :
    polarization(1),
    theta(0.0),
    phi(0.0),
    xi(0.0)
    {}

  ~CPP_spin_polar() {
  }

};   // End Class

extern "C" void spin_polar_to_c (const Opaque_spin_polar_class*, CPP_spin_polar&);
extern "C" void spin_polar_to_f (const CPP_spin_polar&, Opaque_spin_polar_class*);

bool operator== (const CPP_spin_polar&, const CPP_spin_polar&);


//--------------------------------------------------------------------
// CPP_surface_orientation

class Opaque_surface_orientation_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_surface_orientation {
public:
  Real dz_dx;
  Real dz_dy;
  Real dz_dx_rms;
  Real dz_dy_rms;
  Real dz2_dxdy;

  CPP_surface_orientation() :
    dz_dx(0.0),
    dz_dy(0.0),
    dz_dx_rms(0.0),
    dz_dy_rms(0.0),
    dz2_dxdy(0.0)
    {}

  ~CPP_surface_orientation() {
  }

};   // End Class

extern "C" void surface_orientation_to_c (const Opaque_surface_orientation_class*, CPP_surface_orientation&);
extern "C" void surface_orientation_to_f (const CPP_surface_orientation&, Opaque_surface_orientation_class*);

bool operator== (const CPP_surface_orientation&, const CPP_surface_orientation&);


//--------------------------------------------------------------------
// CPP_ac_kicker_time

class Opaque_ac_kicker_time_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_ac_kicker_time {
public:
  Real amp;
  Real time;
  CPP_spline spline;

  CPP_ac_kicker_time() :
    amp(0.0),
    time(0.0),
    spline()
    {}

  ~CPP_ac_kicker_time() {
  }

};   // End Class

extern "C" void ac_kicker_time_to_c (const Opaque_ac_kicker_time_class*, CPP_ac_kicker_time&);
extern "C" void ac_kicker_time_to_f (const CPP_ac_kicker_time&, Opaque_ac_kicker_time_class*);

bool operator== (const CPP_ac_kicker_time&, const CPP_ac_kicker_time&);


//--------------------------------------------------------------------
// CPP_ac_kicker_freq

class Opaque_ac_kicker_freq_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_ac_kicker_freq {
public:
  Real f;
  Real amp;
  Real phi;
  Int rf_clock_harmonic;

  CPP_ac_kicker_freq() :
    f(0.0),
    amp(0.0),
    phi(0.0),
    rf_clock_harmonic(0)
    {}

  ~CPP_ac_kicker_freq() {
  }

};   // End Class

extern "C" void ac_kicker_freq_to_c (const Opaque_ac_kicker_freq_class*, CPP_ac_kicker_freq&);
extern "C" void ac_kicker_freq_to_f (const CPP_ac_kicker_freq&, Opaque_ac_kicker_freq_class*);

bool operator== (const CPP_ac_kicker_freq&, const CPP_ac_kicker_freq&);


//--------------------------------------------------------------------
// CPP_ac_kicker

class Opaque_ac_kicker_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_ac_kicker {
public:
  CPP_ac_kicker_time_ARRAY amp_vs_time;
  CPP_ac_kicker_freq_ARRAY frequency;

  CPP_ac_kicker() :
    amp_vs_time(CPP_ac_kicker_time_ARRAY(CPP_ac_kicker_time(), 0)),
    frequency(CPP_ac_kicker_freq_ARRAY(CPP_ac_kicker_freq(), 0))
    {}

  ~CPP_ac_kicker() {
  }

};   // End Class

extern "C" void ac_kicker_to_c (const Opaque_ac_kicker_class*, CPP_ac_kicker&);
extern "C" void ac_kicker_to_f (const CPP_ac_kicker&, Opaque_ac_kicker_class*);

bool operator== (const CPP_ac_kicker&, const CPP_ac_kicker&);


//--------------------------------------------------------------------
// CPP_interval1_coef

class Opaque_interval1_coef_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_interval1_coef {
public:
  Real c0;
  Real c1;
  Real n_exp;

  CPP_interval1_coef() :
    c0(0.0),
    c1(0.0),
    n_exp(0.0)
    {}

  ~CPP_interval1_coef() {
  }

};   // End Class

extern "C" void interval1_coef_to_c (const Opaque_interval1_coef_class*, CPP_interval1_coef&);
extern "C" void interval1_coef_to_f (const CPP_interval1_coef&, Opaque_interval1_coef_class*);

bool operator== (const CPP_interval1_coef&, const CPP_interval1_coef&);


//--------------------------------------------------------------------
// CPP_photon_reflect_table

class Opaque_photon_reflect_table_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_reflect_table {
public:
  Real_ARRAY angle;
  Real_ARRAY energy;
  CPP_interval1_coef_ARRAY int1;
  Real_MATRIX p_reflect;
  Real max_energy;
  Real_ARRAY p_reflect_scratch;
  Real_ARRAY bragg_angle;

  CPP_photon_reflect_table() :
    angle(0.0, 0),
    energy(0.0, 0),
    int1(CPP_interval1_coef_ARRAY(CPP_interval1_coef(), 0)),
    p_reflect(Real_ARRAY(0.0, 0), 0),
    max_energy(-1),
    p_reflect_scratch(0.0, 0),
    bragg_angle(0.0, 0)
    {}

  ~CPP_photon_reflect_table() {
  }

};   // End Class

extern "C" void photon_reflect_table_to_c (const Opaque_photon_reflect_table_class*, CPP_photon_reflect_table&);
extern "C" void photon_reflect_table_to_f (const CPP_photon_reflect_table&, Opaque_photon_reflect_table_class*);

bool operator== (const CPP_photon_reflect_table&, const CPP_photon_reflect_table&);


//--------------------------------------------------------------------
// CPP_photon_reflect_surface

class Opaque_photon_reflect_surface_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_reflect_surface {
public:
  string name;
  string description;
  string reflectivity_file;
  CPP_photon_reflect_table_ARRAY table;
  Real surface_roughness_rms;
  Real roughness_correlation_len;
  Int ix_surface;

  CPP_photon_reflect_surface() :
    name(),
    description(),
    reflectivity_file(),
    table(CPP_photon_reflect_table_ARRAY(CPP_photon_reflect_table(), 0)),
    surface_roughness_rms(0.0),
    roughness_correlation_len(0.0),
    ix_surface(-1)
    {}

  ~CPP_photon_reflect_surface() {
  }

};   // End Class

extern "C" void photon_reflect_surface_to_c (const Opaque_photon_reflect_surface_class*, CPP_photon_reflect_surface&);
extern "C" void photon_reflect_surface_to_f (const CPP_photon_reflect_surface&, Opaque_photon_reflect_surface_class*);

bool operator== (const CPP_photon_reflect_surface&, const CPP_photon_reflect_surface&);


//--------------------------------------------------------------------
// CPP_coord

class Opaque_coord_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_coord {
public:
  Real_ARRAY vec;
  Real s;
  Real t;
  Real_ARRAY spin;
  Real_ARRAY field;
  Real_ARRAY phase;
  Real charge;
  Real dt_ref;
  Real r;
  Real p0c;
  Real e_potential;
  Real beta;
  Int ix_ele;
  Int ix_branch;
  Int ix_turn;
  Int ix_user;
  Int state;
  Int direction;
  Int time_dir;
  Int species;
  Int location;

  CPP_coord() :
    vec(0.0, 6),
    s(0.0),
    t(0.0),
    spin(0.0, 3),
    field(0.0, 2),
    phase(0.0, 2),
    charge(0.0),
    dt_ref(0.0),
    r(0.0),
    p0c(0.0),
    e_potential(0.0),
    beta(-1),
    ix_ele(-1),
    ix_branch(-1),
    ix_turn(0),
    ix_user(-1),
    state(Bmad::NOT_SET),
    direction(1),
    time_dir(1),
    species(Bmad::NOT_SET),
    location(Bmad::UPSTREAM_END)
    {}

  ~CPP_coord() {
  }

};   // End Class

extern "C" void coord_to_c (const Opaque_coord_class*, CPP_coord&);
extern "C" void coord_to_f (const CPP_coord&, Opaque_coord_class*);

bool operator== (const CPP_coord&, const CPP_coord&);


//--------------------------------------------------------------------
// CPP_coord_array

class Opaque_coord_array_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_coord_array {
public:
  CPP_coord_ARRAY orbit;

  CPP_coord_array() :
    orbit(CPP_coord_ARRAY(CPP_coord(), 0))
    {}

  ~CPP_coord_array() {
  }

};   // End Class

extern "C" void coord_array_to_c (const Opaque_coord_array_class*, CPP_coord_array&);
extern "C" void coord_array_to_f (const CPP_coord_array&, Opaque_coord_array_class*);

bool operator== (const CPP_coord_array&, const CPP_coord_array&);


//--------------------------------------------------------------------
// CPP_bpm_phase_coupling

class Opaque_bpm_phase_coupling_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_bpm_phase_coupling {
public:
  Real k_22a;
  Real k_12a;
  Real k_11b;
  Real k_12b;
  Real cbar22_a;
  Real cbar12_a;
  Real cbar11_b;
  Real cbar12_b;
  Real phi_a;
  Real phi_b;

  CPP_bpm_phase_coupling() :
    k_22a(0.0),
    k_12a(0.0),
    k_11b(0.0),
    k_12b(0.0),
    cbar22_a(0.0),
    cbar12_a(0.0),
    cbar11_b(0.0),
    cbar12_b(0.0),
    phi_a(0.0),
    phi_b(0.0)
    {}

  ~CPP_bpm_phase_coupling() {
  }

};   // End Class

extern "C" void bpm_phase_coupling_to_c (const Opaque_bpm_phase_coupling_class*, CPP_bpm_phase_coupling&);
extern "C" void bpm_phase_coupling_to_f (const CPP_bpm_phase_coupling&, Opaque_bpm_phase_coupling_class*);

bool operator== (const CPP_bpm_phase_coupling&, const CPP_bpm_phase_coupling&);


//--------------------------------------------------------------------
// CPP_expression_atom

class Opaque_expression_atom_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_expression_atom {
public:
  string name;
  Int type;
  Real value;

  CPP_expression_atom() :
    name(),
    type(0),
    value(0.0)
    {}

  ~CPP_expression_atom() {
  }

};   // End Class

extern "C" void expression_atom_to_c (const Opaque_expression_atom_class*, CPP_expression_atom&);
extern "C" void expression_atom_to_f (const CPP_expression_atom&, Opaque_expression_atom_class*);

bool operator== (const CPP_expression_atom&, const CPP_expression_atom&);


//--------------------------------------------------------------------
// CPP_wake_sr_mode

class Opaque_wake_sr_mode_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wake_sr_mode {
public:
  Real amp;
  Real damp;
  Real k;
  Real phi;
  Real b_sin;
  Real b_cos;
  Real a_sin;
  Real a_cos;
  Int polarization;
  Int position_dependence;

  CPP_wake_sr_mode() :
    amp(0.0),
    damp(0.0),
    k(0.0),
    phi(0.0),
    b_sin(0.0),
    b_cos(0.0),
    a_sin(0.0),
    a_cos(0.0),
    polarization(Bmad::NONE),
    position_dependence(Bmad::NOT_SET)
    {}

  ~CPP_wake_sr_mode() {
  }

};   // End Class

extern "C" void wake_sr_mode_to_c (const Opaque_wake_sr_mode_class*, CPP_wake_sr_mode&);
extern "C" void wake_sr_mode_to_f (const CPP_wake_sr_mode&, Opaque_wake_sr_mode_class*);

bool operator== (const CPP_wake_sr_mode&, const CPP_wake_sr_mode&);


//--------------------------------------------------------------------
// CPP_wake_sr

class Opaque_wake_sr_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wake_sr {
public:
  string file;
  CPP_wake_sr_mode_ARRAY long_wake;
  CPP_wake_sr_mode_ARRAY trans_wake;
  Real z_ref_long;
  Real z_ref_trans;
  Real z_max;
  Real amp_scale;
  Real z_scale;
  Bool scale_with_length;

  CPP_wake_sr() :
    file(),
    long_wake(CPP_wake_sr_mode_ARRAY(CPP_wake_sr_mode(), 0)),
    trans_wake(CPP_wake_sr_mode_ARRAY(CPP_wake_sr_mode(), 0)),
    z_ref_long(0.0),
    z_ref_trans(0.0),
    z_max(0.0),
    amp_scale(1),
    z_scale(1),
    scale_with_length(true)
    {}

  ~CPP_wake_sr() {
  }

};   // End Class

extern "C" void wake_sr_to_c (const Opaque_wake_sr_class*, CPP_wake_sr&);
extern "C" void wake_sr_to_f (const CPP_wake_sr&, Opaque_wake_sr_class*);

bool operator== (const CPP_wake_sr&, const CPP_wake_sr&);


//--------------------------------------------------------------------
// CPP_wake_lr_mode

class Opaque_wake_lr_mode_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wake_lr_mode {
public:
  Real freq;
  Real freq_in;
  Real r_over_q;
  Real q;
  Real damp;
  Real phi;
  Real angle;
  Real b_sin;
  Real b_cos;
  Real a_sin;
  Real a_cos;
  Int m;
  Bool polarized;

  CPP_wake_lr_mode() :
    freq(0.0),
    freq_in(0.0),
    r_over_q(0.0),
    q(Bmad::REAL_GARBAGE),
    damp(0.0),
    phi(0.0),
    angle(0.0),
    b_sin(0.0),
    b_cos(0.0),
    a_sin(0.0),
    a_cos(0.0),
    m(0),
    polarized(false)
    {}

  ~CPP_wake_lr_mode() {
  }

};   // End Class

extern "C" void wake_lr_mode_to_c (const Opaque_wake_lr_mode_class*, CPP_wake_lr_mode&);
extern "C" void wake_lr_mode_to_f (const CPP_wake_lr_mode&, Opaque_wake_lr_mode_class*);

bool operator== (const CPP_wake_lr_mode&, const CPP_wake_lr_mode&);


//--------------------------------------------------------------------
// CPP_wake_lr

class Opaque_wake_lr_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wake_lr {
public:
  string file;
  CPP_wake_lr_mode_ARRAY mode;
  Real t_ref;
  Real freq_spread;
  Real amp_scale;
  Real time_scale;
  Bool self_wake_on;

  CPP_wake_lr() :
    file(),
    mode(CPP_wake_lr_mode_ARRAY(CPP_wake_lr_mode(), 0)),
    t_ref(0.0),
    freq_spread(0.0),
    amp_scale(1),
    time_scale(1),
    self_wake_on(true)
    {}

  ~CPP_wake_lr() {
  }

};   // End Class

extern "C" void wake_lr_to_c (const Opaque_wake_lr_class*, CPP_wake_lr&);
extern "C" void wake_lr_to_f (const CPP_wake_lr&, Opaque_wake_lr_class*);

bool operator== (const CPP_wake_lr&, const CPP_wake_lr&);


//--------------------------------------------------------------------
// CPP_lat_ele_loc

class Opaque_lat_ele_loc_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_lat_ele_loc {
public:
  Int ix_ele;
  Int ix_branch;

  CPP_lat_ele_loc() :
    ix_ele(-1),
    ix_branch(0)
    {}

  ~CPP_lat_ele_loc() {
  }

};   // End Class

extern "C" void lat_ele_loc_to_c (const Opaque_lat_ele_loc_class*, CPP_lat_ele_loc&);
extern "C" void lat_ele_loc_to_f (const CPP_lat_ele_loc&, Opaque_lat_ele_loc_class*);

bool operator== (const CPP_lat_ele_loc&, const CPP_lat_ele_loc&);


//--------------------------------------------------------------------
// CPP_wake

class Opaque_wake_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wake {
public:
  CPP_wake_sr sr;
  CPP_wake_lr lr;

  CPP_wake() :
    sr(),
    lr()
    {}

  ~CPP_wake() {
  }

};   // End Class

extern "C" void wake_to_c (const Opaque_wake_class*, CPP_wake&);
extern "C" void wake_to_f (const CPP_wake&, Opaque_wake_class*);

bool operator== (const CPP_wake&, const CPP_wake&);


//--------------------------------------------------------------------
// CPP_taylor_term

class Opaque_taylor_term_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_taylor_term {
public:
  Real coef;
  Int_ARRAY expn;

  CPP_taylor_term() :
    coef(0.0),
    expn(0, 6)
    {}

  ~CPP_taylor_term() {
  }

};   // End Class

extern "C" void taylor_term_to_c (const Opaque_taylor_term_class*, CPP_taylor_term&);
extern "C" void taylor_term_to_f (const CPP_taylor_term&, Opaque_taylor_term_class*);

bool operator== (const CPP_taylor_term&, const CPP_taylor_term&);


//--------------------------------------------------------------------
// CPP_taylor

class Opaque_taylor_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_taylor {
public:
  Real ref;
  CPP_taylor_term_ARRAY term;

  CPP_taylor() :
    ref(0.0),
    term(CPP_taylor_term_ARRAY(CPP_taylor_term(), 0))
    {}

  ~CPP_taylor() {
  }

};   // End Class

extern "C" void taylor_to_c (const Opaque_taylor_class*, CPP_taylor&);
extern "C" void taylor_to_f (const CPP_taylor&, Opaque_taylor_class*);

bool operator== (const CPP_taylor&, const CPP_taylor&);


//--------------------------------------------------------------------
// CPP_em_taylor_term

class Opaque_em_taylor_term_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_em_taylor_term {
public:
  Real coef;
  Int_ARRAY expn;

  CPP_em_taylor_term() :
    coef(0.0),
    expn(0, 2)
    {}

  ~CPP_em_taylor_term() {
  }

};   // End Class

extern "C" void em_taylor_term_to_c (const Opaque_em_taylor_term_class*, CPP_em_taylor_term&);
extern "C" void em_taylor_term_to_f (const CPP_em_taylor_term&, Opaque_em_taylor_term_class*);

bool operator== (const CPP_em_taylor_term&, const CPP_em_taylor_term&);


//--------------------------------------------------------------------
// CPP_em_taylor

class Opaque_em_taylor_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_em_taylor {
public:
  Real ref;
  CPP_em_taylor_term_ARRAY term;

  CPP_em_taylor() :
    ref(0.0),
    term(CPP_em_taylor_term_ARRAY(CPP_em_taylor_term(), 0))
    {}

  ~CPP_em_taylor() {
  }

};   // End Class

extern "C" void em_taylor_to_c (const Opaque_em_taylor_class*, CPP_em_taylor&);
extern "C" void em_taylor_to_f (const CPP_em_taylor&, Opaque_em_taylor_class*);

bool operator== (const CPP_em_taylor&, const CPP_em_taylor&);


//--------------------------------------------------------------------
// CPP_cartesian_map_term1

class Opaque_cartesian_map_term1_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_cartesian_map_term1 {
public:
  Real coef;
  Real kx;
  Real ky;
  Real kz;
  Real x0;
  Real y0;
  Real phi_z;
  Int family;
  Int form;

  CPP_cartesian_map_term1() :
    coef(0.0),
    kx(0.0),
    ky(0.0),
    kz(0.0),
    x0(0.0),
    y0(0.0),
    phi_z(0.0),
    family(0),
    form(0)
    {}

  ~CPP_cartesian_map_term1() {
  }

};   // End Class

extern "C" void cartesian_map_term1_to_c (const Opaque_cartesian_map_term1_class*, CPP_cartesian_map_term1&);
extern "C" void cartesian_map_term1_to_f (const CPP_cartesian_map_term1&, Opaque_cartesian_map_term1_class*);

bool operator== (const CPP_cartesian_map_term1&, const CPP_cartesian_map_term1&);


//--------------------------------------------------------------------
// CPP_cartesian_map_term

class Opaque_cartesian_map_term_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_cartesian_map_term {
public:
  string file;
  Int n_link;
  CPP_cartesian_map_term1_ARRAY term;

  CPP_cartesian_map_term() :
    file(),
    n_link(1),
    term(CPP_cartesian_map_term1_ARRAY(CPP_cartesian_map_term1(), 0))
    {}

  ~CPP_cartesian_map_term() {
  }

};   // End Class

extern "C" void cartesian_map_term_to_c (const Opaque_cartesian_map_term_class*, CPP_cartesian_map_term&);
extern "C" void cartesian_map_term_to_f (const CPP_cartesian_map_term&, Opaque_cartesian_map_term_class*);

bool operator== (const CPP_cartesian_map_term&, const CPP_cartesian_map_term&);


//--------------------------------------------------------------------
// CPP_cartesian_map

class Opaque_cartesian_map_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_cartesian_map {
public:
  Real field_scale;
  Real_ARRAY r0;
  Int master_parameter;
  Int ele_anchor_pt;
  Int field_type;
  CPP_cartesian_map_term* ptr;

  CPP_cartesian_map() :
    field_scale(1),
    r0(0.0, 3),
    master_parameter(0),
    ele_anchor_pt(Bmad::ANCHOR_BEGINNING),
    field_type(Bmad::MAGNETIC),
    ptr(NULL)
    {}

  ~CPP_cartesian_map() {
    delete ptr;
  }

};   // End Class

extern "C" void cartesian_map_to_c (const Opaque_cartesian_map_class*, CPP_cartesian_map&);
extern "C" void cartesian_map_to_f (const CPP_cartesian_map&, Opaque_cartesian_map_class*);

bool operator== (const CPP_cartesian_map&, const CPP_cartesian_map&);


//--------------------------------------------------------------------
// CPP_cylindrical_map_term1

class Opaque_cylindrical_map_term1_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_cylindrical_map_term1 {
public:
  Complex e_coef;
  Complex b_coef;

  CPP_cylindrical_map_term1() :
    e_coef(0.0),
    b_coef(0.0)
    {}

  ~CPP_cylindrical_map_term1() {
  }

};   // End Class

extern "C" void cylindrical_map_term1_to_c (const Opaque_cylindrical_map_term1_class*, CPP_cylindrical_map_term1&);
extern "C" void cylindrical_map_term1_to_f (const CPP_cylindrical_map_term1&, Opaque_cylindrical_map_term1_class*);

bool operator== (const CPP_cylindrical_map_term1&, const CPP_cylindrical_map_term1&);


//--------------------------------------------------------------------
// CPP_cylindrical_map_term

class Opaque_cylindrical_map_term_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_cylindrical_map_term {
public:
  string file;
  Int n_link;
  CPP_cylindrical_map_term1_ARRAY term;

  CPP_cylindrical_map_term() :
    file(),
    n_link(1),
    term(CPP_cylindrical_map_term1_ARRAY(CPP_cylindrical_map_term1(), 0))
    {}

  ~CPP_cylindrical_map_term() {
  }

};   // End Class

extern "C" void cylindrical_map_term_to_c (const Opaque_cylindrical_map_term_class*, CPP_cylindrical_map_term&);
extern "C" void cylindrical_map_term_to_f (const CPP_cylindrical_map_term&, Opaque_cylindrical_map_term_class*);

bool operator== (const CPP_cylindrical_map_term&, const CPP_cylindrical_map_term&);


//--------------------------------------------------------------------
// CPP_cylindrical_map

class Opaque_cylindrical_map_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_cylindrical_map {
public:
  Int m;
  Int harmonic;
  Real phi0_fieldmap;
  Real theta0_azimuth;
  Real field_scale;
  Int master_parameter;
  Int ele_anchor_pt;
  Real dz;
  Real_ARRAY r0;
  CPP_cylindrical_map_term* ptr;

  CPP_cylindrical_map() :
    m(0),
    harmonic(0),
    phi0_fieldmap(0.0),
    theta0_azimuth(0.0),
    field_scale(1),
    master_parameter(0),
    ele_anchor_pt(Bmad::ANCHOR_BEGINNING),
    dz(0.0),
    r0(0.0, 3),
    ptr(NULL)
    {}

  ~CPP_cylindrical_map() {
    delete ptr;
  }

};   // End Class

extern "C" void cylindrical_map_to_c (const Opaque_cylindrical_map_class*, CPP_cylindrical_map&);
extern "C" void cylindrical_map_to_f (const CPP_cylindrical_map&, Opaque_cylindrical_map_class*);

bool operator== (const CPP_cylindrical_map&, const CPP_cylindrical_map&);


//--------------------------------------------------------------------
// CPP_grid_field_pt1

class Opaque_grid_field_pt1_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_grid_field_pt1 {
public:
  Complex_ARRAY e;
  Complex_ARRAY b;

  CPP_grid_field_pt1() :
    e(0.0, 3),
    b(0.0, 3)
    {}

  ~CPP_grid_field_pt1() {
  }

};   // End Class

extern "C" void grid_field_pt1_to_c (const Opaque_grid_field_pt1_class*, CPP_grid_field_pt1&);
extern "C" void grid_field_pt1_to_f (const CPP_grid_field_pt1&, Opaque_grid_field_pt1_class*);

bool operator== (const CPP_grid_field_pt1&, const CPP_grid_field_pt1&);


//--------------------------------------------------------------------
// CPP_grid_field_pt

class Opaque_grid_field_pt_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_grid_field_pt {
public:
  string file;
  Int n_link;
  CPP_grid_field_pt1_TENSOR pt;

  CPP_grid_field_pt() :
    file(),
    n_link(1),
    pt(CPP_grid_field_pt1_MATRIX(CPP_grid_field_pt1_ARRAY(CPP_grid_field_pt1(), 0), 0), 0)
    {}

  ~CPP_grid_field_pt() {
  }

};   // End Class

extern "C" void grid_field_pt_to_c (const Opaque_grid_field_pt_class*, CPP_grid_field_pt&);
extern "C" void grid_field_pt_to_f (const CPP_grid_field_pt&, Opaque_grid_field_pt_class*);

bool operator== (const CPP_grid_field_pt&, const CPP_grid_field_pt&);


//--------------------------------------------------------------------
// CPP_grid_field

class Opaque_grid_field_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_grid_field {
public:
  Int geometry;
  Int harmonic;
  Real phi0_fieldmap;
  Real field_scale;
  Int field_type;
  Int master_parameter;
  Int ele_anchor_pt;
  Int interpolation_order;
  Real_ARRAY dr;
  Real_ARRAY r0;
  Bool curved_ref_frame;
  CPP_grid_field_pt* ptr;

  CPP_grid_field() :
    geometry(0),
    harmonic(0),
    phi0_fieldmap(0.0),
    field_scale(1),
    field_type(Bmad::MIXED),
    master_parameter(0),
    ele_anchor_pt(Bmad::ANCHOR_BEGINNING),
    interpolation_order(1),
    dr(0.0, 3),
    r0(0.0, 3),
    curved_ref_frame(false),
    ptr(NULL)
    {}

  ~CPP_grid_field() {
    delete ptr;
  }

};   // End Class

extern "C" void grid_field_to_c (const Opaque_grid_field_class*, CPP_grid_field&);
extern "C" void grid_field_to_f (const CPP_grid_field&, Opaque_grid_field_class*);

bool operator== (const CPP_grid_field&, const CPP_grid_field&);


//--------------------------------------------------------------------
// CPP_floor_position

class Opaque_floor_position_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_floor_position {
public:
  Real_ARRAY r;
  Real_MATRIX w;
  Real theta;
  Real phi;
  Real psi;

  CPP_floor_position() :
    r(0.0, 3),
    w(Real_ARRAY(0.0, 3), 3),
    theta(0.0),
    phi(0.0),
    psi(0.0)
    {}

  ~CPP_floor_position() {
  }

};   // End Class

extern "C" void floor_position_to_c (const Opaque_floor_position_class*, CPP_floor_position&);
extern "C" void floor_position_to_f (const CPP_floor_position&, Opaque_floor_position_class*);

bool operator== (const CPP_floor_position&, const CPP_floor_position&);


//--------------------------------------------------------------------
// CPP_high_energy_space_charge

class Opaque_high_energy_space_charge_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_high_energy_space_charge {
public:
  CPP_coord closed_orb;
  Real kick_const;
  Real sig_x;
  Real sig_y;
  Real phi;
  Real sin_phi;
  Real cos_phi;
  Real sig_z;

  CPP_high_energy_space_charge() :
    closed_orb(),
    kick_const(0.0),
    sig_x(0.0),
    sig_y(0.0),
    phi(0.0),
    sin_phi(0.0),
    cos_phi(0.0),
    sig_z(0.0)
    {}

  ~CPP_high_energy_space_charge() {
  }

};   // End Class

extern "C" void high_energy_space_charge_to_c (const Opaque_high_energy_space_charge_class*, CPP_high_energy_space_charge&);
extern "C" void high_energy_space_charge_to_f (const CPP_high_energy_space_charge&, Opaque_high_energy_space_charge_class*);

bool operator== (const CPP_high_energy_space_charge&, const CPP_high_energy_space_charge&);


//--------------------------------------------------------------------
// CPP_xy_disp

class Opaque_xy_disp_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_xy_disp {
public:
  Real eta;
  Real etap;
  Real deta_ds;
  Real sigma;

  CPP_xy_disp() :
    eta(0.0),
    etap(0.0),
    deta_ds(0.0),
    sigma(0.0)
    {}

  ~CPP_xy_disp() {
  }

};   // End Class

extern "C" void xy_disp_to_c (const Opaque_xy_disp_class*, CPP_xy_disp&);
extern "C" void xy_disp_to_f (const CPP_xy_disp&, Opaque_xy_disp_class*);

bool operator== (const CPP_xy_disp&, const CPP_xy_disp&);


//--------------------------------------------------------------------
// CPP_twiss

class Opaque_twiss_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_twiss {
public:
  Real beta;
  Real alpha;
  Real gamma;
  Real phi;
  Real eta;
  Real etap;
  Real deta_ds;
  Real sigma;
  Real sigma_p;
  Real emit;
  Real norm_emit;

  CPP_twiss() :
    beta(0.0),
    alpha(0.0),
    gamma(0.0),
    phi(0.0),
    eta(0.0),
    etap(0.0),
    deta_ds(0.0),
    sigma(0.0),
    sigma_p(0.0),
    emit(0.0),
    norm_emit(0.0)
    {}

  ~CPP_twiss() {
  }

};   // End Class

extern "C" void twiss_to_c (const Opaque_twiss_class*, CPP_twiss&);
extern "C" void twiss_to_f (const CPP_twiss&, Opaque_twiss_class*);

bool operator== (const CPP_twiss&, const CPP_twiss&);


//--------------------------------------------------------------------
// CPP_mode3

class Opaque_mode3_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_mode3 {
public:
  Real_MATRIX v;
  CPP_twiss a;
  CPP_twiss b;
  CPP_twiss c;
  CPP_twiss x;
  CPP_twiss y;

  CPP_mode3() :
    v(Real_ARRAY(0.0, 6), 6),
    a(),
    b(),
    c(),
    x(),
    y()
    {}

  ~CPP_mode3() {
  }

};   // End Class

extern "C" void mode3_to_c (const Opaque_mode3_class*, CPP_mode3&);
extern "C" void mode3_to_f (const CPP_mode3&, Opaque_mode3_class*);

bool operator== (const CPP_mode3&, const CPP_mode3&);


//--------------------------------------------------------------------
// CPP_bookkeeping_state

class Opaque_bookkeeping_state_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_bookkeeping_state {
public:
  Int attributes;
  Int control;
  Int floor_position;
  Int s_position;
  Int ref_energy;
  Int mat6;
  Int rad_int;
  Int ptc;

  CPP_bookkeeping_state() :
    attributes(Bmad::STALE),
    control(Bmad::STALE),
    floor_position(Bmad::STALE),
    s_position(Bmad::STALE),
    ref_energy(Bmad::STALE),
    mat6(Bmad::STALE),
    rad_int(Bmad::STALE),
    ptc(Bmad::STALE)
    {}

  ~CPP_bookkeeping_state() {
  }

};   // End Class

extern "C" void bookkeeping_state_to_c (const Opaque_bookkeeping_state_class*, CPP_bookkeeping_state&);
extern "C" void bookkeeping_state_to_f (const CPP_bookkeeping_state&, Opaque_bookkeeping_state_class*);

bool operator== (const CPP_bookkeeping_state&, const CPP_bookkeeping_state&);


//--------------------------------------------------------------------
// CPP_rad_map

class Opaque_rad_map_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_rad_map {
public:
  Real_ARRAY ref_orb;
  Real_MATRIX damp_dmat;
  Real_ARRAY xfer_damp_vec;
  Real_MATRIX xfer_damp_mat;
  Real_MATRIX stoc_mat;

  CPP_rad_map() :
    ref_orb(-1, 6),
    damp_dmat(Real_ARRAY(0.0, 6), 6),
    xfer_damp_vec(0.0, 6),
    xfer_damp_mat(Real_ARRAY(0.0, 6), 6),
    stoc_mat(Real_ARRAY(0.0, 6), 6)
    {}

  ~CPP_rad_map() {
  }

};   // End Class

extern "C" void rad_map_to_c (const Opaque_rad_map_class*, CPP_rad_map&);
extern "C" void rad_map_to_f (const CPP_rad_map&, Opaque_rad_map_class*);

bool operator== (const CPP_rad_map&, const CPP_rad_map&);


//--------------------------------------------------------------------
// CPP_rad_map_ele

class Opaque_rad_map_ele_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_rad_map_ele {
public:
  CPP_rad_map rm0;
  CPP_rad_map rm1;
  Bool stale;

  CPP_rad_map_ele() :
    rm0(),
    rm1(),
    stale(true)
    {}

  ~CPP_rad_map_ele() {
  }

};   // End Class

extern "C" void rad_map_ele_to_c (const Opaque_rad_map_ele_class*, CPP_rad_map_ele&);
extern "C" void rad_map_ele_to_f (const CPP_rad_map_ele&, Opaque_rad_map_ele_class*);

bool operator== (const CPP_rad_map_ele&, const CPP_rad_map_ele&);


//--------------------------------------------------------------------
// CPP_gen_grad1

class Opaque_gen_grad1_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_gen_grad1 {
public:
  Int m;
  Int sincos;
  Int n_deriv_max;
  Real_MATRIX deriv;

  CPP_gen_grad1() :
    m(0),
    sincos(0),
    n_deriv_max(-1),
    deriv(Real_ARRAY(0.0, 0), 0)
    {}

  ~CPP_gen_grad1() {
  }

};   // End Class

extern "C" void gen_grad1_to_c (const Opaque_gen_grad1_class*, CPP_gen_grad1&);
extern "C" void gen_grad1_to_f (const CPP_gen_grad1&, Opaque_gen_grad1_class*);

bool operator== (const CPP_gen_grad1&, const CPP_gen_grad1&);


//--------------------------------------------------------------------
// CPP_gen_grad_map

class Opaque_gen_grad_map_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_gen_grad_map {
public:
  string file;
  CPP_gen_grad1_ARRAY gg;
  Int ele_anchor_pt;
  Int field_type;
  Int iz0;
  Int iz1;
  Real dz;
  Real_ARRAY r0;
  Real field_scale;
  Int master_parameter;
  Bool curved_ref_frame;

  CPP_gen_grad_map() :
    file(),
    gg(CPP_gen_grad1_ARRAY(CPP_gen_grad1(), 0)),
    ele_anchor_pt(Bmad::ANCHOR_BEGINNING),
    field_type(Bmad::MAGNETIC),
    iz0(Bmad::INT_GARBAGE),
    iz1(Bmad::INT_GARBAGE),
    dz(0.0),
    r0(0.0, 3),
    field_scale(1),
    master_parameter(0),
    curved_ref_frame(false)
    {}

  ~CPP_gen_grad_map() {
  }

};   // End Class

extern "C" void gen_grad_map_to_c (const Opaque_gen_grad_map_class*, CPP_gen_grad_map&);
extern "C" void gen_grad_map_to_f (const CPP_gen_grad_map&, Opaque_gen_grad_map_class*);

bool operator== (const CPP_gen_grad_map&, const CPP_gen_grad_map&);


//--------------------------------------------------------------------
// CPP_surface_grid_pt

class Opaque_surface_grid_pt_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_surface_grid_pt {
public:
  CPP_surface_orientation orientation;
  Real z0;
  Real x0;
  Real y0;
  Real dz_dx;
  Real dz_dy;
  Real d2z_dxdy;

  CPP_surface_grid_pt() :
    orientation(),
    z0(0.0),
    x0(0.0),
    y0(0.0),
    dz_dx(0.0),
    dz_dy(0.0),
    d2z_dxdy(0.0)
    {}

  ~CPP_surface_grid_pt() {
  }

};   // End Class

extern "C" void surface_grid_pt_to_c (const Opaque_surface_grid_pt_class*, CPP_surface_grid_pt&);
extern "C" void surface_grid_pt_to_f (const CPP_surface_grid_pt&, Opaque_surface_grid_pt_class*);

bool operator== (const CPP_surface_grid_pt&, const CPP_surface_grid_pt&);


//--------------------------------------------------------------------
// CPP_surface_grid

class Opaque_surface_grid_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_surface_grid {
public:
  Bool active;
  Int type;
  Real_ARRAY dr;
  Real_ARRAY r0;
  CPP_surface_grid_pt_MATRIX pt;

  CPP_surface_grid() :
    active(true),
    type(Bmad::NOT_SET),
    dr(0.0, 2),
    r0(0.0, 2),
    pt(CPP_surface_grid_pt_ARRAY(CPP_surface_grid_pt(), 0), 0)
    {}

  ~CPP_surface_grid() {
  }

};   // End Class

extern "C" void surface_grid_to_c (const Opaque_surface_grid_class*, CPP_surface_grid&);
extern "C" void surface_grid_to_f (const CPP_surface_grid&, Opaque_surface_grid_class*);

bool operator== (const CPP_surface_grid&, const CPP_surface_grid&);


//--------------------------------------------------------------------
// CPP_target_point

class Opaque_target_point_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_target_point {
public:
  Real_ARRAY r;

  CPP_target_point() :
    r(0.0, 3)
    {}

  ~CPP_target_point() {
  }

};   // End Class

extern "C" void target_point_to_c (const Opaque_target_point_class*, CPP_target_point&);
extern "C" void target_point_to_f (const CPP_target_point&, Opaque_target_point_class*);

bool operator== (const CPP_target_point&, const CPP_target_point&);


//--------------------------------------------------------------------
// CPP_surface_curvature

class Opaque_surface_curvature_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_surface_curvature {
public:
  Real_MATRIX xy;
  Real spherical;
  Real_ARRAY elliptical;
  Bool has_curvature;

  CPP_surface_curvature() :
    xy(Real_ARRAY(0.0, 7), 7),
    spherical(0.0),
    elliptical(0.0, 3),
    has_curvature(false)
    {}

  ~CPP_surface_curvature() {
  }

};   // End Class

extern "C" void surface_curvature_to_c (const Opaque_surface_curvature_class*, CPP_surface_curvature&);
extern "C" void surface_curvature_to_f (const CPP_surface_curvature&, Opaque_surface_curvature_class*);

bool operator== (const CPP_surface_curvature&, const CPP_surface_curvature&);


//--------------------------------------------------------------------
// CPP_photon_target

class Opaque_photon_target_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_target {
public:
  Int type;
  Int n_corner;
  CPP_lat_ele_loc ele_loc;
  CPP_target_point_ARRAY corner;
  CPP_target_point center;

  CPP_photon_target() :
    type(Bmad::OFF),
    n_corner(0),
    ele_loc(),
    corner(CPP_target_point_ARRAY(CPP_target_point(), 8)),
    center()
    {}

  ~CPP_photon_target() {
  }

};   // End Class

extern "C" void photon_target_to_c (const Opaque_photon_target_class*, CPP_photon_target&);
extern "C" void photon_target_to_f (const CPP_photon_target&, Opaque_photon_target_class*);

bool operator== (const CPP_photon_target&, const CPP_photon_target&);


//--------------------------------------------------------------------
// CPP_photon_material

class Opaque_photon_material_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_material {
public:
  Complex f0_m1;
  Complex f0_m2;
  Complex f_0;
  Complex f_h;
  Complex f_hbar;
  Complex f_hkl;
  Real_ARRAY h_norm;
  Real_ARRAY l_ref;

  CPP_photon_material() :
    f0_m1(0.0),
    f0_m2(0.0),
    f_0(0.0),
    f_h(0.0),
    f_hbar(0.0),
    f_hkl(0.0),
    h_norm(0.0, 3),
    l_ref(0.0, 3)
    {}

  ~CPP_photon_material() {
  }

};   // End Class

extern "C" void photon_material_to_c (const Opaque_photon_material_class*, CPP_photon_material&);
extern "C" void photon_material_to_f (const CPP_photon_material&, Opaque_photon_material_class*);

bool operator== (const CPP_photon_material&, const CPP_photon_material&);


//--------------------------------------------------------------------
// CPP_pixel_pt

class Opaque_pixel_pt_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_pixel_pt {
public:
  Int8 n_photon;
  Complex e_x;
  Complex e_y;
  Real intensity_x;
  Real intensity_y;
  Real intensity;
  Real_ARRAY orbit;
  Real_ARRAY orbit_rms;
  Real_ARRAY init_orbit;
  Real_ARRAY init_orbit_rms;

  CPP_pixel_pt() :
    n_photon(0),
    e_x(0.0),
    e_y(0.0),
    intensity_x(0.0),
    intensity_y(0.0),
    intensity(0.0),
    orbit(0.0, 6),
    orbit_rms(0.0, 6),
    init_orbit(0.0, 6),
    init_orbit_rms(0.0, 6)
    {}

  ~CPP_pixel_pt() {
  }

};   // End Class

extern "C" void pixel_pt_to_c (const Opaque_pixel_pt_class*, CPP_pixel_pt&);
extern "C" void pixel_pt_to_f (const CPP_pixel_pt&, Opaque_pixel_pt_class*);

bool operator== (const CPP_pixel_pt&, const CPP_pixel_pt&);


//--------------------------------------------------------------------
// CPP_pixel_detec

class Opaque_pixel_detec_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_pixel_detec {
public:
  Real_ARRAY dr;
  Real_ARRAY r0;
  Int8 n_track_tot;
  Int8 n_hit_detec;
  Int8 n_hit_pixel;
  CPP_pixel_pt_MATRIX pt;

  CPP_pixel_detec() :
    dr(0.0, 2),
    r0(0.0, 2),
    n_track_tot(0),
    n_hit_detec(0),
    n_hit_pixel(0),
    pt(CPP_pixel_pt_ARRAY(CPP_pixel_pt(), 0), 0)
    {}

  ~CPP_pixel_detec() {
  }

};   // End Class

extern "C" void pixel_detec_to_c (const Opaque_pixel_detec_class*, CPP_pixel_detec&);
extern "C" void pixel_detec_to_f (const CPP_pixel_detec&, Opaque_pixel_detec_class*);

bool operator== (const CPP_pixel_detec&, const CPP_pixel_detec&);


//--------------------------------------------------------------------
// CPP_photon_element

class Opaque_photon_element_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_photon_element {
public:
  CPP_surface_curvature curvature;
  CPP_photon_target target;
  CPP_photon_material material;
  CPP_surface_grid grid;
  CPP_pixel_detec pixel;
  Int reflectivity_table_type;
  CPP_photon_reflect_table reflectivity_table_sigma;
  CPP_photon_reflect_table reflectivity_table_pi;
  CPP_spline_ARRAY init_energy_prob;
  Real_ARRAY integrated_init_energy_prob;

  CPP_photon_element() :
    curvature(),
    target(),
    material(),
    grid(),
    pixel(),
    reflectivity_table_type(Bmad::NOT_SET),
    reflectivity_table_sigma(),
    reflectivity_table_pi(),
    init_energy_prob(CPP_spline_ARRAY(CPP_spline(), 0)),
    integrated_init_energy_prob(0.0, 0)
    {}

  ~CPP_photon_element() {
  }

};   // End Class

extern "C" void photon_element_to_c (const Opaque_photon_element_class*, CPP_photon_element&);
extern "C" void photon_element_to_f (const CPP_photon_element&, Opaque_photon_element_class*);

bool operator== (const CPP_photon_element&, const CPP_photon_element&);


//--------------------------------------------------------------------
// CPP_wall3d_vertex

class Opaque_wall3d_vertex_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wall3d_vertex {
public:
  Real x;
  Real y;
  Real radius_x;
  Real radius_y;
  Real tilt;
  Real angle;
  Real x0;
  Real y0;
  Int type;

  CPP_wall3d_vertex() :
    x(0.0),
    y(0.0),
    radius_x(0.0),
    radius_y(0.0),
    tilt(0.0),
    angle(0.0),
    x0(0.0),
    y0(0.0),
    type(Bmad::NORMAL)
    {}

  ~CPP_wall3d_vertex() {
  }

};   // End Class

extern "C" void wall3d_vertex_to_c (const Opaque_wall3d_vertex_class*, CPP_wall3d_vertex&);
extern "C" void wall3d_vertex_to_f (const CPP_wall3d_vertex&, Opaque_wall3d_vertex_class*);

bool operator== (const CPP_wall3d_vertex&, const CPP_wall3d_vertex&);


//--------------------------------------------------------------------
// CPP_wall3d_section

class Opaque_wall3d_section_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wall3d_section {
public:
  string name;
  string material;
  CPP_wall3d_vertex_ARRAY v;
  CPP_photon_reflect_surface* surface;
  Int type;
  Int n_vertex_input;
  Int ix_ele;
  Int ix_branch;
  Int vertices_state;
  Bool patch_in_region;
  Real thickness;
  Real s;
  Real_ARRAY r0;
  Real dx0_ds;
  Real dy0_ds;
  Real_ARRAY x0_coef;
  Real_ARRAY y0_coef;
  Real dr_ds;
  Real_ARRAY p1_coef;
  Real_ARRAY p2_coef;

  CPP_wall3d_section() :
    name(),
    material(),
    v(CPP_wall3d_vertex_ARRAY(CPP_wall3d_vertex(), 0)),
    surface(NULL),
    type(Bmad::NORMAL),
    n_vertex_input(0),
    ix_ele(0),
    ix_branch(0),
    vertices_state(Bmad::RELATIVE),
    patch_in_region(false),
    thickness(-1),
    s(0.0),
    r0(0.0, 2),
    dx0_ds(0.0),
    dy0_ds(0.0),
    x0_coef(0.0, 4),
    y0_coef(0.0, 4),
    dr_ds(Bmad::REAL_GARBAGE),
    p1_coef(0.0, 3),
    p2_coef(0.0, 3)
    {}

  ~CPP_wall3d_section() {
    delete surface;
  }

};   // End Class

extern "C" void wall3d_section_to_c (const Opaque_wall3d_section_class*, CPP_wall3d_section&);
extern "C" void wall3d_section_to_f (const CPP_wall3d_section&, Opaque_wall3d_section_class*);

bool operator== (const CPP_wall3d_section&, const CPP_wall3d_section&);


//--------------------------------------------------------------------
// CPP_wall3d

class Opaque_wall3d_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_wall3d {
public:
  string name;
  Int type;
  Int ix_wall3d;
  Int n_link;
  Real thickness;
  string clear_material;
  string opaque_material;
  Bool superimpose;
  Int ele_anchor_pt;
  CPP_wall3d_section_ARRAY section;

  CPP_wall3d() :
    name(),
    type(Bmad::CHAMBER_WALL),
    ix_wall3d(0),
    n_link(1),
    thickness(-1),
    clear_material(),
    opaque_material(),
    superimpose(false),
    ele_anchor_pt(Bmad::ANCHOR_BEGINNING),
    section(CPP_wall3d_section_ARRAY(CPP_wall3d_section(), 0))
    {}

  ~CPP_wall3d() {
  }

};   // End Class

extern "C" void wall3d_to_c (const Opaque_wall3d_class*, CPP_wall3d&);
extern "C" void wall3d_to_f (const CPP_wall3d&, Opaque_wall3d_class*);

bool operator== (const CPP_wall3d&, const CPP_wall3d&);


//--------------------------------------------------------------------
// CPP_control

class Opaque_control_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_control {
public:
  Real value;
  Real_ARRAY y_knot;
  CPP_expression_atom_ARRAY stack;
  CPP_lat_ele_loc slave;
  CPP_lat_ele_loc lord;
  string slave_name;
  string attribute;
  Int ix_attrib;

  CPP_control() :
    value(0.0),
    y_knot(0.0, 0),
    stack(CPP_expression_atom_ARRAY(CPP_expression_atom(), 0)),
    slave(),
    lord(),
    slave_name(),
    attribute(),
    ix_attrib(-1)
    {}

  ~CPP_control() {
  }

};   // End Class

extern "C" void control_to_c (const Opaque_control_class*, CPP_control&);
extern "C" void control_to_f (const CPP_control&, Opaque_control_class*);

bool operator== (const CPP_control&, const CPP_control&);


//--------------------------------------------------------------------
// CPP_control_var1

class Opaque_control_var1_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_control_var1 {
public:
  string name;
  Real value;
  Real old_value;

  CPP_control_var1() :
    name(),
    value(0.0),
    old_value(0.0)
    {}

  ~CPP_control_var1() {
  }

};   // End Class

extern "C" void control_var1_to_c (const Opaque_control_var1_class*, CPP_control_var1&);
extern "C" void control_var1_to_f (const CPP_control_var1&, Opaque_control_var1_class*);

bool operator== (const CPP_control_var1&, const CPP_control_var1&);


//--------------------------------------------------------------------
// CPP_control_ramp1

class Opaque_control_ramp1_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_control_ramp1 {
public:
  Real value;
  Real_ARRAY y_knot;
  CPP_expression_atom_ARRAY stack;
  string attribute;
  string slave_name;
  CPP_lat_ele_loc slave;
  Bool is_controller;

  CPP_control_ramp1() :
    value(0.0),
    y_knot(0.0, 0),
    stack(CPP_expression_atom_ARRAY(CPP_expression_atom(), 0)),
    attribute(),
    slave_name(),
    slave(),
    is_controller(false)
    {}

  ~CPP_control_ramp1() {
  }

};   // End Class

extern "C" void control_ramp1_to_c (const Opaque_control_ramp1_class*, CPP_control_ramp1&);
extern "C" void control_ramp1_to_f (const CPP_control_ramp1&, Opaque_control_ramp1_class*);

bool operator== (const CPP_control_ramp1&, const CPP_control_ramp1&);


//--------------------------------------------------------------------
// CPP_controller

class Opaque_controller_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_controller {
public:
  CPP_control_var1_ARRAY var;
  CPP_control_ramp1_ARRAY ramp;
  Real_ARRAY x_knot;

  CPP_controller() :
    var(CPP_control_var1_ARRAY(CPP_control_var1(), 0)),
    ramp(CPP_control_ramp1_ARRAY(CPP_control_ramp1(), 0)),
    x_knot(0.0, 0)
    {}

  ~CPP_controller() {
  }

};   // End Class

extern "C" void controller_to_c (const Opaque_controller_class*, CPP_controller&);
extern "C" void controller_to_f (const CPP_controller&, Opaque_controller_class*);

bool operator== (const CPP_controller&, const CPP_controller&);


//--------------------------------------------------------------------
// CPP_ellipse_beam_init

class Opaque_ellipse_beam_init_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_ellipse_beam_init {
public:
  Int part_per_ellipse;
  Int n_ellipse;
  Real sigma_cutoff;

  CPP_ellipse_beam_init() :
    part_per_ellipse(0),
    n_ellipse(1),
    sigma_cutoff(0.0)
    {}

  ~CPP_ellipse_beam_init() {
  }

};   // End Class

extern "C" void ellipse_beam_init_to_c (const Opaque_ellipse_beam_init_class*, CPP_ellipse_beam_init&);
extern "C" void ellipse_beam_init_to_f (const CPP_ellipse_beam_init&, Opaque_ellipse_beam_init_class*);

bool operator== (const CPP_ellipse_beam_init&, const CPP_ellipse_beam_init&);


//--------------------------------------------------------------------
// CPP_kv_beam_init

class Opaque_kv_beam_init_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_kv_beam_init {
public:
  Int_ARRAY part_per_phi;
  Int n_i2;
  Real a;

  CPP_kv_beam_init() :
    part_per_phi(0, 2),
    n_i2(0),
    a(0.0)
    {}

  ~CPP_kv_beam_init() {
  }

};   // End Class

extern "C" void kv_beam_init_to_c (const Opaque_kv_beam_init_class*, CPP_kv_beam_init&);
extern "C" void kv_beam_init_to_f (const CPP_kv_beam_init&, Opaque_kv_beam_init_class*);

bool operator== (const CPP_kv_beam_init&, const CPP_kv_beam_init&);


//--------------------------------------------------------------------
// CPP_grid_beam_init

class Opaque_grid_beam_init_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_grid_beam_init {
public:
  Int n_x;
  Int n_px;
  Real x_min;
  Real x_max;
  Real px_min;
  Real px_max;

  CPP_grid_beam_init() :
    n_x(0),
    n_px(0),
    x_min(0.0),
    x_max(0.0),
    px_min(0.0),
    px_max(0.0)
    {}

  ~CPP_grid_beam_init() {
  }

};   // End Class

extern "C" void grid_beam_init_to_c (const Opaque_grid_beam_init_class*, CPP_grid_beam_init&);
extern "C" void grid_beam_init_to_f (const CPP_grid_beam_init&, Opaque_grid_beam_init_class*);

bool operator== (const CPP_grid_beam_init&, const CPP_grid_beam_init&);


//--------------------------------------------------------------------
// CPP_beam_init

class Opaque_beam_init_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_beam_init {
public:
  string position_file;
  String_ARRAY distribution_type;
  Real_ARRAY spin;
  CPP_ellipse_beam_init_ARRAY ellipse;
  CPP_kv_beam_init kv;
  CPP_grid_beam_init_ARRAY grid;
  Real_ARRAY center_jitter;
  Real_ARRAY emit_jitter;
  Real sig_z_jitter;
  Real sig_pz_jitter;
  Int n_particle;
  Bool renorm_center;
  Bool renorm_sigma;
  string random_engine;
  string random_gauss_converter;
  Real random_sigma_cutoff;
  Real a_norm_emit;
  Real b_norm_emit;
  Real a_emit;
  Real b_emit;
  Real dpz_dz;
  Real_ARRAY center;
  Real t_offset;
  Real dt_bunch;
  Real sig_z;
  Real sig_pz;
  Real bunch_charge;
  Int n_bunch;
  Int ix_turn;
  string species;
  Bool full_6d_coupling_calc;
  Bool use_particle_start;
  Bool use_t_coords;
  Bool use_z_as_t;

  CPP_beam_init() :
    position_file(),
    distribution_type(String_ARRAY(string(), 3)),
    spin(0.0, 3),
    ellipse(CPP_ellipse_beam_init_ARRAY(CPP_ellipse_beam_init(), 3)),
    kv(),
    grid(CPP_grid_beam_init_ARRAY(CPP_grid_beam_init(), 3)),
    center_jitter(0.0, 6),
    emit_jitter(0.0, 2),
    sig_z_jitter(0.0),
    sig_pz_jitter(0.0),
    n_particle(0),
    renorm_center(true),
    renorm_sigma(true),
    random_engine(),
    random_gauss_converter(),
    random_sigma_cutoff(-1),
    a_norm_emit(0.0),
    b_norm_emit(0.0),
    a_emit(0.0),
    b_emit(0.0),
    dpz_dz(0.0),
    center(0.0, 6),
    t_offset(0.0),
    dt_bunch(0.0),
    sig_z(0.0),
    sig_pz(0.0),
    bunch_charge(0.0),
    n_bunch(0),
    ix_turn(0),
    species(),
    full_6d_coupling_calc(false),
    use_particle_start(false),
    use_t_coords(false),
    use_z_as_t(false)
    {}

  ~CPP_beam_init() {
  }

};   // End Class

extern "C" void beam_init_to_c (const Opaque_beam_init_class*, CPP_beam_init&);
extern "C" void beam_init_to_f (const CPP_beam_init&, Opaque_beam_init_class*);

bool operator== (const CPP_beam_init&, const CPP_beam_init&);


//--------------------------------------------------------------------
// CPP_lat_param

class Opaque_lat_param_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_lat_param {
public:
  Real n_part;
  Real total_length;
  Real unstable_factor;
  Real_MATRIX t1_with_rf;
  Real_MATRIX t1_no_rf;
  Real spin_tune;
  Int particle;
  Int default_tracking_species;
  Int geometry;
  Int ixx;
  Bool stable;
  Bool live_branch;
  Real g1_integral;
  Real g2_integral;
  Real g3_integral;
  CPP_bookkeeping_state bookkeeping_state;
  CPP_beam_init beam_init;

  CPP_lat_param() :
    n_part(0.0),
    total_length(0.0),
    unstable_factor(0.0),
    t1_with_rf(Real_ARRAY(0.0, 6), 6),
    t1_no_rf(Real_ARRAY(0.0, 6), 6),
    spin_tune(0.0),
    particle(Bmad::NOT_SET),
    default_tracking_species(Bmad::REF_PARTICLE),
    geometry(0),
    ixx(0),
    stable(false),
    live_branch(true),
    g1_integral(-1),
    g2_integral(-1),
    g3_integral(-1),
    bookkeeping_state(),
    beam_init()
    {}

  ~CPP_lat_param() {
  }

};   // End Class

extern "C" void lat_param_to_c (const Opaque_lat_param_class*, CPP_lat_param&);
extern "C" void lat_param_to_f (const CPP_lat_param&, Opaque_lat_param_class*);

bool operator== (const CPP_lat_param&, const CPP_lat_param&);


//--------------------------------------------------------------------
// CPP_mode_info

class Opaque_mode_info_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_mode_info {
public:
  Bool stable;
  Real tune;
  Real emit;
  Real chrom;
  Real sigma;
  Real sigmap;

  CPP_mode_info() :
    stable(false),
    tune(0.0),
    emit(0.0),
    chrom(0.0),
    sigma(0.0),
    sigmap(0.0)
    {}

  ~CPP_mode_info() {
  }

};   // End Class

extern "C" void mode_info_to_c (const Opaque_mode_info_class*, CPP_mode_info&);
extern "C" void mode_info_to_f (const CPP_mode_info&, Opaque_mode_info_class*);

bool operator== (const CPP_mode_info&, const CPP_mode_info&);


//--------------------------------------------------------------------
// CPP_pre_tracker

class Opaque_pre_tracker_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_pre_tracker {
public:
  Int who;
  Int ix_ele_start;
  Int ix_ele_end;
  string input_file;

  CPP_pre_tracker() :
    who(0),
    ix_ele_start(0),
    ix_ele_end(0),
    input_file()
    {}

  ~CPP_pre_tracker() {
  }

};   // End Class

extern "C" void pre_tracker_to_c (const Opaque_pre_tracker_class*, CPP_pre_tracker&);
extern "C" void pre_tracker_to_f (const CPP_pre_tracker&, Opaque_pre_tracker_class*);

bool operator== (const CPP_pre_tracker&, const CPP_pre_tracker&);


//--------------------------------------------------------------------
// CPP_anormal_mode

class Opaque_anormal_mode_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_anormal_mode {
public:
  Real emittance;
  Real emittance_no_vert;
  Real_ARRAY synch_int;
  Real j_damp;
  Real alpha_damp;
  Real chrom;
  Real tune;

  CPP_anormal_mode() :
    emittance(0.0),
    emittance_no_vert(0.0),
    synch_int(0.0, 3),
    j_damp(0.0),
    alpha_damp(0.0),
    chrom(0.0),
    tune(0.0)
    {}

  ~CPP_anormal_mode() {
  }

};   // End Class

extern "C" void anormal_mode_to_c (const Opaque_anormal_mode_class*, CPP_anormal_mode&);
extern "C" void anormal_mode_to_f (const CPP_anormal_mode&, Opaque_anormal_mode_class*);

bool operator== (const CPP_anormal_mode&, const CPP_anormal_mode&);


//--------------------------------------------------------------------
// CPP_linac_normal_mode

class Opaque_linac_normal_mode_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_linac_normal_mode {
public:
  Real i2_e4;
  Real i3_e7;
  Real i5a_e6;
  Real i5b_e6;
  Real sig_e1;
  Real a_emittance_end;
  Real b_emittance_end;

  CPP_linac_normal_mode() :
    i2_e4(0.0),
    i3_e7(0.0),
    i5a_e6(0.0),
    i5b_e6(0.0),
    sig_e1(0.0),
    a_emittance_end(0.0),
    b_emittance_end(0.0)
    {}

  ~CPP_linac_normal_mode() {
  }

};   // End Class

extern "C" void linac_normal_mode_to_c (const Opaque_linac_normal_mode_class*, CPP_linac_normal_mode&);
extern "C" void linac_normal_mode_to_f (const CPP_linac_normal_mode&, Opaque_linac_normal_mode_class*);

bool operator== (const CPP_linac_normal_mode&, const CPP_linac_normal_mode&);


//--------------------------------------------------------------------
// CPP_normal_modes

class Opaque_normal_modes_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_normal_modes {
public:
  Real_ARRAY synch_int;
  Real sige_e;
  Real sig_z;
  Real e_loss;
  Real rf_voltage;
  Real pz_aperture;
  Real pz_average;
  Real momentum_compaction;
  Real dpz_damp;
  CPP_anormal_mode a;
  CPP_anormal_mode b;
  CPP_anormal_mode z;
  CPP_linac_normal_mode lin;

  CPP_normal_modes() :
    synch_int(0.0, 4),
    sige_e(0.0),
    sig_z(0.0),
    e_loss(0.0),
    rf_voltage(0.0),
    pz_aperture(0.0),
    pz_average(0.0),
    momentum_compaction(0.0),
    dpz_damp(0.0),
    a(),
    b(),
    z(),
    lin()
    {}

  ~CPP_normal_modes() {
  }

};   // End Class

extern "C" void normal_modes_to_c (const Opaque_normal_modes_class*, CPP_normal_modes&);
extern "C" void normal_modes_to_f (const CPP_normal_modes&, Opaque_normal_modes_class*);

bool operator== (const CPP_normal_modes&, const CPP_normal_modes&);


//--------------------------------------------------------------------
// CPP_em_field

class Opaque_em_field_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_em_field {
public:
  Real_ARRAY e;
  Real_ARRAY b;
  Real_MATRIX de;
  Real_MATRIX db;
  Real phi;
  Real phi_b;
  Real_ARRAY a;

  CPP_em_field() :
    e(0.0, 3),
    b(0.0, 3),
    de(Real_ARRAY(0.0, 3), 3),
    db(Real_ARRAY(0.0, 3), 3),
    phi(0.0),
    phi_b(0.0),
    a(0.0, 3)
    {}

  ~CPP_em_field() {
  }

};   // End Class

extern "C" void em_field_to_c (const Opaque_em_field_class*, CPP_em_field&);
extern "C" void em_field_to_f (const CPP_em_field&, Opaque_em_field_class*);

bool operator== (const CPP_em_field&, const CPP_em_field&);


//--------------------------------------------------------------------
// CPP_strong_beam

class Opaque_strong_beam_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_strong_beam {
public:
  Int ix_slice;
  Real x_center;
  Real y_center;
  Real x_sigma;
  Real y_sigma;
  Real dx;
  Real dy;

  CPP_strong_beam() :
    ix_slice(0),
    x_center(0.0),
    y_center(0.0),
    x_sigma(0.0),
    y_sigma(0.0),
    dx(0.0),
    dy(0.0)
    {}

  ~CPP_strong_beam() {
  }

};   // End Class

extern "C" void strong_beam_to_c (const Opaque_strong_beam_class*, CPP_strong_beam&);
extern "C" void strong_beam_to_f (const CPP_strong_beam&, Opaque_strong_beam_class*);

bool operator== (const CPP_strong_beam&, const CPP_strong_beam&);


//--------------------------------------------------------------------
// CPP_track_point

class Opaque_track_point_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_track_point {
public:
  Real s_body;
  CPP_coord orb;
  CPP_em_field field;
  CPP_strong_beam strong_beam;
  Real_ARRAY vec0;
  Real_MATRIX mat6;

  CPP_track_point() :
    s_body(0.0),
    orb(),
    field(),
    strong_beam(),
    vec0(0.0, 6),
    mat6(Real_ARRAY(0.0, 6), 6)
    {}

  ~CPP_track_point() {
  }

};   // End Class

extern "C" void track_point_to_c (const Opaque_track_point_class*, CPP_track_point&);
extern "C" void track_point_to_f (const CPP_track_point&, Opaque_track_point_class*);

bool operator== (const CPP_track_point&, const CPP_track_point&);


//--------------------------------------------------------------------
// CPP_track

class Opaque_track_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_track {
public:
  CPP_track_point_ARRAY pt;
  Real ds_save;
  Int n_pt;
  Int n_bad;
  Int n_ok;

  CPP_track() :
    pt(CPP_track_point_ARRAY(CPP_track_point(), 0)),
    ds_save(1e-3),
    n_pt(-1),
    n_bad(0),
    n_ok(0)
    {}

  ~CPP_track() {
  }

};   // End Class

extern "C" void track_to_c (const Opaque_track_class*, CPP_track&);
extern "C" void track_to_f (const CPP_track&, Opaque_track_class*);

bool operator== (const CPP_track&, const CPP_track&);


//--------------------------------------------------------------------
// CPP_space_charge_common

class Opaque_space_charge_common_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_space_charge_common {
public:
  Real ds_track_step;
  Real dt_track_step;
  Real cathode_strength_cutoff;
  Real rel_tol_tracking;
  Real abs_tol_tracking;
  Real beam_chamber_height;
  Real lsc_sigma_cutoff;
  Real particle_sigma_cutoff;
  Int_ARRAY space_charge_mesh_size;
  Int_ARRAY csr3d_mesh_size;
  Int n_bin;
  Int particle_bin_span;
  Int n_shield_images;
  Int sc_min_in_bin;
  Bool lsc_kick_transverse_dependence;
  Bool debug;
  string diagnostic_output_file;

  CPP_space_charge_common() :
    ds_track_step(0.0),
    dt_track_step(1e-12),
    cathode_strength_cutoff(0.01),
    rel_tol_tracking(1e-8),
    abs_tol_tracking(1e-10),
    beam_chamber_height(0.0),
    lsc_sigma_cutoff(0.1),
    particle_sigma_cutoff(-1),
    space_charge_mesh_size(32, 3),
    csr3d_mesh_size(32, 3),
    n_bin(0),
    particle_bin_span(2),
    n_shield_images(0),
    sc_min_in_bin(10),
    lsc_kick_transverse_dependence(false),
    debug(false),
    diagnostic_output_file()
    {}

  ~CPP_space_charge_common() {
  }

};   // End Class

extern "C" void space_charge_common_to_c (const Opaque_space_charge_common_class*, CPP_space_charge_common&);
extern "C" void space_charge_common_to_f (const CPP_space_charge_common&, Opaque_space_charge_common_class*);

bool operator== (const CPP_space_charge_common&, const CPP_space_charge_common&);


//--------------------------------------------------------------------
// CPP_bmad_common

class Opaque_bmad_common_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_bmad_common {
public:
  Real max_aperture_limit;
  Real_ARRAY d_orb;
  Real default_ds_step;
  Real significant_length;
  Real rel_tol_tracking;
  Real abs_tol_tracking;
  Real rel_tol_adaptive_tracking;
  Real abs_tol_adaptive_tracking;
  Real init_ds_adaptive_tracking;
  Real min_ds_adaptive_tracking;
  Real fatal_ds_adaptive_tracking;
  Real autoscale_amp_abs_tol;
  Real autoscale_amp_rel_tol;
  Real autoscale_phase_tol;
  Real electric_dipole_moment;
  Real synch_rad_scale;
  Real sad_eps_scale;
  Real sad_amp_max;
  Int sad_n_div_max;
  Int taylor_order;
  Int runge_kutta_order;
  Int default_integ_order;
  Int max_num_runge_kutta_step;
  Bool rf_phase_below_transition_ref;
  Bool sr_wakes_on;
  Bool lr_wakes_on;
  Bool auto_bookkeeper;
  Bool high_energy_space_charge_on;
  Bool csr_and_space_charge_on;
  Bool spin_tracking_on;
  Bool spin_sokolov_ternov_flipping_on;
  Bool radiation_damping_on;
  Bool radiation_zero_average;
  Bool radiation_fluctuations_on;
  Bool conserve_taylor_maps;
  Bool absolute_time_tracking;
  Bool absolute_time_ref_shift;
  Bool convert_to_kinetic_momentum;
  Bool aperture_limit_on;
  Bool debug;

  CPP_bmad_common() :
    max_aperture_limit(1e3),
    d_orb(1e-5, 6),
    default_ds_step(0.0),
    significant_length(1e-10),
    rel_tol_tracking(1e-8),
    abs_tol_tracking(1e-11),
    rel_tol_adaptive_tracking(1e-8),
    abs_tol_adaptive_tracking(1e-10),
    init_ds_adaptive_tracking(1e-3),
    min_ds_adaptive_tracking(0.0),
    fatal_ds_adaptive_tracking(1e-8),
    autoscale_amp_abs_tol(0.0),
    autoscale_amp_rel_tol(1e-6),
    autoscale_phase_tol(1e-5),
    electric_dipole_moment(0.0),
    synch_rad_scale(0.0),
    sad_eps_scale(5.0e-3),
    sad_amp_max(5.0e-2),
    sad_n_div_max(1000),
    taylor_order(0),
    runge_kutta_order(4),
    default_integ_order(2),
    max_num_runge_kutta_step(10000),
    rf_phase_below_transition_ref(false),
    sr_wakes_on(true),
    lr_wakes_on(true),
    auto_bookkeeper(true),
    high_energy_space_charge_on(false),
    csr_and_space_charge_on(false),
    spin_tracking_on(false),
    spin_sokolov_ternov_flipping_on(false),
    radiation_damping_on(false),
    radiation_zero_average(false),
    radiation_fluctuations_on(false),
    conserve_taylor_maps(true),
    absolute_time_tracking(false),
    absolute_time_ref_shift(true),
    convert_to_kinetic_momentum(false),
    aperture_limit_on(true),
    debug(false)
    {}

  ~CPP_bmad_common() {
  }

};   // End Class

extern "C" void bmad_common_to_c (const Opaque_bmad_common_class*, CPP_bmad_common&);
extern "C" void bmad_common_to_f (const CPP_bmad_common&, Opaque_bmad_common_class*);

bool operator== (const CPP_bmad_common&, const CPP_bmad_common&);


//--------------------------------------------------------------------
// CPP_rad_int1

class Opaque_rad_int1_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_rad_int1 {
public:
  Real i0;
  Real i1;
  Real i2;
  Real i3;
  Real i4a;
  Real i4b;
  Real i4z;
  Real i5a;
  Real i5b;
  Real i6b;
  Real lin_i2_e4;
  Real lin_i3_e7;
  Real lin_i5a_e6;
  Real lin_i5b_e6;
  Real lin_norm_emit_a;
  Real lin_norm_emit_b;
  Real lin_sig_e;
  Real n_steps;

  CPP_rad_int1() :
    i0(0.0),
    i1(0.0),
    i2(0.0),
    i3(0.0),
    i4a(0.0),
    i4b(0.0),
    i4z(0.0),
    i5a(0.0),
    i5b(0.0),
    i6b(0.0),
    lin_i2_e4(0.0),
    lin_i3_e7(0.0),
    lin_i5a_e6(0.0),
    lin_i5b_e6(0.0),
    lin_norm_emit_a(0.0),
    lin_norm_emit_b(0.0),
    lin_sig_e(0.0),
    n_steps(0.0)
    {}

  ~CPP_rad_int1() {
  }

};   // End Class

extern "C" void rad_int1_to_c (const Opaque_rad_int1_class*, CPP_rad_int1&);
extern "C" void rad_int1_to_f (const CPP_rad_int1&, Opaque_rad_int1_class*);

bool operator== (const CPP_rad_int1&, const CPP_rad_int1&);


//--------------------------------------------------------------------
// CPP_rad_int_branch

class Opaque_rad_int_branch_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_rad_int_branch {
public:
  CPP_rad_int1_ARRAY ele;

  CPP_rad_int_branch() :
    ele(CPP_rad_int1_ARRAY(CPP_rad_int1(), 0))
    {}

  ~CPP_rad_int_branch() {
  }

};   // End Class

extern "C" void rad_int_branch_to_c (const Opaque_rad_int_branch_class*, CPP_rad_int_branch&);
extern "C" void rad_int_branch_to_f (const CPP_rad_int_branch&, Opaque_rad_int_branch_class*);

bool operator== (const CPP_rad_int_branch&, const CPP_rad_int_branch&);


//--------------------------------------------------------------------
// CPP_rad_int_all_ele

class Opaque_rad_int_all_ele_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_rad_int_all_ele {
public:
  CPP_rad_int_branch_ARRAY branch;

  CPP_rad_int_all_ele() :
    branch(CPP_rad_int_branch_ARRAY(CPP_rad_int_branch(), 0))
    {}

  ~CPP_rad_int_all_ele() {
  }

};   // End Class

extern "C" void rad_int_all_ele_to_c (const Opaque_rad_int_all_ele_class*, CPP_rad_int_all_ele&);
extern "C" void rad_int_all_ele_to_f (const CPP_rad_int_all_ele&, Opaque_rad_int_all_ele_class*);

bool operator== (const CPP_rad_int_all_ele&, const CPP_rad_int_all_ele&);


//--------------------------------------------------------------------
// CPP_ele

class Opaque_ele_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_ele {
public:
  string name;
  string type;
  string alias;
  string component_name;
  string* descrip;
  CPP_twiss a;
  CPP_twiss b;
  CPP_twiss z;
  CPP_xy_disp x;
  CPP_xy_disp y;
  CPP_ac_kicker* ac_kick;
  CPP_bookkeeping_state bookkeeping_state;
  CPP_controller* control;
  CPP_floor_position floor;
  CPP_high_energy_space_charge* high_energy_space_charge;
  CPP_mode3* mode3;
  CPP_photon_element* photon;
  CPP_rad_map_ele* rad_map;
  CPP_taylor_ARRAY taylor;
  Real_ARRAY spin_taylor_ref_orb_in;
  CPP_taylor_ARRAY spin_taylor;
  CPP_wake* wake;
  CPP_wall3d_ARRAY wall3d;
  CPP_cartesian_map_ARRAY cartesian_map;
  CPP_cylindrical_map_ARRAY cylindrical_map;
  CPP_gen_grad_map_ARRAY gen_grad_map;
  CPP_grid_field_ARRAY grid_field;
  CPP_coord map_ref_orb_in;
  CPP_coord map_ref_orb_out;
  CPP_coord time_ref_orb_in;
  CPP_coord time_ref_orb_out;
  Real_ARRAY value;
  Real_ARRAY old_value;
  Real_MATRIX spin_q;
  Real_ARRAY vec0;
  Real_MATRIX mat6;
  Real_MATRIX c_mat;
  Real gamma_c;
  Real s_start;
  Real s;
  Real ref_time;
  Real_ARRAY a_pole;
  Real_ARRAY b_pole;
  Real_ARRAY a_pole_elec;
  Real_ARRAY b_pole_elec;
  Real_ARRAY custom;
  Real_TENSOR r;
  Int key;
  Int sub_key;
  Int ix_ele;
  Int ix_branch;
  Int lord_status;
  Int n_slave;
  Int n_slave_field;
  Int ix1_slave;
  Int slave_status;
  Int n_lord;
  Int n_lord_field;
  Int ic1_lord;
  Int ix_pointer;
  Int ixx;
  Int iyy;
  Int izz;
  Int mat6_calc_method;
  Int tracking_method;
  Int spin_tracking_method;
  Int csr_method;
  Int space_charge_method;
  Int ptc_integration_type;
  Int field_calc;
  Int aperture_at;
  Int aperture_type;
  Int ref_species;
  Int orientation;
  Bool symplectify;
  Bool mode_flip;
  Bool multipoles_on;
  Bool scale_multipoles;
  Bool taylor_map_includes_offsets;
  Bool field_master;
  Bool is_on;
  Bool logic;
  Bool bmad_logic;
  Bool select;
  Bool offset_moves_aperture;

  void class_init (const int key_) {
    key = key_;

    if (key == Bmad::LCAVITY) {
      value[Bmad::COUPLER_AT] = Bmad::DOWNSTREAM_END;
      value[Bmad::FIELD_AUTOSCALE] = 1;
      value[Bmad::N_CELL] = 1;
    }

    if (key == Bmad::RFCAVITY) {
      value[Bmad::COUPLER_AT] = Bmad::DOWNSTREAM_END;
      value[Bmad::FIELD_AUTOSCALE] = 1;
      value[Bmad::N_CELL] = 1;
    }

    if (key == Bmad::RBEND || key == Bmad::SBEND) {
      value[Bmad::FRINGE_AT] = Bmad::BOTH_ENDS;
      value[Bmad::FRINGE_TYPE] = Bmad::BASIC_BEND;
      value[Bmad::PTC_FIELD_GEOMETRY] = Bmad::SECTOR;
    }
  }

  CPP_ele(const int key_ = 0) :
    name(),
    type(),
    alias(),
    component_name(),
    descrip(NULL),
    a(),
    b(),
    z(),
    x(),
    y(),
    ac_kick(NULL),
    bookkeeping_state(),
    control(NULL),
    floor(),
    high_energy_space_charge(NULL),
    mode3(NULL),
    photon(NULL),
    rad_map(NULL),
    taylor(CPP_taylor_ARRAY(CPP_taylor(), 6)),
    spin_taylor_ref_orb_in(Bmad::REAL_GARBAGE, 6),
    spin_taylor(CPP_taylor_ARRAY(CPP_taylor(), 4)),
    wake(NULL),
    wall3d(CPP_wall3d_ARRAY(CPP_wall3d(), 0)),
    cartesian_map(CPP_cartesian_map_ARRAY(CPP_cartesian_map(), 0)),
    cylindrical_map(CPP_cylindrical_map_ARRAY(CPP_cylindrical_map(), 0)),
    gen_grad_map(CPP_gen_grad_map_ARRAY(CPP_gen_grad_map(), 0)),
    grid_field(CPP_grid_field_ARRAY(CPP_grid_field(), 0)),
    map_ref_orb_in(),
    map_ref_orb_out(),
    time_ref_orb_in(),
    time_ref_orb_out(),
    value(double(0), Bmad::NUM_ELE_ATTRIB+1),
    old_value(double(0), Bmad::NUM_ELE_ATTRIB+1),
    spin_q(Real_ARRAY(Bmad::REAL_GARBAGE, 7), 4),
    vec0(0.0, 6),
    mat6(Real_ARRAY(0.0, 6), 6),
    c_mat(Real_ARRAY(0.0, 2), 2),
    gamma_c(1),
    s_start(0.0),
    s(0.0),
    ref_time(0.0),
    a_pole(0.0, 0),
    b_pole(0.0, 0),
    a_pole_elec(0.0, 0),
    b_pole_elec(0.0, 0),
    custom(0.0, 0),
    r(Real_MATRIX(Real_ARRAY(0.0, 0), 0), 0),
    key(key_),
    sub_key(0),
    ix_ele(-1),
    ix_branch(0),
    lord_status(Bmad::NOT_A_LORD),
    n_slave(0),
    n_slave_field(0),
    ix1_slave(0),
    slave_status(Bmad::FREE),
    n_lord(0),
    n_lord_field(0),
    ic1_lord(0),
    ix_pointer(0),
    ixx(0),
    iyy(0),
    izz(0),
    mat6_calc_method(Bmad::BMAD_STANDARD),
    tracking_method(Bmad::BMAD_STANDARD),
    spin_tracking_method(Bmad::BMAD_STANDARD),
    csr_method(Bmad::OFF),
    space_charge_method(Bmad::OFF),
    ptc_integration_type(Bmad::MATRIX_KICK),
    field_calc(Bmad::BMAD_STANDARD),
    aperture_at(Bmad::DOWNSTREAM_END),
    aperture_type(Bmad::RECTANGULAR),
    ref_species(Bmad::NOT_SET),
    orientation(1),
    symplectify(false),
    mode_flip(false),
    multipoles_on(true),
    scale_multipoles(true),
    taylor_map_includes_offsets(true),
    field_master(false),
    is_on(true),
    logic(false),
    bmad_logic(false),
    select(false),
    offset_moves_aperture(false)
        {
      class_init(key);
    }


  ~CPP_ele() {
    delete descrip;
    delete ac_kick;
    delete control;
    delete high_energy_space_charge;
    delete mode3;
    delete photon;
    delete rad_map;
    delete wake;
  }

};   // End Class

extern "C" void ele_to_c (const Opaque_ele_class*, CPP_ele&);
extern "C" void ele_to_f (const CPP_ele&, Opaque_ele_class*);

bool operator== (const CPP_ele&, const CPP_ele&);


//--------------------------------------------------------------------
// CPP_complex_taylor_term

class Opaque_complex_taylor_term_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_complex_taylor_term {
public:
  Complex coef;
  Int_ARRAY expn;

  CPP_complex_taylor_term() :
    coef(0.0),
    expn(0, 6)
    {}

  ~CPP_complex_taylor_term() {
  }

};   // End Class

extern "C" void complex_taylor_term_to_c (const Opaque_complex_taylor_term_class*, CPP_complex_taylor_term&);
extern "C" void complex_taylor_term_to_f (const CPP_complex_taylor_term&, Opaque_complex_taylor_term_class*);

bool operator== (const CPP_complex_taylor_term&, const CPP_complex_taylor_term&);


//--------------------------------------------------------------------
// CPP_complex_taylor

class Opaque_complex_taylor_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_complex_taylor {
public:
  Complex ref;
  CPP_complex_taylor_term_ARRAY term;

  CPP_complex_taylor() :
    ref(0.0),
    term(CPP_complex_taylor_term_ARRAY(CPP_complex_taylor_term(), 0))
    {}

  ~CPP_complex_taylor() {
  }

};   // End Class

extern "C" void complex_taylor_to_c (const Opaque_complex_taylor_class*, CPP_complex_taylor&);
extern "C" void complex_taylor_to_f (const CPP_complex_taylor&, Opaque_complex_taylor_class*);

bool operator== (const CPP_complex_taylor&, const CPP_complex_taylor&);


//--------------------------------------------------------------------
// CPP_branch

class Opaque_branch_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_branch {
public:
  string name;
  Int ix_branch;
  Int ix_from_branch;
  Int ix_from_ele;
  Int ix_to_ele;
  Int n_ele_track;
  Int n_ele_max;
  CPP_mode_info a;
  CPP_mode_info b;
  CPP_mode_info z;
  CPP_ele_ARRAY ele;
  CPP_lat_param param;
  CPP_wall3d_ARRAY wall3d;

  CPP_branch() :
    name(),
    ix_branch(-1),
    ix_from_branch(-1),
    ix_from_ele(-1),
    ix_to_ele(-1),
    n_ele_track(0),
    n_ele_max(0),
    a(),
    b(),
    z(),
    ele(CPP_ele_ARRAY(CPP_ele(), 0)),
    param(),
    wall3d(CPP_wall3d_ARRAY(CPP_wall3d(), 0))
    {}

  ~CPP_branch() {
  }

};   // End Class

extern "C" void branch_to_c (const Opaque_branch_class*, CPP_branch&);
extern "C" void branch_to_f (const CPP_branch&, Opaque_branch_class*);

bool operator== (const CPP_branch&, const CPP_branch&);


//--------------------------------------------------------------------
// CPP_lat

class Opaque_lat_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_lat {
public:
  string use_name;
  string lattice;
  string machine;
  string input_file_name;
  string title;
  String_ARRAY print_str;
  CPP_expression_atom_ARRAY constant;
  CPP_mode_info* a;
  CPP_mode_info* b;
  CPP_mode_info* z;
  CPP_lat_param* param;
  CPP_bookkeeping_state lord_state;
  CPP_ele ele_init;
  CPP_ele_ARRAY ele;
  CPP_branch_ARRAY branch;
  CPP_control_ARRAY control;
  CPP_coord particle_start;
  CPP_beam_init beam_init;
  CPP_pre_tracker pre_tracker;
  Real_ARRAY custom;
  Int version;
  Int* n_ele_track;
  Int* n_ele_max;
  Int n_control_max;
  Int n_ic_max;
  Int input_taylor_order;
  Int_ARRAY ic;
  Int photon_type;
  Int creation_hash;

  CPP_lat() :
    use_name(),
    lattice(),
    machine(),
    input_file_name(),
    title(),
    print_str(String_ARRAY(string(), 0)),
    constant(CPP_expression_atom_ARRAY(CPP_expression_atom(), 0)),
    a(NULL),
    b(NULL),
    z(NULL),
    param(NULL),
    lord_state(),
    ele_init(),
    ele(CPP_ele_ARRAY(CPP_ele(), 0)),
    branch(CPP_branch_ARRAY(CPP_branch(), 0)),
    control(CPP_control_ARRAY(CPP_control(), 0)),
    particle_start(),
    beam_init(),
    pre_tracker(),
    custom(0.0, 0),
    version(-1),
    n_ele_track(NULL),
    n_ele_max(NULL),
    n_control_max(0),
    n_ic_max(0),
    input_taylor_order(0),
    ic(0, 0),
    photon_type(Bmad::INCOHERENT),
    creation_hash(0)
    {}

  ~CPP_lat() {
    delete a;
    delete b;
    delete z;
    delete param;
    delete n_ele_track;
    delete n_ele_max;
  }

};   // End Class

extern "C" void lat_to_c (const Opaque_lat_class*, CPP_lat&);
extern "C" void lat_to_f (const CPP_lat&, Opaque_lat_class*);

bool operator== (const CPP_lat&, const CPP_lat&);


//--------------------------------------------------------------------
// CPP_bunch

class Opaque_bunch_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_bunch {
public:
  CPP_coord_ARRAY particle;
  Int_ARRAY ix_z;
  Real charge_tot;
  Real charge_live;
  Real z_center;
  Real t_center;
  Real t0;
  Bool drift_between_t_and_s;
  Int ix_ele;
  Int ix_bunch;
  Int ix_turn;
  Int n_live;
  Int n_good;
  Int n_bad;

  CPP_bunch() :
    particle(CPP_coord_ARRAY(CPP_coord(), 0)),
    ix_z(0, 0),
    charge_tot(0.0),
    charge_live(0.0),
    z_center(0.0),
    t_center(0.0),
    t0(Bmad::REAL_GARBAGE),
    drift_between_t_and_s(false),
    ix_ele(0),
    ix_bunch(0),
    ix_turn(0),
    n_live(0),
    n_good(0),
    n_bad(0)
    {}

  ~CPP_bunch() {
  }

};   // End Class

extern "C" void bunch_to_c (const Opaque_bunch_class*, CPP_bunch&);
extern "C" void bunch_to_f (const CPP_bunch&, Opaque_bunch_class*);

bool operator== (const CPP_bunch&, const CPP_bunch&);


//--------------------------------------------------------------------
// CPP_bunch_params

class Opaque_bunch_params_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_bunch_params {
public:
  CPP_coord centroid;
  CPP_twiss x;
  CPP_twiss y;
  CPP_twiss z;
  CPP_twiss a;
  CPP_twiss b;
  CPP_twiss c;
  Real_MATRIX sigma;
  Real_ARRAY rel_max;
  Real_ARRAY rel_min;
  Real s;
  Real t;
  Real sigma_t;
  Real charge_live;
  Real charge_tot;
  Int n_particle_tot;
  Int n_particle_live;
  Int n_particle_lost_in_ele;
  Int n_good_steps;
  Int n_bad_steps;
  Int ix_ele;
  Int location;
  Bool twiss_valid;

  CPP_bunch_params() :
    centroid(),
    x(),
    y(),
    z(),
    a(),
    b(),
    c(),
    sigma(Real_ARRAY(0.0, 6), 6),
    rel_max(0.0, 7),
    rel_min(0.0, 7),
    s(-1),
    t(-1),
    sigma_t(0.0),
    charge_live(0.0),
    charge_tot(0.0),
    n_particle_tot(0),
    n_particle_live(0),
    n_particle_lost_in_ele(0),
    n_good_steps(0),
    n_bad_steps(0),
    ix_ele(-1),
    location(Bmad::NOT_SET),
    twiss_valid(false)
    {}

  ~CPP_bunch_params() {
  }

};   // End Class

extern "C" void bunch_params_to_c (const Opaque_bunch_params_class*, CPP_bunch_params&);
extern "C" void bunch_params_to_f (const CPP_bunch_params&, Opaque_bunch_params_class*);

bool operator== (const CPP_bunch_params&, const CPP_bunch_params&);


//--------------------------------------------------------------------
// CPP_beam

class Opaque_beam_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_beam {
public:
  CPP_bunch_ARRAY bunch;

  CPP_beam() :
    bunch(CPP_bunch_ARRAY(CPP_bunch(), 0))
    {}

  ~CPP_beam() {
  }

};   // End Class

extern "C" void beam_to_c (const Opaque_beam_class*, CPP_beam&);
extern "C" void beam_to_f (const CPP_beam&, Opaque_beam_class*);

bool operator== (const CPP_beam&, const CPP_beam&);


//--------------------------------------------------------------------
// CPP_aperture_point

class Opaque_aperture_point_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_aperture_point {
public:
  Real x;
  Real y;
  Int plane;
  Int ix_ele;
  Int i_turn;

  CPP_aperture_point() :
    x(0.0),
    y(0.0),
    plane(0),
    ix_ele(0),
    i_turn(0)
    {}

  ~CPP_aperture_point() {
  }

};   // End Class

extern "C" void aperture_point_to_c (const Opaque_aperture_point_class*, CPP_aperture_point&);
extern "C" void aperture_point_to_f (const CPP_aperture_point&, Opaque_aperture_point_class*);

bool operator== (const CPP_aperture_point&, const CPP_aperture_point&);


//--------------------------------------------------------------------
// CPP_aperture_param

class Opaque_aperture_param_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_aperture_param {
public:
  Real min_angle;
  Real max_angle;
  Int n_angle;
  Int n_turn;
  Real x_init;
  Real y_init;
  Real rel_accuracy;
  Real abs_accuracy;
  string start_ele;

  CPP_aperture_param() :
    min_angle(0.0),
    max_angle(Bmad::PI),
    n_angle(9),
    n_turn(100),
    x_init(0.0),
    y_init(0.0),
    rel_accuracy(0.0),
    abs_accuracy(0.0),
    start_ele()
    {}

  ~CPP_aperture_param() {
  }

};   // End Class

extern "C" void aperture_param_to_c (const Opaque_aperture_param_class*, CPP_aperture_param&);
extern "C" void aperture_param_to_f (const CPP_aperture_param&, Opaque_aperture_param_class*);

bool operator== (const CPP_aperture_param&, const CPP_aperture_param&);


//--------------------------------------------------------------------
// CPP_aperture_scan

class Opaque_aperture_scan_class {};  // Opaque class for pointers to corresponding fortran structs.

class CPP_aperture_scan {
public:
  CPP_aperture_point_ARRAY point;
  CPP_coord ref_orb;
  Real pz_start;

  CPP_aperture_scan() :
    point(CPP_aperture_point_ARRAY(CPP_aperture_point(), 0)),
    ref_orb(),
    pz_start(0.0)
    {}

  ~CPP_aperture_scan() {
  }

};   // End Class

extern "C" void aperture_scan_to_c (const Opaque_aperture_scan_class*, CPP_aperture_scan&);
extern "C" void aperture_scan_to_f (const CPP_aperture_scan&, Opaque_aperture_scan_class*);

bool operator== (const CPP_aperture_scan&, const CPP_aperture_scan&);


//--------------------------------------------------------------------

#define CPP_BMAD_CLASSES
#endif
