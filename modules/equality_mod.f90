!+
! Module equality_mod
!
! This module defines a set of functions which overload the equality operator ("==").
! These functions test for equality between instances of a given structure. 
!
! This file is generated as a by product of the Bmad/C++ interface code generation
! The code generation files can be found in cpp_bmad_interface.
!
! DO NOT EDIT THIS FILE DIRECTLY! 
!- 

module equality_mod
use beam_def_struct

interface operator (==)
  module procedure eq_surface_orientation, eq_interval1_coef, eq_photon_reflect_table, eq_photon_reflect_surface, eq_controller_var
  module procedure eq_coord, eq_coord_array, eq_bpm_phase_coupling, eq_expression_atom, eq_wig_term
  module procedure eq_wig, eq_wake_sr_mode, eq_wake_sr, eq_wake_lr, eq_lat_ele_loc
  module procedure eq_wake, eq_em_field_map_term, eq_em_field_map, eq_em_field_grid_pt, eq_em_field_grid
  module procedure eq_em_field_mode, eq_em_fields, eq_floor_position, eq_space_charge, eq_xy_disp
  module procedure eq_twiss, eq_mode3, eq_bookkeeping_state, eq_rad_int_ele_cache, eq_surface_grid_pt
  module procedure eq_surface_grid, eq_segmented_surface, eq_target_point, eq_photon_surface, eq_photon_target
  module procedure eq_photon_material, eq_photon_element, eq_wall3d_vertex, eq_wall3d_section, eq_wall3d
  module procedure eq_taylor_term, eq_taylor, eq_control, eq_lat_param, eq_mode_info
  module procedure eq_pre_tracker, eq_anormal_mode, eq_linac_normal_mode, eq_normal_modes, eq_em_field
  module procedure eq_track_map, eq_track, eq_synch_rad_common, eq_csr_parameter, eq_bmad_common
  module procedure eq_rad_int1, eq_rad_int_all_ele, eq_ptc_genfield, eq_ele, eq_complex_taylor_term
  module procedure eq_complex_taylor, eq_normal_form, eq_branch, eq_lat, eq_bunch
  module procedure eq_beam_spin, eq_bunch_params, eq_beam
end interface

contains

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_surface_orientation (f1, f2) result (is_eq)

implicit none

type(surface_orientation_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%x_pitch == f2%x_pitch)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%y_pitch == f2%y_pitch)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%x_pitch_rms == f2%x_pitch_rms)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%y_pitch_rms == f2%y_pitch_rms)

end function eq_surface_orientation

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_interval1_coef (f1, f2) result (is_eq)

implicit none

type(interval1_coef_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%c0 == f2%c0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%c1 == f2%c1)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%n_exp == f2%n_exp)

end function eq_interval1_coef

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_photon_reflect_table (f1, f2) result (is_eq)

implicit none

type(photon_reflect_table_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%angle) .eqv. allocated(f2%angle))
if (.not. is_eq) return
if (allocated(f1%angle)) is_eq = all(shape(f1%angle) == shape(f2%angle))
if (.not. is_eq) return
if (allocated(f1%angle)) is_eq = all(f1%angle == f2%angle)
!! f_side.equality_test[real, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%energy) .eqv. allocated(f2%energy))
if (.not. is_eq) return
if (allocated(f1%energy)) is_eq = all(shape(f1%energy) == shape(f2%energy))
if (.not. is_eq) return
if (allocated(f1%energy)) is_eq = all(f1%energy == f2%energy)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%int1) .eqv. allocated(f2%int1))
if (.not. is_eq) return
if (allocated(f1%int1)) is_eq = all(shape(f1%int1) == shape(f2%int1))
if (.not. is_eq) return
if (allocated(f1%int1)) is_eq = all(f1%int1 == f2%int1)
!! f_side.equality_test[real, 2, ALLOC]
is_eq = is_eq .and. (allocated(f1%p_reflect) .eqv. allocated(f2%p_reflect))
if (.not. is_eq) return
if (allocated(f1%p_reflect)) is_eq = all(shape(f1%p_reflect) == shape(f2%p_reflect))
if (.not. is_eq) return
if (allocated(f1%p_reflect)) is_eq = all(f1%p_reflect == f2%p_reflect)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%max_energy == f2%max_energy)
!! f_side.equality_test[real, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%p_reflect_scratch) .eqv. allocated(f2%p_reflect_scratch))
if (.not. is_eq) return
if (allocated(f1%p_reflect_scratch)) is_eq = all(shape(f1%p_reflect_scratch) == shape(f2%p_reflect_scratch))
if (.not. is_eq) return
if (allocated(f1%p_reflect_scratch)) is_eq = all(f1%p_reflect_scratch == f2%p_reflect_scratch)

end function eq_photon_reflect_table

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_photon_reflect_surface (f1, f2) result (is_eq)

implicit none

type(photon_reflect_surface_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%descrip == f2%descrip)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%reflectivity_file == f2%reflectivity_file)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%table) .eqv. allocated(f2%table))
if (.not. is_eq) return
if (allocated(f1%table)) is_eq = all(shape(f1%table) == shape(f2%table))
if (.not. is_eq) return
if (allocated(f1%table)) is_eq = all(f1%table == f2%table)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%surface_roughness_rms == f2%surface_roughness_rms)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%roughness_correlation_len == f2%roughness_correlation_len)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%initialized .eqv. f2%initialized)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_surface == f2%ix_surface)

end function eq_photon_reflect_surface

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_controller_var (f1, f2) result (is_eq)

implicit none

type(controller_var_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%name == f2%name)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%value == f2%value)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%old_value == f2%old_value)

end function eq_controller_var

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_coord (f1, f2) result (is_eq)

implicit none

type(coord_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%vec == f2%vec)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%s == f2%s)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%t == f2%t)
!! f_side.equality_test[complex, 1, NOT]
is_eq = is_eq .and. all(f1%spin == f2%spin)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%field == f2%field)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%phase == f2%phase)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%charge == f2%charge)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%path_len == f2%path_len)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%p0c == f2%p0c)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%beta == f2%beta)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_ele == f2%ix_ele)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%state == f2%state)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%direction == f2%direction)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%species == f2%species)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%location == f2%location)

end function eq_coord

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_coord_array (f1, f2) result (is_eq)

implicit none

type(coord_array_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%orbit) .eqv. allocated(f2%orbit))
if (.not. is_eq) return
if (allocated(f1%orbit)) is_eq = all(shape(f1%orbit) == shape(f2%orbit))
if (.not. is_eq) return
if (allocated(f1%orbit)) is_eq = all(f1%orbit == f2%orbit)

end function eq_coord_array

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_bpm_phase_coupling (f1, f2) result (is_eq)

implicit none

type(bpm_phase_coupling_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%k_22a == f2%k_22a)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%k_12a == f2%k_12a)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%k_11b == f2%k_11b)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%k_12b == f2%k_12b)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%cbar22_a == f2%cbar22_a)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%cbar12_a == f2%cbar12_a)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%cbar11_b == f2%cbar11_b)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%cbar12_b == f2%cbar12_b)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%phi_a == f2%phi_a)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%phi_b == f2%phi_b)

end function eq_bpm_phase_coupling

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_expression_atom (f1, f2) result (is_eq)

implicit none

type(expression_atom_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%name == f2%name)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%type == f2%type)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%value == f2%value)

end function eq_expression_atom

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_wig_term (f1, f2) result (is_eq)

implicit none

type(wig_term_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%coef == f2%coef)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%kx == f2%kx)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%ky == f2%ky)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%kz == f2%kz)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%x0 == f2%x0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%y0 == f2%y0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%phi_z == f2%phi_z)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%type == f2%type)

end function eq_wig_term

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_wig (f1, f2) result (is_eq)

implicit none

type(wig_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_link == f2%n_link)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%term) .eqv. allocated(f2%term))
if (.not. is_eq) return
if (allocated(f1%term)) is_eq = all(shape(f1%term) == shape(f2%term))
if (.not. is_eq) return
if (allocated(f1%term)) is_eq = all(f1%term == f2%term)

end function eq_wig

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_wake_sr_mode (f1, f2) result (is_eq)

implicit none

type(wake_sr_mode_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%amp == f2%amp)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%damp == f2%damp)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%k == f2%k)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%phi == f2%phi)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%b_sin == f2%b_sin)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%b_cos == f2%b_cos)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%a_sin == f2%a_sin)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%a_cos == f2%a_cos)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%polarization == f2%polarization)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%transverse_dependence == f2%transverse_dependence)

end function eq_wake_sr_mode

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_wake_sr (f1, f2) result (is_eq)

implicit none

type(wake_sr_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%mode) .eqv. allocated(f2%mode))
if (.not. is_eq) return
if (allocated(f1%mode)) is_eq = all(shape(f1%mode) == shape(f2%mode))
if (.not. is_eq) return
if (allocated(f1%mode)) is_eq = all(f1%mode == f2%mode)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%z_ref == f2%z_ref)

end function eq_wake_sr

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_wake_lr (f1, f2) result (is_eq)

implicit none

type(wake_lr_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%freq == f2%freq)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%freq_in == f2%freq_in)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%r_over_q == f2%r_over_q)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%q == f2%q)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%angle == f2%angle)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%b_sin == f2%b_sin)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%b_cos == f2%b_cos)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%a_sin == f2%a_sin)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%a_cos == f2%a_cos)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%t_ref == f2%t_ref)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%m == f2%m)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%polarized .eqv. f2%polarized)

end function eq_wake_lr

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_lat_ele_loc (f1, f2) result (is_eq)

implicit none

type(lat_ele_loc_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_ele == f2%ix_ele)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_branch == f2%ix_branch)

end function eq_lat_ele_loc

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_wake (f1, f2) result (is_eq)

implicit none

type(wake_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%sr_file == f2%sr_file)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%lr_file == f2%lr_file)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%sr_long == f2%sr_long)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%sr_trans == f2%sr_trans)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%lr) .eqv. allocated(f2%lr))
if (.not. is_eq) return
if (allocated(f1%lr)) is_eq = all(shape(f1%lr) == shape(f2%lr))
if (.not. is_eq) return
if (allocated(f1%lr)) is_eq = all(f1%lr == f2%lr)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%z_sr_max == f2%z_sr_max)

end function eq_wake

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_em_field_map_term (f1, f2) result (is_eq)

implicit none

type(em_field_map_term_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%e_coef == f2%e_coef)
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%b_coef == f2%b_coef)

end function eq_em_field_map_term

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_em_field_map (f1, f2) result (is_eq)

implicit none

type(em_field_map_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%file == f2%file)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_link == f2%n_link)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ele_anchor_pt == f2%ele_anchor_pt)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%dz == f2%dz)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%term) .eqv. allocated(f2%term))
if (.not. is_eq) return
if (allocated(f1%term)) is_eq = all(shape(f1%term) == shape(f2%term))
if (.not. is_eq) return
if (allocated(f1%term)) is_eq = all(f1%term == f2%term)

end function eq_em_field_map

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_em_field_grid_pt (f1, f2) result (is_eq)

implicit none

type(em_field_grid_pt_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[complex, 1, NOT]
is_eq = is_eq .and. all(f1%e == f2%e)
!! f_side.equality_test[complex, 1, NOT]
is_eq = is_eq .and. all(f1%b == f2%b)

end function eq_em_field_grid_pt

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_em_field_grid (f1, f2) result (is_eq)

implicit none

type(em_field_grid_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%file == f2%file)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%type == f2%type)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ele_anchor_pt == f2%ele_anchor_pt)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_link == f2%n_link)
!! f_side.equality_test[type, 3, ALLOC]
is_eq = is_eq .and. (allocated(f1%pt) .eqv. allocated(f2%pt))
if (.not. is_eq) return
if (allocated(f1%pt)) is_eq = all(shape(f1%pt) == shape(f2%pt))
if (.not. is_eq) return
if (allocated(f1%pt)) is_eq = all(f1%pt == f2%pt)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%dr == f2%dr)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%r0 == f2%r0)

end function eq_em_field_grid

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_em_field_mode (f1, f2) result (is_eq)

implicit none

type(em_field_mode_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%m == f2%m)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%harmonic == f2%harmonic)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%f_damp == f2%f_damp)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%phi0_ref == f2%phi0_ref)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%stored_energy == f2%stored_energy)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%phi0_azimuth == f2%phi0_azimuth)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%field_scale == f2%field_scale)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%master_scale == f2%master_scale)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%map) .eqv. associated(f2%map))
if (.not. is_eq) return
if (associated(f1%map)) is_eq = (f1%map == f2%map)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%grid) .eqv. associated(f2%grid))
if (.not. is_eq) return
if (associated(f1%grid)) is_eq = (f1%grid == f2%grid)

end function eq_em_field_mode

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_em_fields (f1, f2) result (is_eq)

implicit none

type(em_fields_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%mode) .eqv. allocated(f2%mode))
if (.not. is_eq) return
if (allocated(f1%mode)) is_eq = all(shape(f1%mode) == shape(f2%mode))
if (.not. is_eq) return
if (allocated(f1%mode)) is_eq = all(f1%mode == f2%mode)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%mode_to_autoscale == f2%mode_to_autoscale)

end function eq_em_fields

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_floor_position (f1, f2) result (is_eq)

implicit none

type(floor_position_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%r == f2%r)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%theta == f2%theta)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%phi == f2%phi)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%psi == f2%psi)

end function eq_floor_position

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_space_charge (f1, f2) result (is_eq)

implicit none

type(space_charge_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%closed_orb == f2%closed_orb)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%kick_const == f2%kick_const)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sig_x == f2%sig_x)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sig_y == f2%sig_y)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%phi == f2%phi)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sin_phi == f2%sin_phi)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%cos_phi == f2%cos_phi)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sig_z == f2%sig_z)

end function eq_space_charge

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_xy_disp (f1, f2) result (is_eq)

implicit none

type(xy_disp_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%eta == f2%eta)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%etap == f2%etap)

end function eq_xy_disp

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_twiss (f1, f2) result (is_eq)

implicit none

type(twiss_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%beta == f2%beta)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%alpha == f2%alpha)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%gamma == f2%gamma)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%phi == f2%phi)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%eta == f2%eta)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%etap == f2%etap)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sigma == f2%sigma)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sigma_p == f2%sigma_p)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%emit == f2%emit)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%norm_emit == f2%norm_emit)

end function eq_twiss

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_mode3 (f1, f2) result (is_eq)

implicit none

type(mode3_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 2, NOT]
is_eq = is_eq .and. all(f1%v == f2%v)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%a == f2%a)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%b == f2%b)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%c == f2%c)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%x == f2%x)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%y == f2%y)

end function eq_mode3

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_bookkeeping_state (f1, f2) result (is_eq)

implicit none

type(bookkeeping_state_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%attributes == f2%attributes)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%control == f2%control)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%floor_position == f2%floor_position)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%s_position == f2%s_position)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ref_energy == f2%ref_energy)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%mat6 == f2%mat6)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%rad_int == f2%rad_int)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ptc == f2%ptc)

end function eq_bookkeeping_state

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_rad_int_ele_cache (f1, f2) result (is_eq)

implicit none

type(rad_int_ele_cache_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%orb0 == f2%orb0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%g2_0 == f2%g2_0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%g3_0 == f2%g3_0)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%dg2_dorb == f2%dg2_dorb)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%dg3_dorb == f2%dg3_dorb)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%stale .eqv. f2%stale)

end function eq_rad_int_ele_cache

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_surface_grid_pt (f1, f2) result (is_eq)

implicit none

type(surface_grid_pt_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%orientation == f2%orientation)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_photon == f2%n_photon)
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%e_x == f2%e_x)
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%e_y == f2%e_y)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%intensity_x == f2%intensity_x)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%intensity_y == f2%intensity_y)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%intensity == f2%intensity)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%orbit == f2%orbit)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%orbit_rms == f2%orbit_rms)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%init_orbit == f2%init_orbit)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%init_orbit_rms == f2%init_orbit_rms)

end function eq_surface_grid_pt

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_surface_grid (f1, f2) result (is_eq)

implicit none

type(surface_grid_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%file == f2%file)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%type == f2%type)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%dr == f2%dr)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%r0 == f2%r0)
!! f_side.equality_test[type, 2, ALLOC]
is_eq = is_eq .and. (allocated(f1%pt) .eqv. allocated(f2%pt))
if (.not. is_eq) return
if (allocated(f1%pt)) is_eq = all(shape(f1%pt) == shape(f2%pt))
if (.not. is_eq) return
if (allocated(f1%pt)) is_eq = all(f1%pt == f2%pt)

end function eq_surface_grid

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_segmented_surface (f1, f2) result (is_eq)

implicit none

type(segmented_surface_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix == f2%ix)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%iy == f2%iy)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%x0 == f2%x0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%y0 == f2%y0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%z0 == f2%z0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%slope_x == f2%slope_x)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%slope_y == f2%slope_y)

end function eq_segmented_surface

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_target_point (f1, f2) result (is_eq)

implicit none

type(target_point_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%r == f2%r)

end function eq_target_point

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_photon_surface (f1, f2) result (is_eq)

implicit none

type(photon_surface_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%grid == f2%grid)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%segment == f2%segment)
!! f_side.equality_test[real, 2, NOT]
is_eq = is_eq .and. all(f1%curvature_xy == f2%curvature_xy)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%has_curvature .eqv. f2%has_curvature)

end function eq_photon_surface

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_photon_target (f1, f2) result (is_eq)

implicit none

type(photon_target_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%deterministic_grid .eqv. f2%deterministic_grid)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_grid == f2%ix_grid)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%iy_grid == f2%iy_grid)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%type == f2%type)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_corner == f2%n_corner)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%ele_loc == f2%ele_loc)
!! f_side.equality_test[type, 1, NOT]
is_eq = is_eq .and. all(f1%corner == f2%corner)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%center == f2%center)

end function eq_photon_target

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_photon_material (f1, f2) result (is_eq)

implicit none

type(photon_material_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%f0_m1 == f2%f0_m1)
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%f0_m2 == f2%f0_m2)
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%f_0 == f2%f_0)
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%f_h == f2%f_h)
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%f_hbar == f2%f_hbar)
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%f_hkl == f2%f_hkl)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%h_norm == f2%h_norm)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%l_ref == f2%l_ref)

end function eq_photon_material

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_photon_element (f1, f2) result (is_eq)

implicit none

type(photon_element_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%surface == f2%surface)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%target == f2%target)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%material == f2%material)

end function eq_photon_element

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_wall3d_vertex (f1, f2) result (is_eq)

implicit none

type(wall3d_vertex_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%x == f2%x)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%y == f2%y)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%radius_x == f2%radius_x)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%radius_y == f2%radius_y)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%tilt == f2%tilt)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%angle == f2%angle)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%x0 == f2%x0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%y0 == f2%y0)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%type == f2%type)

end function eq_wall3d_vertex

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_wall3d_section (f1, f2) result (is_eq)

implicit none

type(wall3d_section_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%name == f2%name)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%material == f2%material)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%v) .eqv. allocated(f2%v))
if (.not. is_eq) return
if (allocated(f1%v)) is_eq = all(shape(f1%v) == shape(f2%v))
if (.not. is_eq) return
if (allocated(f1%v)) is_eq = all(f1%v == f2%v)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%surface) .eqv. associated(f2%surface))
if (.not. is_eq) return
if (associated(f1%surface)) is_eq = (f1%surface == f2%surface)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%type == f2%type)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_vertex_input == f2%n_vertex_input)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_ele == f2%ix_ele)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_branch == f2%ix_branch)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%patch_in_region .eqv. f2%patch_in_region)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%thickness == f2%thickness)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%s == f2%s)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%x0 == f2%x0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%y0 == f2%y0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%x_safe == f2%x_safe)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%y_safe == f2%y_safe)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%dx0_ds == f2%dx0_ds)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%dy0_ds == f2%dy0_ds)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%x0_coef == f2%x0_coef)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%y0_coef == f2%y0_coef)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%dr_ds == f2%dr_ds)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%p1_coef == f2%p1_coef)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%p2_coef == f2%p2_coef)

end function eq_wall3d_section

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_wall3d (f1, f2) result (is_eq)

implicit none

type(wall3d_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_link == f2%n_link)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%thickness == f2%thickness)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%clear_material == f2%clear_material)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%opaque_material == f2%opaque_material)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%superimpose .eqv. f2%superimpose)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ele_anchor_pt == f2%ele_anchor_pt)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%section) .eqv. allocated(f2%section))
if (.not. is_eq) return
if (allocated(f1%section)) is_eq = all(shape(f1%section) == shape(f2%section))
if (.not. is_eq) return
if (allocated(f1%section)) is_eq = all(f1%section == f2%section)

end function eq_wall3d

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_taylor_term (f1, f2) result (is_eq)

implicit none

type(taylor_term_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%coef == f2%coef)
!! f_side.equality_test[integer, 1, NOT]
is_eq = is_eq .and. all(f1%expn == f2%expn)

end function eq_taylor_term

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_taylor (f1, f2) result (is_eq)

implicit none

type(taylor_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%ref == f2%ref)
!! f_side.equality_test[type, 1, PTR]
is_eq = is_eq .and. (associated(f1%term) .eqv. associated(f2%term))
if (.not. is_eq) return
if (associated(f1%term)) is_eq = all(shape(f1%term) == shape(f2%term))
if (.not. is_eq) return
if (associated(f1%term)) is_eq = all(f1%term == f2%term)

end function eq_taylor

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_control (f1, f2) result (is_eq)

implicit none

type(control_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%stack) .eqv. allocated(f2%stack))
if (.not. is_eq) return
if (allocated(f1%stack)) is_eq = all(shape(f1%stack) == shape(f2%stack))
if (.not. is_eq) return
if (allocated(f1%stack)) is_eq = all(f1%stack == f2%stack)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%slave == f2%slave)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_lord == f2%ix_lord)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_attrib == f2%ix_attrib)

end function eq_control

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_lat_param (f1, f2) result (is_eq)

implicit none

type(lat_param_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%n_part == f2%n_part)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%total_length == f2%total_length)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%unstable_factor == f2%unstable_factor)
!! f_side.equality_test[real, 2, NOT]
is_eq = is_eq .and. all(f1%t1_with_rf == f2%t1_with_rf)
!! f_side.equality_test[real, 2, NOT]
is_eq = is_eq .and. all(f1%t1_no_rf == f2%t1_no_rf)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%particle == f2%particle)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%default_tracking_species == f2%default_tracking_species)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%geometry == f2%geometry)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ixx == f2%ixx)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%stable .eqv. f2%stable)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%backwards_time_tracking .eqv. f2%backwards_time_tracking)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%bookkeeping_state == f2%bookkeeping_state)

end function eq_lat_param

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_mode_info (f1, f2) result (is_eq)

implicit none

type(mode_info_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%tune == f2%tune)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%emit == f2%emit)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%chrom == f2%chrom)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sigma == f2%sigma)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sigmap == f2%sigmap)

end function eq_mode_info

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_pre_tracker (f1, f2) result (is_eq)

implicit none

type(pre_tracker_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%who == f2%who)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_ele_start == f2%ix_ele_start)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_ele_end == f2%ix_ele_end)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%input_file == f2%input_file)

end function eq_pre_tracker

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_anormal_mode (f1, f2) result (is_eq)

implicit none

type(anormal_mode_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%emittance == f2%emittance)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%synch_int == f2%synch_int)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%j_damp == f2%j_damp)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%alpha_damp == f2%alpha_damp)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%chrom == f2%chrom)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%tune == f2%tune)

end function eq_anormal_mode

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_linac_normal_mode (f1, f2) result (is_eq)

implicit none

type(linac_normal_mode_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i2_e4 == f2%i2_e4)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i3_e7 == f2%i3_e7)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i5a_e6 == f2%i5a_e6)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i5b_e6 == f2%i5b_e6)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sig_e1 == f2%sig_e1)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%a_emittance_end == f2%a_emittance_end)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%b_emittance_end == f2%b_emittance_end)

end function eq_linac_normal_mode

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_normal_modes (f1, f2) result (is_eq)

implicit none

type(normal_modes_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%synch_int == f2%synch_int)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sige_e == f2%sige_e)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sig_z == f2%sig_z)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%e_loss == f2%e_loss)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%rf_voltage == f2%rf_voltage)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%pz_aperture == f2%pz_aperture)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%a == f2%a)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%b == f2%b)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%z == f2%z)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%lin == f2%lin)

end function eq_normal_modes

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_em_field (f1, f2) result (is_eq)

implicit none

type(em_field_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%e == f2%e)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%b == f2%b)
!! f_side.equality_test[real, 2, NOT]
is_eq = is_eq .and. all(f1%de == f2%de)
!! f_side.equality_test[real, 2, NOT]
is_eq = is_eq .and. all(f1%db == f2%db)

end function eq_em_field

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_track_map (f1, f2) result (is_eq)

implicit none

type(track_map_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%vec0 == f2%vec0)
!! f_side.equality_test[real, 2, NOT]
is_eq = is_eq .and. all(f1%mat6 == f2%mat6)

end function eq_track_map

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_track (f1, f2) result (is_eq)

implicit none

type(track_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%orb) .eqv. allocated(f2%orb))
if (.not. is_eq) return
if (allocated(f1%orb)) is_eq = all(shape(f1%orb) == shape(f2%orb))
if (.not. is_eq) return
if (allocated(f1%orb)) is_eq = all(f1%orb == f2%orb)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%field) .eqv. allocated(f2%field))
if (.not. is_eq) return
if (allocated(f1%field)) is_eq = all(shape(f1%field) == shape(f2%field))
if (.not. is_eq) return
if (allocated(f1%field)) is_eq = all(f1%field == f2%field)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%map) .eqv. allocated(f2%map))
if (.not. is_eq) return
if (allocated(f1%map)) is_eq = all(shape(f1%map) == shape(f2%map))
if (.not. is_eq) return
if (allocated(f1%map)) is_eq = all(f1%map == f2%map)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%ds_save == f2%ds_save)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_pt == f2%n_pt)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_bad == f2%n_bad)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_ok == f2%n_ok)

end function eq_track

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_synch_rad_common (f1, f2) result (is_eq)

implicit none

type(synch_rad_common_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%scale == f2%scale)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i2 == f2%i2)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i3 == f2%i3)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i5a == f2%i5a)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i5b == f2%i5b)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%i_calc_on .eqv. f2%i_calc_on)

end function eq_synch_rad_common

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_csr_parameter (f1, f2) result (is_eq)

implicit none

type(csr_parameter_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%ds_track_step == f2%ds_track_step)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%beam_chamber_height == f2%beam_chamber_height)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%sigma_cutoff == f2%sigma_cutoff)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_bin == f2%n_bin)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%particle_bin_span == f2%particle_bin_span)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_shield_images == f2%n_shield_images)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix1_ele_csr == f2%ix1_ele_csr)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix2_ele_csr == f2%ix2_ele_csr)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%lcsr_component_on .eqv. f2%lcsr_component_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%lsc_component_on .eqv. f2%lsc_component_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%tsc_component_on .eqv. f2%tsc_component_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%small_angle_approx .eqv. f2%small_angle_approx)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%print_taylor_warning .eqv. f2%print_taylor_warning)

end function eq_csr_parameter

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_bmad_common (f1, f2) result (is_eq)

implicit none

type(bmad_common_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%max_aperture_limit == f2%max_aperture_limit)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%d_orb == f2%d_orb)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%default_ds_step == f2%default_ds_step)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%significant_length == f2%significant_length)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%rel_tol_tracking == f2%rel_tol_tracking)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%abs_tol_tracking == f2%abs_tol_tracking)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%rel_tol_adaptive_tracking == f2%rel_tol_adaptive_tracking)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%abs_tol_adaptive_tracking == f2%abs_tol_adaptive_tracking)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%init_ds_adaptive_tracking == f2%init_ds_adaptive_tracking)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%min_ds_adaptive_tracking == f2%min_ds_adaptive_tracking)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%fatal_ds_adaptive_tracking == f2%fatal_ds_adaptive_tracking)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%electric_dipole_moment == f2%electric_dipole_moment)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%taylor_order == f2%taylor_order)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%default_integ_order == f2%default_integ_order)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ptc_max_fringe_order == f2%ptc_max_fringe_order)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%use_hard_edge_drifts .eqv. f2%use_hard_edge_drifts)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%sr_wakes_on .eqv. f2%sr_wakes_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%lr_wakes_on .eqv. f2%lr_wakes_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%mat6_track_symmetric .eqv. f2%mat6_track_symmetric)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%auto_bookkeeper .eqv. f2%auto_bookkeeper)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%space_charge_on .eqv. f2%space_charge_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%coherent_synch_rad_on .eqv. f2%coherent_synch_rad_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%spin_tracking_on .eqv. f2%spin_tracking_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%radiation_damping_on .eqv. f2%radiation_damping_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%radiation_fluctuations_on .eqv. f2%radiation_fluctuations_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%conserve_taylor_maps .eqv. f2%conserve_taylor_maps)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%absolute_time_tracking_default .eqv. f2%absolute_time_tracking_default)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%convert_to_kinetic_momentum .eqv. f2%convert_to_kinetic_momentum)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%aperture_limit_on .eqv. f2%aperture_limit_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%debug .eqv. f2%debug)

end function eq_bmad_common

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_rad_int1 (f1, f2) result (is_eq)

implicit none

type(rad_int1_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i0 == f2%i0)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i1 == f2%i1)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i2 == f2%i2)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i3 == f2%i3)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i4a == f2%i4a)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i4b == f2%i4b)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i4z == f2%i4z)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i5a == f2%i5a)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i5b == f2%i5b)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%i6b == f2%i6b)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%lin_i2_e4 == f2%lin_i2_e4)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%lin_i3_e7 == f2%lin_i3_e7)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%lin_i5a_e6 == f2%lin_i5a_e6)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%lin_i5b_e6 == f2%lin_i5b_e6)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%lin_norm_emit_a == f2%lin_norm_emit_a)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%lin_norm_emit_b == f2%lin_norm_emit_b)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%n_steps == f2%n_steps)

end function eq_rad_int1

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_rad_int_all_ele (f1, f2) result (is_eq)

implicit none

type(rad_int_all_ele_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%ele) .eqv. allocated(f2%ele))
if (.not. is_eq) return
if (allocated(f1%ele)) is_eq = all(shape(f1%ele) == shape(f2%ele))
if (.not. is_eq) return
if (allocated(f1%ele)) is_eq = all(f1%ele == f2%ele)

end function eq_rad_int_all_ele

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_ptc_genfield (f1, f2) result (is_eq)

implicit none

type(ptc_genfield_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%vec0 == f2%vec0)

end function eq_ptc_genfield

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_ele (f1, f2) result (is_eq)

implicit none

type(ele_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%name == f2%name)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%type == f2%type)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%alias == f2%alias)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%component_name == f2%component_name)
!! f_side.equality_test[character, 0, PTR]

is_eq = is_eq .and. (associated(f1%descrip) .eqv. associated(f2%descrip))
if (.not. is_eq) return
if (associated(f1%descrip)) is_eq = (f1%descrip == f2%descrip)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%a == f2%a)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%b == f2%b)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%z == f2%z)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%x == f2%x)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%y == f2%y)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%bookkeeping_state == f2%bookkeeping_state)
!! f_side.equality_test[type, 1, PTR]
is_eq = is_eq .and. (associated(f1%control_var) .eqv. associated(f2%control_var))
if (.not. is_eq) return
if (associated(f1%control_var)) is_eq = all(shape(f1%control_var) == shape(f2%control_var))
if (.not. is_eq) return
if (associated(f1%control_var)) is_eq = all(f1%control_var == f2%control_var)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%em_field) .eqv. associated(f2%em_field))
if (.not. is_eq) return
if (associated(f1%em_field)) is_eq = (f1%em_field == f2%em_field)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%floor == f2%floor)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%ptc_genfield == f2%ptc_genfield)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%mode3) .eqv. associated(f2%mode3))
if (.not. is_eq) return
if (associated(f1%mode3)) is_eq = (f1%mode3 == f2%mode3)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%photon) .eqv. associated(f2%photon))
if (.not. is_eq) return
if (associated(f1%photon)) is_eq = (f1%photon == f2%photon)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%rad_int_cache) .eqv. associated(f2%rad_int_cache))
if (.not. is_eq) return
if (associated(f1%rad_int_cache)) is_eq = (f1%rad_int_cache == f2%rad_int_cache)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%space_charge) .eqv. associated(f2%space_charge))
if (.not. is_eq) return
if (associated(f1%space_charge)) is_eq = (f1%space_charge == f2%space_charge)
!! f_side.equality_test[type, 1, NOT]
is_eq = is_eq .and. all(f1%taylor == f2%taylor)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%wake) .eqv. associated(f2%wake))
if (.not. is_eq) return
if (associated(f1%wake)) is_eq = (f1%wake == f2%wake)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%wall3d) .eqv. associated(f2%wall3d))
if (.not. is_eq) return
if (associated(f1%wall3d)) is_eq = (f1%wall3d == f2%wall3d)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%wig) .eqv. associated(f2%wig))
if (.not. is_eq) return
if (associated(f1%wig)) is_eq = (f1%wig == f2%wig)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%map_ref_orb_in == f2%map_ref_orb_in)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%map_ref_orb_out == f2%map_ref_orb_out)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%time_ref_orb_in == f2%time_ref_orb_in)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%time_ref_orb_out == f2%time_ref_orb_out)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%value == f2%value)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%old_value == f2%old_value)
!! f_side.equality_test[real, 1, NOT]
is_eq = is_eq .and. all(f1%vec0 == f2%vec0)
!! f_side.equality_test[real, 2, NOT]
is_eq = is_eq .and. all(f1%mat6 == f2%mat6)
!! f_side.equality_test[real, 2, NOT]
is_eq = is_eq .and. all(f1%c_mat == f2%c_mat)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%gamma_c == f2%gamma_c)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%s == f2%s)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%ref_time == f2%ref_time)
!! f_side.equality_test[real, 3, PTR]
is_eq = is_eq .and. (associated(f1%r) .eqv. associated(f2%r))
if (.not. is_eq) return
if (associated(f1%r)) is_eq = all(shape(f1%r) == shape(f2%r))
if (.not. is_eq) return
if (associated(f1%r)) is_eq = all(f1%r == f2%r)
!! f_side.equality_test[real, 1, PTR]
is_eq = is_eq .and. (associated(f1%a_pole) .eqv. associated(f2%a_pole))
if (.not. is_eq) return
if (associated(f1%a_pole)) is_eq = all(shape(f1%a_pole) == shape(f2%a_pole))
if (.not. is_eq) return
if (associated(f1%a_pole)) is_eq = all(f1%a_pole == f2%a_pole)
!! f_side.equality_test[real, 1, PTR]
is_eq = is_eq .and. (associated(f1%b_pole) .eqv. associated(f2%b_pole))
if (.not. is_eq) return
if (associated(f1%b_pole)) is_eq = all(shape(f1%b_pole) == shape(f2%b_pole))
if (.not. is_eq) return
if (associated(f1%b_pole)) is_eq = all(f1%b_pole == f2%b_pole)
!! f_side.equality_test[real, 1, PTR]
is_eq = is_eq .and. (associated(f1%a_pole_elec) .eqv. associated(f2%a_pole_elec))
if (.not. is_eq) return
if (associated(f1%a_pole_elec)) is_eq = all(shape(f1%a_pole_elec) == shape(f2%a_pole_elec))
if (.not. is_eq) return
if (associated(f1%a_pole_elec)) is_eq = all(f1%a_pole_elec == f2%a_pole_elec)
!! f_side.equality_test[real, 1, PTR]
is_eq = is_eq .and. (associated(f1%b_pole_elec) .eqv. associated(f2%b_pole_elec))
if (.not. is_eq) return
if (associated(f1%b_pole_elec)) is_eq = all(shape(f1%b_pole_elec) == shape(f2%b_pole_elec))
if (.not. is_eq) return
if (associated(f1%b_pole_elec)) is_eq = all(f1%b_pole_elec == f2%b_pole_elec)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%key == f2%key)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%sub_key == f2%sub_key)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_ele == f2%ix_ele)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_branch == f2%ix_branch)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%slave_status == f2%slave_status)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_slave == f2%n_slave)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix1_slave == f2%ix1_slave)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix2_slave == f2%ix2_slave)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%lord_status == f2%lord_status)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_lord == f2%n_lord)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ic1_lord == f2%ic1_lord)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ic2_lord == f2%ic2_lord)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_pointer == f2%ix_pointer)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ixx == f2%ixx)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%iyy == f2%iyy)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%mat6_calc_method == f2%mat6_calc_method)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%tracking_method == f2%tracking_method)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%spin_tracking_method == f2%spin_tracking_method)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ptc_integration_type == f2%ptc_integration_type)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%field_calc == f2%field_calc)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%aperture_at == f2%aperture_at)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%aperture_type == f2%aperture_type)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%orientation == f2%orientation)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%symplectify .eqv. f2%symplectify)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%mode_flip .eqv. f2%mode_flip)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%multipoles_on .eqv. f2%multipoles_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%scale_multipoles .eqv. f2%scale_multipoles)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%taylor_map_includes_offsets .eqv. f2%taylor_map_includes_offsets)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%field_master .eqv. f2%field_master)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%is_on .eqv. f2%is_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%old_is_on .eqv. f2%old_is_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%logic .eqv. f2%logic)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%bmad_logic .eqv. f2%bmad_logic)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%select .eqv. f2%select)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%csr_calc_on .eqv. f2%csr_calc_on)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%offset_moves_aperture .eqv. f2%offset_moves_aperture)

end function eq_ele

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_complex_taylor_term (f1, f2) result (is_eq)

implicit none

type(complex_taylor_term_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%coef == f2%coef)
!! f_side.equality_test[integer, 1, NOT]
is_eq = is_eq .and. all(f1%expn == f2%expn)

end function eq_complex_taylor_term

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_complex_taylor (f1, f2) result (is_eq)

implicit none

type(complex_taylor_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[complex, 0, NOT]
is_eq = is_eq .and. (f1%ref == f2%ref)
!! f_side.equality_test[type, 1, PTR]
is_eq = is_eq .and. (associated(f1%term) .eqv. associated(f2%term))
if (.not. is_eq) return
if (associated(f1%term)) is_eq = all(shape(f1%term) == shape(f2%term))
if (.not. is_eq) return
if (associated(f1%term)) is_eq = all(f1%term == f2%term)

end function eq_complex_taylor

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_normal_form (f1, f2) result (is_eq)

implicit none

type(normal_form_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 1, NOT]
is_eq = is_eq .and. all(f1%m == f2%m)
!! f_side.equality_test[type, 1, NOT]
is_eq = is_eq .and. all(f1%a == f2%a)
!! f_side.equality_test[type, 1, NOT]
is_eq = is_eq .and. all(f1%a_inv == f2%a_inv)
!! f_side.equality_test[type, 1, NOT]
is_eq = is_eq .and. all(f1%dhdj == f2%dhdj)
!! f_side.equality_test[type, 1, NOT]
is_eq = is_eq .and. all(f1%f == f2%f)
!! f_side.equality_test[type, 1, NOT]
is_eq = is_eq .and. all(f1%l == f2%l)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%ele_origin) .eqv. associated(f2%ele_origin))
if (.not. is_eq) return
if (associated(f1%ele_origin)) is_eq = (f1%ele_origin == f2%ele_origin)

end function eq_normal_form

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_branch (f1, f2) result (is_eq)

implicit none

type(branch_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%name == f2%name)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_branch == f2%ix_branch)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_from_branch == f2%ix_from_branch)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_from_ele == f2%ix_from_ele)
!! f_side.equality_test[integer, 0, PTR]

is_eq = is_eq .and. (associated(f1%n_ele_track) .eqv. associated(f2%n_ele_track))
if (.not. is_eq) return
if (associated(f1%n_ele_track)) is_eq = (f1%n_ele_track == f2%n_ele_track)
!! f_side.equality_test[integer, 0, PTR]

is_eq = is_eq .and. (associated(f1%n_ele_max) .eqv. associated(f2%n_ele_max))
if (.not. is_eq) return
if (associated(f1%n_ele_max)) is_eq = (f1%n_ele_max == f2%n_ele_max)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%a) .eqv. associated(f2%a))
if (.not. is_eq) return
if (associated(f1%a)) is_eq = (f1%a == f2%a)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%b) .eqv. associated(f2%b))
if (.not. is_eq) return
if (associated(f1%b)) is_eq = (f1%b == f2%b)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%z) .eqv. associated(f2%z))
if (.not. is_eq) return
if (associated(f1%z)) is_eq = (f1%z == f2%z)
!! f_side.equality_test[type, 1, PTR]
is_eq = is_eq .and. (associated(f1%ele) .eqv. associated(f2%ele))
if (.not. is_eq) return
if (associated(f1%ele)) is_eq = all(shape(f1%ele) == shape(f2%ele))
if (.not. is_eq) return
if (associated(f1%ele)) is_eq = all(f1%ele == f2%ele)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%param) .eqv. associated(f2%param))
if (.not. is_eq) return
if (associated(f1%param)) is_eq = (f1%param == f2%param)
!! f_side.equality_test[type, 0, PTR]

is_eq = is_eq .and. (associated(f1%wall3d) .eqv. associated(f2%wall3d))
if (.not. is_eq) return
if (associated(f1%wall3d)) is_eq = (f1%wall3d == f2%wall3d)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%normal_form_with_rf == f2%normal_form_with_rf)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%normal_form_no_rf == f2%normal_form_no_rf)

end function eq_branch

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_lat (f1, f2) result (is_eq)

implicit none

type(lat_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%use_name == f2%use_name)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%lattice == f2%lattice)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%input_file_name == f2%input_file_name)
!! f_side.equality_test[character, 0, NOT]
is_eq = is_eq .and. (f1%title == f2%title)
!! f_side.equality_test[character, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%attribute_alias) .eqv. allocated(f2%attribute_alias))
if (.not. is_eq) return
if (allocated(f1%attribute_alias)) is_eq = all(shape(f1%attribute_alias) == shape(f2%attribute_alias))
if (.not. is_eq) return
if (allocated(f1%attribute_alias)) is_eq = all(f1%attribute_alias == f2%attribute_alias)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%a == f2%a)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%b == f2%b)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%z == f2%z)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%param == f2%param)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%lord_state == f2%lord_state)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%ele_init == f2%ele_init)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%beam_start_ele == f2%beam_start_ele)
!! f_side.equality_test[type, 1, PTR]
is_eq = is_eq .and. (associated(f1%ele) .eqv. associated(f2%ele))
if (.not. is_eq) return
if (associated(f1%ele)) is_eq = all(shape(f1%ele) == shape(f2%ele))
if (.not. is_eq) return
if (associated(f1%ele)) is_eq = all(f1%ele == f2%ele)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%branch) .eqv. allocated(f2%branch))
if (.not. is_eq) return
if (allocated(f1%branch)) is_eq = all(shape(f1%branch) == shape(f2%branch))
if (.not. is_eq) return
if (allocated(f1%branch)) is_eq = all(f1%branch == f2%branch)
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%control) .eqv. allocated(f2%control))
if (.not. is_eq) return
if (allocated(f1%control)) is_eq = all(shape(f1%control) == shape(f2%control))
if (.not. is_eq) return
if (allocated(f1%control)) is_eq = all(f1%control == f2%control)
!! f_side.equality_test[type, 1, PTR]
is_eq = is_eq .and. (associated(f1%surface) .eqv. associated(f2%surface))
if (.not. is_eq) return
if (associated(f1%surface)) is_eq = all(shape(f1%surface) == shape(f2%surface))
if (.not. is_eq) return
if (associated(f1%surface)) is_eq = all(f1%surface == f2%surface)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%beam_start == f2%beam_start)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%pre_tracker == f2%pre_tracker)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%version == f2%version)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_ele_track == f2%n_ele_track)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_ele_max == f2%n_ele_max)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_control_max == f2%n_control_max)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_ic_max == f2%n_ic_max)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%input_taylor_order == f2%input_taylor_order)
!! f_side.equality_test[integer, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%ic) .eqv. allocated(f2%ic))
if (.not. is_eq) return
if (allocated(f1%ic)) is_eq = all(shape(f1%ic) == shape(f2%ic))
if (.not. is_eq) return
if (allocated(f1%ic)) is_eq = all(f1%ic == f2%ic)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%photon_type == f2%photon_type)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%absolute_time_tracking .eqv. f2%absolute_time_tracking)
!! f_side.equality_test[logical, 0, NOT]
is_eq = is_eq .and. (f1%ptc_uses_hard_edge_drifts .eqv. f2%ptc_uses_hard_edge_drifts)

end function eq_lat

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_bunch (f1, f2) result (is_eq)

implicit none

type(bunch_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%particle) .eqv. allocated(f2%particle))
if (.not. is_eq) return
if (allocated(f1%particle)) is_eq = all(shape(f1%particle) == shape(f2%particle))
if (.not. is_eq) return
if (allocated(f1%particle)) is_eq = all(f1%particle == f2%particle)
!! f_side.equality_test[integer, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%ix_z) .eqv. allocated(f2%ix_z))
if (.not. is_eq) return
if (allocated(f1%ix_z)) is_eq = all(shape(f1%ix_z) == shape(f2%ix_z))
if (.not. is_eq) return
if (allocated(f1%ix_z)) is_eq = all(f1%ix_z == f2%ix_z)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%charge_tot == f2%charge_tot)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%charge_live == f2%charge_live)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%z_center == f2%z_center)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%t_center == f2%t_center)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_ele == f2%ix_ele)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%ix_bunch == f2%ix_bunch)

end function eq_bunch

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_beam_spin (f1, f2) result (is_eq)

implicit none

type(beam_spin_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%polarization == f2%polarization)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%theta == f2%theta)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%phi == f2%phi)

end function eq_beam_spin

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_bunch_params (f1, f2) result (is_eq)

implicit none

type(bunch_params_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%x == f2%x)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%y == f2%y)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%z == f2%z)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%a == f2%a)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%b == f2%b)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%c == f2%c)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%centroid == f2%centroid)
!! f_side.equality_test[type, 0, NOT]
is_eq = is_eq .and. (f1%spin == f2%spin)
!! f_side.equality_test[real, 2, NOT]
is_eq = is_eq .and. all(f1%sigma == f2%sigma)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%s == f2%s)
!! f_side.equality_test[real, 0, NOT]
is_eq = is_eq .and. (f1%charge_live == f2%charge_live)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_particle_tot == f2%n_particle_tot)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_particle_live == f2%n_particle_live)
!! f_side.equality_test[integer, 0, NOT]
is_eq = is_eq .and. (f1%n_particle_lost_in_ele == f2%n_particle_lost_in_ele)

end function eq_bunch_params

!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------

elemental function eq_beam (f1, f2) result (is_eq)

implicit none

type(beam_struct), intent(in) :: f1, f2
logical is_eq

!

is_eq = .true.
!! f_side.equality_test[type, 1, ALLOC]
is_eq = is_eq .and. (allocated(f1%bunch) .eqv. allocated(f2%bunch))
if (.not. is_eq) return
if (allocated(f1%bunch)) is_eq = all(shape(f1%bunch) == shape(f2%bunch))
if (.not. is_eq) return
if (allocated(f1%bunch)) is_eq = all(f1%bunch == f2%bunch)

end function eq_beam
end module
